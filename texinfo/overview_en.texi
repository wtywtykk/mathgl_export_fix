@chapter Overview

@cindex MathGL overview

MathGL is ...
@itemize @bullet
@item
a library for making high-quality scientific graphics under Linux and Windows;
@item
a library for the fast data plotting and handling of large data arrays;
@item
a library for working in window and console modes and for easy embedding into other programs;
@item
a library with large and growing set of graphics.
@end itemize

@menu
* What is MathGL?::
* MathGL features::
* Installation::
* Quick guide::
* Changes from v.1::
* Utilities::
* Thanks::
@end menu

@node What is MathGL?, MathGL features, , Overview
@section What is MathGL?

A code for making high-quality scientific graphics under Linux and Windows. A  code for the fast handling and plotting of large data arrays. A code for working in window and console regimes and for easy including into another program. A code with large and renewal set of graphics. Exactly such a code I tried to put in MathGL library.

At this version (@value{VERSION}) MathGL has more than 50 general types of graphics for 1d, 2d and 3d data arrays. It can export graphics to bitmap and vector (EPS or SVG) files. It has OpenGL interface and can be used from console programs. It has functions for data handling and script MGL language for simplification of data plotting. It also has several types of transparency and smoothed lighting, vector fonts and TeX-like symbol parsing, arbitrary curvilinear coordinate system and many other useful things (see pictures section at @uref{http://mathgl.sf.net/, homepage}). Finally it is platform-independent and free (under GPL v.2.0 or later license).

@node MathGL features, Installation, What is MathGL?, Overview
@section MathGL features

MathGL can plot a wide range of graphics. It includes:
@itemize @bullet
@item
one-dimensional (Plot, Area, Bars, Step, Stem, Torus, Chart, Error, Tube, Mark, @pxref{1D plotting});

@item
two-dimensional plots (Mesh, Surf, Dens, Cont, ContF, Boxs, Axial, Fall, Belt, Tile, @pxref{2D plotting});

@item
three-dimensional plots (Surf3, Dens3, Cont3, ContF3, Cloud-like, @pxref{3D plotting});

@item
dual data plots: vector fields Vect, flow threads Flow, mapping chart Map, surfaces and isosurfaces, transparent or colored (i.e. with transparency or color varied) by other data SurfA, SurfC, Surf3A, Surf3C (@pxref{Dual plotting});

@item
and so on. For details see @pxref{MathGL core}.
@end itemize

In fact, I created the functions for drawing of all the types of scientific plots that I know. The list of plots is growing; if you need some special type of a plot then please email me @email{mathgl.abalakin@@gmail.com, e-mail} and it will appear in the new version.

I tried to make plots as nice looking as possible: e.g., a surface can be transparent and highlighted by several (up to 10) light sources. Most of the drawing functions have 2 variants: simple one for the fast plotting of data, complex one for specifying of the exact position of the plot (including parametric representation). Resulting image can be saved in bitmap PNG, JPEG, TGA, BMP format, or in vector EPS, SVG or TeX format, or in 3D formats OBJ, OFF, STL or X3D, or in IDTF format which can be converted into U3D.

All texts are drawn by vector fonts, which allows for high scalability and portability. Texts may contain commands for: some of the TeX-like symbols, changing index (upper or lower indexes) and the style of font inside the text string (@pxref{Font styles}). Texts of ticks are rotated with axis rotation. It is possible to create a legend of plot and put text in an arbitrary position on the plot. Arbitrary text encoding (by the help of function @code{setlocale()}) and UTF-16 encoding are supported.

Special class mglData is used for data encapsulation (@pxref{Data processing}). In addition to a safe creation and deletion of data arrays it includes functions for data processing (smoothing, differentiating, integrating, interpolating and so on) and reading of data files with automatic size determination. Class mglData can handle arrays with up to three dimensions (arrays which depend on up to 3 independent indexes @math{a_@{ijk@}}). Using an array with higher number of dimensions is not meaningful, because I do not know how it can be plotted. Data filling and modification may be done manually or by textual formulas.

There is fast evaluation of a textual mathematical expression (@pxref{Textual formulas}). It is based on string precompilation to tree-like code at the creation of class instance. At evaluation stage code performs only fast tree-walk and returns the value of the expression. In addition to changing data values, textual formulas are also used for drawing in @emph{arbitrary} curvilinear coordinates. A set of such curvilinear coordinates is limited only by user's imagination rather than a fixed list like: polar, parabolic, spherical, and so on.

@node Installation, Quick guide, MathGL features, Overview
@section Installation

MathGL can be installed in 4 different ways.
@enumerate
@item
Compile from sources. The standard script for autoconf/automake tool is included in the library. To run it, one should execute 3 commands: @code{./configure} after it @code{make} and @code{make install} with root/sudo rights. Sometimes after installation you may need to update the library list -- just execute @code{ldconfig} with root/sudo rights. Note, that if you try SVN version then you should run @code{./bootstrap} before configure.

Script @code{./configure} have several additional options which are switched off by default. They are: @code{--enable-fltk, --enable-glut, --enable-qt} for ebabling FLTK, GLUT and/or Qt windows; @code{--enable-jpeg, --enable-gif, --enable-hdf5} for enabling corresponding file formats; @code{--enable-all} for enabling all additional features. For using @code{double} as base internal data type use option @code{--enable-double}. For enabling language interfaces use @code{--enable-python, --enable-octave} or @code{--enable-langall} for all languages. The full list of options can be viewed by command @code{./configure --help}.

@item
One can use also CMake for building MathGL library if autoconf/automake tools are absent. For example, it is the typical situation for Windows, MacOS and/or using of non-GNU compilers. You can use WYSIWYG tools to change CMake build options. Just specify the features you need and resolve all possible conflicts -- specify the paths for header files or libraries if they are not found automatically. After it run @code{make} and @code{make install} with root/sudo rights.

@item
Use a precompiled binary. There are binaries for MinGW (platform Win32). For a precompiled variant one needs only to unpack the archive to the location of the compiler (or in any other folder and setup paths). By default, precompiled versions include the support of GSL (www.gsl.org) and PNG. So, one needs to have these libraries installed on system (it can be found, for example, at @uref{http://gnuwin32.sourceforge.net/packages.html}).

@item
Install precompiled versions from standard packages (RPM, deb, DevPak and so on, see @uref{http://mathgl.sf.net/download.html, Download} section at homepage).
@end enumerate


@c ------------------------------------------------------------------
@node  Quick guide, Changes from v.1, Installation, Overview
@section Quick guide

There are 3 steps to prepare the plot in MathGL: (1) prepare data to be plotted, (2) setup plot, (3) plot data. Let me show this on the example of surface plotting.

First we need the data. MathGL use its own class @code{mglData} to handle data arrays (see @ref{Data processing}). This class give ability to handle data arrays by more or less format independent way. So, create it
@verbatim
    int main()
    {
        mglData dat(30,40);	// data to for plotting
        for(long i=0;i<30;i++)   for(long j=0;j<40;j++)
            dat.a[i+30*j] = 1/(1+(i-15)*(i-15)/225.+(j-20)*(j-20)/400.);
@end verbatim
Here I create matrix 30*40 and initialize it by formula. Note, that I use @code{long} type for indexes @var{i}, @var{j} because data arrays can be really large and @code{long} type will automatically provide proper indexing.

Next step is setup of the plot. The only setup I need is axis rotation and lighting.
@verbatim
        mglGraph gr;		// class for plot drawing
        gr.Rotate(50,60);	// rotate axis
        gr.Light(true);		// enable lighting
@end verbatim

Everything is ready. And surface can be plotted.
@verbatim
        gr.Surf(dat);		// plot surface
@end verbatim
Basically plot is done. But I decide to add yellow (@samp{y} color, see @ref{Color styles}) contour lines on the surface. To do it I can just add:
@verbatim
        gr.Cont(dat,"y");	// plot yellow contour lines
@end verbatim
This demonstrate one of base MathGL concept (see, @ref{General concepts}) -- ``new drawing never clears things drawn already''. So, you can just consequently call different plotting functions to obtain ``combined'' plot. For example, if one need to draw axis then he can just call one more plotting function 
@verbatim
        gr.Axis();			// draw axis
@end verbatim

Now picture is ready and we can save it in a file.
@verbatim
        gr.WriteFrame("sample.png");	// save it
    }
@end verbatim

To compile your program, you need to specify the linker option @code{-lmgl}.

This is enough for a compilation of console program or with external (non-MathGL) window library. If you want to use FLTK or Qt windows provided by MathGL then you need to add the option @code{-lmgl-wnd}. Fortran users also should add C++ library by the option @code{-lstdc++}.

@c ------------------------------------------------------------------
@node  Changes from v.1, Utilities, Quick guide, Overview
@section Changes from v.1.*

* mglGraph class is single plotter class instead of mglGraphZB, mglGraphPS and so on.
* Text style and text color positions are swapped. I.e. text style @samp{r:C} give red centered text, but not roman dark cyan text as for v.1.*.
* ColumnPlot() indexing is reverted.

@c ------------------------------------------------------------------
@node  Utilities, Thanks, Changes from v.1, Overview
@section Utilities for parsing MGL

MathGL library provides several tools for parsing MGL scripts. There is tools saving it to bitmap or vectorial images (@code{mgl2conv}). Tool @code{mglview} show MGL script and allow to rotate and setup the image. Also you can translate MGL script to C++ file by help of @code{mgl2cpp} tool.

All of this tools have similar set of arguments. First argument is name of script file, next argument is optional output file name, last arguments are options. There are options for setting script parameters (it is @code{$0, $1, ... $9}) and locale settings. The script parameters have format @samp{-Nval}. Here N=0,1...9 is parameter ID and val is its value. For example, option @samp{-1test} set to substitute @samp{test} instead of @code{$1} in the script. Option -Lval set locale to val. For example, @samp{-Lutf8} will set UTF-8 locale for script.

Both tools expect stdin input if script file is not specified. This allows to use Linux pipes to send script and produce plot.

Additionally you can create animated GIF file or a set of JPEG files with names @samp{frameNNNN.jpg} (here @samp{NNNN} is frame index). You should use @code{mgl2gif} tool and specify the values of @code{$0} parameter for making animation. Values of the parameter @code{$0} can be specified inside the script by comment @code{##a val} for each value @code{val} (one comment for one value) or by option(s) @samp{-Aval}. Also you can specify a cycle for animation by comment @code{##c v1 v2 dv} or by option @code{-Cn1:n2}. Tool @code{mgl2gif} will execute script several times (once for each specified value of @code{$0}) and save result in animated GIF file. For saving each frame in JPEG just add command @code{write ''} at the end of the script.


@node Thanks, , Utilities, Overview
@section Thanks

@itemize @bullet
@item
My special thanks to Marina Balakina for the patience during the writing of this library and for the help in documentation writing and spelling.
@item
I'm thankful to D. Kulagin and S.M. Plis for making Debian packages.
@item
I'm thankful to M. Vidassov for the help in handling solid UTF-8 fonts.
@item
I'm thankful to N. Troickiy and V. Lipatov for making RPM packages.
@item
I'm thankful to S. Skobelev, A. Korotkevich, V. Onuchin, S.M. Plis, R. Kiselev, A. Ivanov, M. Vidiassov and V. Lipatov for fruitful comments.
@end itemize
