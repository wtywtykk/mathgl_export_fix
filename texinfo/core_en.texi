@c ------------------------------------------------------------------
@chapter MathGL core
@cindex mglGraph

The core of MathGL is @strong{mglGraph} class defined in @code{#include <mgl/mgl.h>}. It contains a lot of plotting functions for 1D, 2D and 3D plots. It also encapsulates parameters for axes drawing. Moreover an arbitrary coordinate transformation may be used for each axis. All plotting functions use data encapsulated in mglData class (@pxref{mglData class}) that allows to check sizes of used arrays easily. Also it have many functions for data handling: modify it by formulas, find momentums and distribution (histogram), apply operator (differentiate, integrate, transpose, Fourier and so on), change data sizes (interpolate, squeeze, crop and so on). Additional information about colors, fonts, formula parsing can be found in @ref{Other classes}.

Note that class mglGraph is abstract and contains only interface functions for plotting but does not make plot by itself. For plotting in specific device (screen, memory or file) one should use derived classes: mglGraphZB -- for bitmap picture in file or in memory; mglGraphPS -- for vector PostScript picture; mglGraphGL -- for drawing using OpenGL, or for GLUT windows interface; and so on, @pxref{Plotter classes}. If you want not only to create a picture but to view it in a window/widget or to run animation and so on then look at @ref{Widget classes}.

There is a C++ wrapper class which have the same name @code{mglGraph} and defined in @code{mgl/mgl_graph.h}. You can use this class even with non-GNU compilers (i.e. in Borland or Microsoft one), but you @strong{should not include} any @code{mgl/mgl.h} or @code{mgl/mgl_parse.h} headers in this case! This wrapper class also used as base for all SWIG-based interfaces (Python, Octave and so on). So, later it is refered as @samp{Python} class for distinguish from original @samp{C++} class defined in @code{mgl/mgl.h} .

@menu
* Graphics setup:: 
* Axis settings:: 
* Transformation matrix:: 
* Export to file:: 
* Primitives drawing:: 
* Text printing:: 
* Axis and Colorbar:: 
* Legend:: 
* 1D plotting:: 
* 2D plotting:: 
* 3D plotting:: 
* Dual plotting:: 
* Vector fields:: 
* Other plotting:: 
* Nonlinear fitting:: 
* Data distributions:: 
* Frames/Animation:: 
* IDTF functions:: 
@end menu

@c ##################################################################
@node Graphics setup, Axis settings, , MathGL core
@section Graphics setup
@cindex MathGL setup

Functions and variables in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DefaultPlotParam ()
@deftypefnx {C function} @code{void} mgl_set_def_param (@code{HMGL} gr)
Restore initial values for all of parameters except described in @ref{Zooming}.
@end deftypefn

@menu
* Transparency:: 
* Lighting:: 
* Fog:: 
* Default sizes:: 
* Zooming:: 
* Cutting:: 
* Font settings:: 
* Palette and colors:: 
* Error handling:: 
* Other settings:: 
@end menu

@c ==================================================================
@node Transparency, Lighting, , Graphics setup
@subsection Transparency
@cindex Alpha
@cindex SetAlphaDef
@cindex SetTransparent
@cindex SetTranspType

There are several functions and variables for setup transparency. The general function is @code{Alpha()} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{Alpha()} call (with one exception, mglGraphGL). Function @code{SetAlphaDef} specify the default value of alpha-channel. You may switch off transparency of selected plot by function @code{SetTransparent}. Finally, function @code{SetTranspType} set the kind of transparency. @sref{Transparent surface sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{bool} Alpha (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_alpha (@code{HMGL} gr, @code{int} enable)
Sets the transparency on/off and returns previous value of transparency. It is recommended to call this function before any plotting command. In any case it must be called before @code{Finish()} function if the last is used. Default value is transparency off. Unfortunately it switches the transparency on/off for all subplots. Use @code{SetTransparent(false)} in particular plot to disable its transparency.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetAlphaDef (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_alpha_default (@code{HMGL} gr, @code{float} alpha)
Sets default value of alpha channel (transparency) for all plotting functions. Note, that OpenGL (mglGraphGL) has incorrect drawing for large values of alpha in case of several overlapping surfaces.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTransparent (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_transp (@code{HMGL} gr, @code{int} enable)
Flag which temporary switches transparency on/off for the plot. This is the same as @code{Alpha(val)} but more correctly work in mglGraphGL class.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTranspType (@code{int} type)
@deftypefnx {C function} @code{void} mgl_set_transp_type (@code{HMGL} gr, @code{int} enable)
Set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{SetAlphaDef(0.3)} or less for lamp-like transparency. @xref{Normal transparency}, @ref{Glass-like transparency}, @ref{Lamp-like transparency}.
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} AlphaDef
Default value of alpha channel. See @code{SetAlphaDef()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} Transparent
Flag which temporary switches transparency on/off for the plot. See @code{SetTransparent()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{int} TranspType
This variable set the transparency type. See @code{SetTranspType()}.
@end deftypecv

@c ==================================================================
@node Lighting, Fog, Transparency, Graphics setup
@subsection Lighting
@cindex Light
@cindex Ambient
@cindex AddLight

There are several functions for setup lighting. The general function is @code{Light(bool)} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{Light()} call (with one exception, mglGraphGL). Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{bool} Light (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light (@code{HMGL} gr, @code{int} enable)
Sets the using of light on/off for overall plot. Function returns previous value of lighting. Default value is lightning off.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Light (@code{int} n, @code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light_n (@code{HMGL} gr, @code{int} n, @code{int} enable)
Switch on/off @var{n}-th light source separately.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} AddLight (@code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{char} c=@code{'w'})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Light (@code{int} n, @code{mglPoint} p, @code{char} c=@code{'w'}, @code{float} bright=@code{0.5}, @code{bool} infty=@code{true})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Light (@code{int} n, @code{mglPoint} p, @code{mglColor} c, @code{float} bright=@code{0.5}, @code{bool} infty=@code{true})
@deftypefnx {C function} @code{void} mgl_add_light (@code{HMGL} gr, @code{int} n, @code{float} x, @code{float} y, @code{float} z, @code{char} c)
The function adds a light source with identification @var{n} at position @var{p} with color @var{c} and with brightness @var{bright} (which must be in range [0,1]). Flag @var{infty}=@code{true} puts the source to infinite distance (for the faster drawing).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Ambient (@code{float} bright=@code{0.5})
@deftypefnx {C function} @code{void} mgl_set_ambbr (@code{HMGL} gr, @code{float} bright)
Sets the brightness of ambient light. The value should be in range [0,1].
@end deftypefn

@c ==================================================================
@node Fog, Default sizes, Lighting, Graphics setup
@subsection Fog
@cindex Fog

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Fog (@code{float} d, @code{float} dz=@code{0.25})
@deftypefnx {C function} @code{void} mgl_set_fog (@code{HMGL} gr, @code{float} d, @code{float} dz)
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deftypefn

@c ==================================================================
@node Default sizes, Zooming, Fog, Graphics setup
@subsection Default sizes
@cindex SetTickLen
@cindex SetTickStl
@cindex SetBarWidth
@cindex SetMarkSize
@cindex SetArrowSize
@cindex SetBaseLineWidth

These variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetBarWidth ( @code{float} val)
@deftypefnx {C function} @code{void} mgl_set_bar_width (@code{HMGL} gr, @code{float} val)
Sets relative width of rectangles in Bars, Barh, BoxPlot (@pxref{Bars}). Default value is @code{0.7}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetMarkSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_mark_size (@code{HMGL} gr, @code{float} val)
Sets size of marks for @ref{1D plotting}. Default value is @code{0.02}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetArrowSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_arrow_size (@code{HMGL} gr, @code{float} val)
Sets size of arrows for @ref{1D plotting}, lines and curves (@pxref{Primitives drawing}). Default value is @code{0.03}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetBaseLineWidth (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_base_line_width (@code{HMGL} gr, @code{float} val)
Defines the base width for all lines. The value <1 is ignored. For values > 1 the real line width is result of multiplication of specified line width and the value of @var{BaseLineWidth}. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTickLen (@code{float} val, @code{float} stt=@code{1})
@deftypefnx {C function} @code{void} mgl_set_tick_len (@code{HMGL} gr, @code{float} val, @code{float} stt)
The relative length of axis ticks. Default value is @code{0.1}. Parameter @var{stt}>0 set relative length of subticks which is in @code{sqrt(1+stt)} times smaller.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTickStl (@code{const char *}stl, @code{const char *}sub=@code{0})
@deftypefnx {C function} @code{void} mgl_set_tick_stl (@code{HMGL} gr, @code{const char *}stl, @code{const char *}sub)
The line style of axis ticks (@var{stl}) and subticks (@var{sub}). If @var{stl} is empty then default style is used (@samp{k} or @samp{w} depending on transparency type). If @var{sub} is empty then ticks style is used (i.e. @var{stl}).
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} BarWidth
Relative width of rectangles. See @code{SetBarWidth()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} MarkSize
The size of marks. See @code{SetMarkSize()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} ArrowSize
The size of arrows. See @code{SetArrowSize()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} BaseLineWidth
The variable define the base width for all lines. See @code{SetBaseLineWidth()}.
@end deftypecv

@c ==================================================================
@node Zooming, Cutting, Default sizes, Graphics setup
@subsection Zooming
@cindex SetPlotFactor
@cindex Zoom

These variables and functions control the overall zooming of the picture (see Zoom()) or the sub-picture (see PlotFactor). Normally you can use these variables and functions for removing ``white'' spaces around a plot.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetPlotFactor (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_plotfactor (@code{HMGL} gr, @code{float} val)
Sets the factor of plot size. It is not recommended to set it lower then 1.5. This is some analogue of function Zoom() but applied not to overall image but for each InPlot. Use negative value or zero to enable automatic @code{PlotFactor} selection.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Zoom (@code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_set_zoom (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
The function changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} PlotFactor
The factor of plot size. See @code{SetPlotFactor()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} AutoPlotFactor
Switch on/off automatic change of PlotFactor variable during plot rotation. See @code{SetPlotFactor()}.
@end deftypecv

@c ==================================================================
@node Cutting, Font settings, Zooming, Graphics setup
@subsection Cutting
@cindex SetCut
@cindex SetCutBox
@cindex CutOff

These variables and functions set the condition when the points are excluded (cutted) from the drawing. Note, that a point with NAN value(s) of coordinate or amplitude will be automatically excluded from the drawing.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetCut (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_cut (@code{HMGL} gr, @code{int} val)
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypefn

@float
@image{cut, 7cm}
@caption{Left figure is drawn with parameter @code{Cut=false}. Right one is drawn with parameter @code{Cut=true}.}
@end float

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetCutBox (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
@deftypefnx {C function} @code{void} mgl_set_cut_box (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} CutOff (@code{const char *}EqC)
@deftypefnx {C function} @code{void} mgl_set_cutoff (@code{HMGL} gr, @code{const char *}EqC)
Sets the cutting off condition by formula @var{EqC}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{""} to disable cutting off condition. @sref{CutOff sample}
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} Cut
Flag which determines how points outside bounding box are drawn. See @code{SetCut()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{mglPoint} {CutMin, CutMax}
Lower and upper edge of the box in which never points are drawn. See @code{SetCutBox()}.
@end deftypecv

@c ==================================================================
@node Font settings, Palette and colors, Cutting, Graphics setup
@subsection Font settings
@cindex SetFontSize
@cindex SetFontDef
@cindex SetRotatedText
@cindex SetFontSizePT
@cindex SetFontSizeCM
@cindex SetFontSizeIN
@cindex SetFont
@cindex GetFont
@cindex LoadFont
@cindex CopyFont
@cindex RestoreFont

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetFontSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_font_size (@code{HMGL} gr, @code{float} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetFontDef (@code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_set_font_def (@code{HMGL} gr, @code{const char *} val)
Sets the font specification (@pxref{Text printing}). Default is @samp{rC} -- Roman font centering.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetRotatedText (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_rotated_text (@code{HMGL} gr, @code{int} val)
Sets to use or not text rotation along axis.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{""})
@deftypefnx {C function} @code{void} mgl_load_font (@code{HMGL} gr, @code{const char *}name, @code{const char *}path)
Load font typeface from @var{path}/@var{name}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} CopyFont (@code{mglGraph *} from)
@deftypefnx {C function} @code{void} mgl_copy_font (@code{HMGL} gr, @code{HMGL} gr_from)
Copy font data from another @code{mglGraph} object.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} RestoreFont ()
@deftypefnx {C function} @code{void} mgl_restore_font (@code{HMGL} gr)
Restore font data to default typeface.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} SetFontSizePT (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in pt and picture DPI (default is 16 pt for dpi=72).
@end deftypefn
@deftypefn {Method on @code{mglGraph} (C++)} @code{inline void} SetFontSizeCM (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in centimeters and picture DPI (default is 0.56 cm = 16 pt).
@end deftypefn
@deftypefn {Method on @code{mglGraph} (C++)} @code{inline void} SetFontSizeIN (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in inch and picture DPI (default is 0.22 in = 16 pt).
@end deftypefn
@deftypefn {Method on @code{mglGraph} (C++)} @code{void} SetFont (@code{mglFont *}f)
Sets font typeface. Note that each mglFont instance can be used with @emph{ONLY ONE} mglGraph instance at a moment of time! If @code{f==""} then default font is used.
@end deftypefn
@deftypefn {Method on @code{mglGraph} (C++)} @code{inline mglFont *}GetFont ()
Gets current typeface. Note that this variable can be deleted at next SetFont() call!
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} FontSize
The font size. See @code{SetFontSize()}.
@end deftypecv
@deftypecv {@emph{Obsolete option}} mglGraph @code{char} FontDef@code{[32]}
Font style. See @code{SetFontDef()}.
@end deftypecv
@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} RotatedText
Set to use or not text rotation along axis.
@end deftypecv

@c ==================================================================
@node Palette and colors, Error handling, Font settings, Graphics setup
@subsection Pallete and colors
@cindex SetPalColor
@cindex SetPalNum
@cindex SetPalette
@cindex SetScheme
@cindex SelectPen

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetPalette (@code{const char *}@var{colors})
@deftypefnx {C function} @code{void} mgl_set_palette (@code{HMGL} gr, @code{const char *}@var{colors})
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (@pxref{1D plotting}) for curves which styles are not specified.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetPalColor (@code{int} n, @code{float} r, @code{float} g, @code{float} b)
@deftypefnx {C function} @code{void} mgl_set_pal_color (@code{HMGL} gr, @code{int} n, @code{float} r, @code{float} g, @code{float} b)
Sets color for individual palette entry. Look at @code{SetPalette()} function for simplified palette setting.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetPalNum (@code{int} num)
@deftypefnx {C function} @code{void} mgl_set_pal_num (@code{HMGL} gr, @code{int} num)
Sets the number of actual colors in palette. The value must be less then 100. 
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetScheme (@code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_set_scheme (@code{HMGL} gr, @code{const char *}sch)
Set the color scheme for following plots. Usually this function is used internally. @xref{Color scheme}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} SelectPen (@code{const char *}sch)
Set the line and mark styles for following plots. Usually this function is used internally. @xref{Line styles}.
@end deftypefn


@deftypecv {@emph{Obsolete option}} mglGraph @code{mglColor} Pal@code{[101]}
Color palette for @ref{1D plotting}. See @code{SetPalette()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{int} NumPal
Number of actual colors in palette. See @code{SetPalette()}.
@end deftypecv

@c ==================================================================
@node Error handling, Other settings, Palette and colors, Graphics setup
@subsection Error handling

@cindex Message
@c @cindex WarnCode
@cindex SetWarn
@cindex GetWarnCode

There are 2 variables which indicate the warnings/errors presence during plot creation. Normally user should set it to zero by @code{SetWarn(0);} before plotting and check if @var{WarnCode} is not zero after plotting. Only last warning will be saved. All warnings/errors produced by MathGL is not critical -- the plot just will not be drawn.

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} SetWarn (@code{int} code, @code{const char *}who=@code{""})
Set warning code and corresponding message from function @var{who}. Normally you should call this function only for clearing the warning state, i.e. call @code{SetWarn(0);}.
@end deftypefn

@deftypecv {General option (C++)} mglGraph @code{char *} Message
Pointer to buffer for writing messages about matters why some plot are not drawn. Set to NULL to disable messages. The buffer length must be at least 1024. If Message[0]==0 then there are no messages
@end deftypecv

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{int} GetWarnCode ()
@deftypefnx {C function} @code{int} mgl_get_warn_code (@code{HMGL} gr)
Return the numerical ID of warning about the not drawn plot. Possible values are:
@table @code
@item mglWarnNone=0
Everything OK
@item mglWarnDim
Data dimension(s) is incompatible
@item mglWarnLow
Data dimension(s) is too small
@item mglWarnNeg
Minimal data value is negative
@item mglWarnFile
No file or wrong data dimensions
@item mglWarnMem
Not enough memory
@item mglWarnZero
Data values are zero
@item mglWarnLegA
Too many legend entries
@item mglWarnLeg
No legend entries
@item mglWarnSlc
Slice value is out of range
@item mglWarnCnt
Number of contours is zero or negative
@item mglWarnOpen
Couldn't open file
@item mglWarnLId
Light: ID is out of range
@item mglWarnSize
Setsize: size(s) is zero or negative
@item mglWarnFmt
Format is not supported for that build
@end table
@end deftypefn

@deftypecv {Obsolete option} mglGraph @code{int} WarnCode
Numerical ID of warning about the not drawn plot.
@end deftypecv

@c ==================================================================
@node Other settings, , Error handling, Graphics setup
@subsection Other settings
@cindex SetMeshNum
@cindex SetAxialDir
@cindex SetDrawFace
@cindex PlotId

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetMeshNum (@code{int} val)
@deftypefnx {C function} @code{void} mgl_set_meshnum (@code{HMGL} gr, @code{int} num)
Sets approximate number of lines in Mesh(), Fall(), Grid() and also the number of hachures in Vect(), VectC(), Dew() and the number of cells in Cloud*(). By default (=0) it draws all lines/hachures/cells.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetAxialDir (@code{char} val)
@deftypefnx {C function} @code{} mgl_set_axial_dir (@code{HMGL} gr, @code{char} dir)
Sets direction around which curve rotated in Axial() and Torus(). Default value is 'z'.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetDrawFace (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_draw_face (@code{HMGL} gr, @code{int} val)
Enable/disable faces drawing. It is useful for speeding up drawing (for example, during rotation and so on).
@end deftypefn

@deftypecv {General option (C++)} mglGraph @code{const char *} PlotId
Id of plot for saving filename (in GLUT window for example).
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{int} MeshNum
Sets approximate number of lines/hachures/cells. See @code{SetMeshNum()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{char} AxialDir
Set rotation direction. See @code{SetAxialDir()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} DrawFace
Flag for preventing faces drawing. See @code{SetDrawFace()}.
@end deftypecv

@deftypecv {General option (C++)} mglGraph @code{int} CirclePnts
Number of points used for a circle approximation (for example, in @ref{Primitives drawing}, @ref{Tube}, @ref{Pipe} and so on). Default value is 40.
@end deftypecv

@deftypecv {General option (C++)} mglGraph @code{int} GridPnts
Number of points used for grid lines drawing (it is important for curved coordinates). Default value is 50.
@end deftypecv

@c ==================================================================
@node Axis settings, Transformation matrix, Graphics setup, MathGL core
@section Axis settings

These large set of variables and functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (@pxref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (bounding box):: 
* Curved coordinates:: 
* Ticks:: 
@end menu

@c ------------------------------------------------------------------
@node Ranges (bounding box), Curved coordinates, , Axis settings
@subsection Ranges (bounding box)
@cindex Axis
@cindex CAxis
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Min
@cindex Max
@cindex Cmin
@cindex Cmax
@cindex RecalcBorder
@cindex Org
@cindex AutoOrg
@cindex SetRanges
@cindex SetAutoRanges

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetRanges (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1=@code{0}, @code{float} z2=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Axis (@code{mglPoint} min, @code{mglPoint} max, @code{mglPoint} org=@code{mglPoint(NAN,NAN,NAN)})
@deftypefnx {C function} @code{void} mgl_set_axis_2d (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_set_axis_3d (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
Safely sets the value for @var{Min}, @var{Max} and @var{Org} members (options) of the class. If minimal and maximal values of the coordinate are the same then they are ignored. This function also sets @var{Cmin}=@code{Min.z} and @var{Cmax}=@code{Max.z}. This is default color range for 2d plots.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetCRange (@code{float} min, @code{float} max)
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} CAxis (@code{float} min, @code{float} max)
@deftypefnx {C function} @code{void} mgl_set_caxis (@code{HMGL} gr, @code{float} min, @code{float} max)
Safely sets minimal and maximal values of data for coloring. This values are used later for determining the color of the surface.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} XRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
@deftypefnx {C function} @code{void} mgl_set_xrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of @code{Min.x} and @code{Max.x} as minimal and maximal values of data @var{a}. Parameter @var{add} specify to add or not the new range to current one. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} YRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
@deftypefnx {C function} @code{void} mgl_set_yrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of @code{Min.y} and @code{Max.y} as minimal and maximal values of data @var{a}. Parameter @var{add} specify to add or not the new range to current one. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ZRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
@deftypefnx {C function} @code{void} mgl_set_zrange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of @code{Min.z} and @code{Max.z} as minimal and maximal values of data @var{a}. Parameter @var{add} specify to add or not the new range to current one. Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}. See also Axis().
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} CRange (@code{const mglData &} dat, @code{bool} add=@code{false}, @code{float} fact=@code{0})
@deftypefnx {C function} @code{void} mgl_set_crange (@code{HMGL} gr, @code{const HMDT} a, @code{int} add)
Sets values of @code{Cmin} and @code{Cmax} as minimal and maximal values of data @var{a}. Parameter @var{add} specify to add or not the new range to current one. Parameter @var{fact} add additional range increase on value (@var{Cmax}-@var{Cmin})*@var{fact}. See also CAxis().
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetAutoRanges (@code{float} x1, @code{float} x2, @code{float} y1=@code{0}, @code{float} y2=@code{0}, @code{float} z1=@code{0}, @code{float} z2=@code{0})
@deftypefnx {C function} @code{void} mgl_set_auto (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1, @code{float} z2)
Sets ranges for automatic variables of plots. It act as changing of @var{Min}, @var{Max} proprties without calling of RecalcBorder(). Function don't change the direction if minimal and maximal values are the same. For example, if y@var{y1}=@var{y2} then ranges along y-direction will not be changed (will be used previous one). Note that the automatic range become axis range after next call of [XYZ]Range() function(s).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetOrigin (@code{float} x0, @code{float} y0, @code{float} z0=@code{NAN})
@deftypefnx {C function} @code{void} mgl_set_origin (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0)
Sets center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} RecalcBorder ()
Recalculates internal parameter for correct apply of transformation rules. @strong{Must be called} after any direct change of members @var{Min}, @var{Max}, @var{fx}, @var{fy}, @var{fz} if its changes should be seen on the plot.
@end deftypefn

@deftypecv {General option (C++)} mglGraph @code{mglPoint} {Min, Max}
Lower and upper edges of bounding box for graphics. These variables are used for determining the range of automatic (non-specified) arrays in most of plotting functions. So, you may change it before plot and return it back after it and the plot will have automatic x-(y-,z-)coordinate normalized in this range but not in bounding box. @strong{BUT} if you want to change the bounding box then you @strong{must} call @code{RecalcBorder();} after it or use Axis() function.
@end deftypecv

@deftypecv {General option (C++)} mglGraph @code{float} {Cmin, Cmax}
Minimal and maximal value for data (used for coloring).
@end deftypecv

@deftypecv {General option (C++)} mglGraph @code{mglPoint} Org
Center of axis cross section. If one of values is NAN then MathGL library try to select optimal axis position.
@end deftypecv

@deftypecv {General option (C++)} mglGraph @code{bool} AutoOrg
Flag for automatic shifting of axes origin @var{Org} if it lies out of range @var{Min} ... @var{Max}.
@end deftypecv


@c ------------------------------------------------------------------
@node Curved coordinates, Ticks, Ranges (bounding box), Axis settings
@subsection Curved coordinates
@cindex SetFunc
@cindex SetCoor
@cindex Ternary

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetFunc (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ=@code{""}, @code{const char *}EqA=@code{""})
@deftypefnx {C function} @code{void} mgl_set_func (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ)
@deftypefnx {C function} @code{void} mgl_set_func_ext (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ, @code{const char *}EqA)
Sets transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates @samp{x}, @samp{y}, @samp{z} and @samp{a} or @samp{c} for colorbar. For example, the cylindrical coordinates are introduced as @code{Axis("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be empty or @code{NULL}. Using transformation formulas will slightly slowing the program. Parameter @var{EqA} set the similar transformation formula for color scheme. @xref{Textual formulas}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetCoor (@code{int} how)
@deftypefnx {C function} @code{void} mgl_set_coor (@code{HMGL} gr, @code{int} how)
Sets one of the predefined transformation formulas for curvilinear coordinate. Paramater @var{how} define the coordinates: @code{mglCartesian=0} -- Cartesian coordinates (no transformation); @code{mglPolar=1} -- Polar coordiantes @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @code{mglSpherical=2} -- Sperical coordinates @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @code{mglParabolic=3} -- Parabolic coordinates @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @code{mglParaboloidal=4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @code{mglOblate=5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @code{mglProlate=6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @code{mglElliptic=7} -- Elliptic coordinates @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @code{mglToroidal=8} -- Toroidal coordinates @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @code{mglBispherical=9} -- Bispherical coordinates @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @code{mglBipolar=10} -- Bipolar coordinates @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Ternary (@code{bool} tern)
@deftypefnx {C function} @code{void} mgl_set_ternary (@code{HMGL} gr, @code{int} tern)
The function sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deftypefn

@c ------------------------------------------------------------------
@node Ticks, , Curved coordinates, Axis settings
@subsection Ticks

@cindex SetTicks
@cindex SetTicksVal
@cindex SetTuneTicks
@cindex AdjustTicks
@cindex SetXTT
@cindex SetYTT
@cindex SetZTT
@cindex SetCTT

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} AdjustTicks (@code{const char *}dir=@code{"xyz"})
@deftypefnx {C function} @code{void} mgl_adjust_ticks (@code{HMGL} gr, @code{const char *}dir)
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @code{SetTuneTicks(true)}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTicks (@code{char} dir, @code{float} d=@code{-5}, @code{int} ns=@code{0}, @code{float} org=@code{NAN})
@deftypefnx {C function} @code{void} mgl_set_ticks_dir (@code{HMGL} gr, @code{char} dir, @code{float} d, @code{int} ns, @code{float} org)
@deftypefnx {C function} @code{void} mgl_set_ticks (@code{HMGL} gr, @code{float} dx, @code{float} dy, @code{float} dz)
@deftypefnx {C function} @code{void} mgl_set_subticks (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} nz)
@deftypefnx {C function} @code{void} mgl_set_tick_origin (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0)
Set the ticks step @var{d}, number of sub-ticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir} (use 'c' for colorbar ticks). Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set logarithmic ticks. If @var{org} value is NAN then value from @var{Org} is used.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{const char **}lbl)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float *}val, @code{const wchar_t **}lbl)
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} SetTicksVal (@code{char} dir, @code{int} n, @code{float} val1, @code{wchar_t *}lbl1, ...)
@deftypefnx {C function} @code{void} mgl_set_ticks_vals (@code{HMGL} gr, @code{char} dir, @code{int} n, @code{float *}val, @code{const char **}lbl)
@deftypefnx {C function} @code{void} mgl_set_ticks_val (@code{HMGL} gr, @code{char} dir, @code{int} n, @code{double} val, @code{const char *}lbl, ...)
Set the manual positions @var{val} and its labels @var{lbl} for @var{n}-th ticks along axis @var{dir}. The arrays @var{val} and @var{lbl} must contain @var{n} elements. Use @code{SetTicks()} to restore automatic ticks. Note, you @strong{have to be} very careful to use floating-point (not integer!!!) values as ticks position due to limitations of stdarg library (argument transfer). @sref{Manual ticks sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetTuneTicks (@code{bool} tune, @code{float} pos=@code{1.15})
@deftypefnx {C function} @code{void} mgl_tune_ticks (@code{HMGL} gr, @code{bool} tune, @code{float} pos)
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Also set the position @var{pos} of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetXTT (@code{const char *}xtt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetYTT (@code{const char *}ytt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetZTT (@code{const char *}ztt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetCTT (@code{const char *}ctt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetXTT (@code{const wchar_t *}xtt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetYTT (@code{const wchar_t *}ytt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetZTT (@code{const wchar_t *}ztt)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} SetCTT (@code{const wchar_t *}ctt)
@deftypefnx {C function} @code{void} mgl_set_xttw (@code{HMGL} gr, @code{const wchar_t *}xtt)
@deftypefnx {C function} @code{void} mgl_set_yttw (@code{HMGL} gr, @code{const wchar_t *}ytt)
@deftypefnx {C function} @code{void} mgl_set_zttw (@code{HMGL} gr, @code{const wchar_t *}ztt)
@deftypefnx {C function} @code{void} mgl_set_cttw (@code{HMGL} gr, @code{const wchar_t *}ctt)
@deftypefnx {C function} @code{void} mgl_set_xtt (@code{HMGL} gr, @code{const wchar_t *}xtt)
@deftypefnx {C function} @code{void} mgl_set_ytt (@code{HMGL} gr, @code{const wchar_t *}ytt)
@deftypefnx {C function} @code{void} mgl_set_ztt (@code{HMGL} gr, @code{const wchar_t *}ztt)
@deftypefnx {C function} @code{void} mgl_set_ctt (@code{HMGL} gr, @code{const wchar_t *}ctt)
The template for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{""} then default template is used (in simplest case it is @samp{%.2g}). Setting of template switch off automatic ticks tuning (see @code{SetTuneTicks()}).
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} {dx, dy, dz}
Step for axis ticks. See @code{SetTicks()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{int} {NSx, NSy, NSz}
Number of axis sub-ticks. See @code{SetTicks()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{mglPoint} OrgT
Starting point for ticks. See @code{SetTicks()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} TuneTicks
Switch on/off ticks enhancing by factoring common multiplier. See @code{SetTuneTicks()}.
@end deftypecv

@deftypecv {@emph{Obsolete option}} mglGraph @code{float} FactorPos
The position of common multiplier/component on the axis. See @code{SetTuneTicks()}.
@end deftypecv


@c ##################################################################
@node Transformation matrix, Export to file, Axis settings, MathGL core
@section Transformation matrix
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex StickPlot
@cindex InPlot
@cindex Identity
@cindex Perspective
@cindex RestoreM
@cindex View
@cindex ColumnPlot
@cindex Push
@cindex Pop

These functions control how and where further plotting will be placed. There is a curtain order of calling of these functions for the better plot view. First one should be SubPlot() or InPlot() for specifying the place. After it a Rotate() and Aspect(). And finally any other plotting functions may be called. Alternatevely you can use ColumnPlot() for position plots in the column one by another without gap between plot axis (bounding boxes).

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypefnx {C function} @code{void} mgl_subplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m)
@deftypefnx {C function} @code{void} mgl_subplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{float} dx, @code{float} dy)
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_subplot_s (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}style)
The same as previous but space reserved for axis/colorbar is saved only if @var{style} contain: @samp{L} or @samp{<} -- at left side, @samp{R} or @samp{>} -- at right side, @samp{A} or @samp{^} -- at top side, @samp{U} or @samp{_} -- at bottom side.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} InPlot (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{bool} rel=@code{false})
@deftypefnx {C function} @code{void} mgl_inplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_relplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{true} then the relative position to current SubPlot() (or last InPlot() with @var{rel}=@code{false}) is used. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ColumnPlot (@code{int} num, @code{int} ind, @code{float} d=@code{0})
@deftypefnx {C function} @code{void} mgl_columnplot (@code{HMGL} gr, @code{int} num, @code{int} ind)
@deftypefnx {C function} @code{void} mgl_columnplot_d (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{float} d)
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous SubPlot() call (or InPlot() with @var{rel}=@code{false}). Parameter @var{d} set extra gap between cells. @sref{ColumnPlot sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} StickPlot (@code{int} num, @code{int} ind, @code{float} tet, @code{float} phi)
@deftypefnx {C function} @code{void} mgl_stickplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{float} tet, @code{float} phi)
Puts further plotting in @var{ind}-th cell of stick with @var{num} cells. At this, stick is rotated on angles @var{tet}, @var{phi}. The position is relative to previous SubPlot() call (or InPlot() with @var{rel}=@code{false}). @sref{StickPlot sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Rotate (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
@deftypefnx {C function} @code{void} mgl_rotate (@code{HMGL} gr, @code{float} TetX, @code{float} TetZ, @code{float} TetY)
Rotates a further plotting relative to each axis @{x, z, y@} consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} RotateN (@code{float} Tet, @code{float} x, @code{float} y, @code{float} z)
@deftypefnx {C function} @code{void} mgl_rotate_vector (@code{HMGL} gr, @code{float Tet}, @code{float x}, @code{float y}, @code{float z})
Rotates a further plotting around vector @{@var{x}, @var{y}, @var{z}@} on angle @var{Tet}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Aspect (@code{float} Ax, @code{float} Ay, @code{float} Az)
@deftypefnx {C function} @code{void} mgl_aspect (@code{HMGL} gr, @code{float} Ax, @code{float} Ay, @code{float} Az)
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after Rotate() function.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Perspective (@code{float} a)
@deftypefnx {C function} @code{void} mgl_perspective (@code{HMGL} gr, @code{float} a)
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Identity (@code{bool} rel=@code{false})
@deftypefnx {C function} @code{void} mgl_identity (@code{HMGL} gr, @code{int} rel)
Clears transformation matrix. This function clears all previous effects of Aspect(), SubPlot(), InPlot() or Rotate() functions. It is equivalent to the call of @code{InPlot(0,1,0,1,rel)}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Push ()
@deftypefnx {C function} @code{void} mgl_mat_push (@code{HMGL} gr)
Push transformation matrix into stack. Later you can restore its current state by Pop() function. Stack can keep up to 10 matrices.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Pop ()
@deftypefnx {C function} @code{void} mgl_mat_pop (@code{HMGL} gr)
Pop (restore last 'pushed') transformation matrix into stack.
@end deftypefn

@c ##################################################################
@node Export to file, Primitives drawing, Transformation matrix, MathGL core
@section Export to file
@cindex WriteFrame
@cindex WritePNG
@cindex WriteGIF
@cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteJPEG
@cindex SetSize
@cindex Flush
@cindex Finish
@cindex ShowImage

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG and SVG files.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteFrame (@code{const char *}fname=@code{""}, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_frame (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{""}). If @var{fname}=@code{""} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id and name @samp{frame} is defined by @var{PlotId} class property.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{int} compr=@code{""}, @code{bool} alpha=@code{true})
@deftypefnx {C function} @code{void} mgl_write_png (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@deftypefnx {C function} @code{void} mgl_write_png_solid (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to PNG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file, @var{alpha} gives the transparency type. By default there are no description added and transparent image used. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_jpg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if NO_JPEG is defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_gif (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to GIF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_bmp (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file. The vector representation is used if possible. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. If file name is terminated by @samp{z} (for example, @samp{fname.eps.gz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_svg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to SVG (Scalable Vector Graphics) file. The vector representation is used. In difference of EPS format, SVG format support transparency that allows to correctly draw half-transparent plot (like SurfA(), Surf3A(), CloudQ() or CloudP()). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name). If file name is terminated by @samp{z} (for example, @samp{fname.svgz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_idtf (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ShowImage (@code{const char *}viewer=@code{"kuickshow"}, @code{bool} nowait=@code{false})
@deftypefnx {C function} @code{void} mgl_show_image (@code{const char *}viewer, @code{int} nowait)
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetSize (@code{int} width, @code{int} height)
@deftypefnx {C function} @code{void} mgl_set_size (@code{HMGL} gr, @code{int} width, @code{int} height)
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Flush ()
@deftypefnx {C function} @code{void} mgl_flush (@code{HMGL} gr)
Flushes the plotting commands to frame. This function may be useful if one wants to remove array before the finishing of the plot (i.e. before calling @code{Finish()}). Also call of this function separate the objects in mglGraphIDTF. Most of plots call this function internally.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Finish ()
Finishes plotting and create a picture. Normally this function is called internally.
@end deftypefn


@c ##################################################################
@node Primitives drawing, Text printing, Export to file, MathGL core
@section Primitives drawing
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Mark
@cindex Error
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

These functions draw some simple objects like line, point, sphere, drop, cone and so on.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Clf (@code{mglColor} Back=@code{WC})
@deftypefnx {C function} @code{void} mgl_clf (@code{HMGL} gr)
@deftypefnx {C function} @code{void} mgl_clf_rgb (@code{HMGL} gr, @code{float} r, @code{float} g, @code{float} b)
Clear the picture and fill it by color @var{Back}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Ball (@code{float} x, @code{float} y, @code{float} z, @code{mglColor} col=@code{RC}, @code{float} alpha=@code{1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Ball (@code{mglPoint} p, @code{char} col=@code{'r'})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Ball (@code{float} x, @code{float} y, @code{float} z, @code{char} col=@code{'r'})
@deftypefnx {C function} @code{void} mgl_ball (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z)
@deftypefnx {C function} @code{void} mgl_ball_rgb (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} r, @code{float} g, @code{float} b, @code{float} alpha)
@deftypefnx {C function} @code{void} mgl_ball_str (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{char} col)
Draws a point (ball) at position @var{p}=@{@var{x}, @var{y}, @var{z}@} with color @var{col}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Error (@code{mglPoint} p, @code{mglPoint} e, @code{char} *pen=@code{""})
Draws a 3d error box at position @var{p} with sizes @var{e} and style @var{pen}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Line (@code{mglPoint} p1, @code{mglPoint} p2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Line (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl=@code{"B"}, @code{int}num=@code{2})
@deftypefnx {C function} @code{void} mgl_line (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl, @code{int}num)
Draws a geodesic line (straight line in Cartesian coordinates) from point @var{p1} to @var{p2} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the stright line will be drawn in all coordinate system (independently on transformation formulas (@pxref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on). Line will be drawn even if it lies out of bounding box.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Curve (@code{mglPoint} p1, @code{mglPoint} d1, @code{mglPoint} p2, @code{mglPoint} d2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Curve (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
@deftypefnx {C function} @code{void} mgl_curve (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl, @code{int} num)
Draws Bezier-like curve from point @var{p1} to @var{p2} using line style @var{stl}. At this tangent is codirected with @var{d1}, @var{d2} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas @pxref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordinate system. Curve will be drawn even if it lies out of bounding box.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"}, @code{int} num=@code{2}, @code{float} val=@code{NAN})
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. In first case parameter @var{val} (if not @code{NAN}) set the color according color scheme. Face will be drawn even if it lies out of bounding box.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} FaceX (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} FaceY (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} FaceZ (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl=@code{"w"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypefnx {C function} @code{void} mgl_facex (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facey (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facez (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl, @code{float} d1, @code{float} d2)
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or separately if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Sphere (@code{mglPoint} p, @code{float} r, @code{const char *}stl=@code{"r"})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Sphere (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl=@code{"r"})
@deftypefnx {C function} @code{void} mgl_sphere (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl)
Draw the sphere with radius @var{r} and center at point @var{p}=@{@var{x}, @var{y}, @var{z}@} and color @var{stl}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Drop (@code{mglPoint} p, @code{mglPoint} q, @code{float} r, @code{mglColor} col, @code{float} shift=@code{1}, @code{float} ap=@code{1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Drop (@code{mglPoint} p, @code{mglPoint} q, @code{float} r, @code{const char *}col="r", @code{float} shift=@code{1}, @code{float} ap=@code{1})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Drop (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col="r", @code{float} shift=@code{1}, @code{float} ap=@code{1})
@deftypefnx {C function} @code{void} mgl_drop (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col, @code{float} shift, @code{float} ap)
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{q} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Cone (@code{mglPoint} p1, @code{mglPoint} p2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Cone (@code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
@deftypefnx {C function} @code{void} mgl_cone (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2, @code{const char *}stl, @code{int} draw_edge)
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @var{p1}, @var{p2} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is supposed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Mark (@code{mglPoint} p, @code{char} mark=@code{'.'})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Mark (@code{float} x, @code{float} y, @code{float} z, @code{char} mark=@code{'.'})
@deftypefnx {C function} @code{void} mgl_mark (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{char} mark)
Draws a marks of different type at position @var{p}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Glyph (@code{float} x, @code{float} y, @code{float} f, @code{int} nt, @code{const short *}trig, @code{int} nl, @code{const short *}line)
Draw a set of triangles (or lines if @var{trig}=@code{NULL}) for glyph which is placed at point @{@var{x}, @var{y}@}. Values in the arrays are normalized by factor @var{f}. Normally this function is used internally.
@end deftypefn

@c ##################################################################
@node Text printing, Axis and Colorbar, Primitives drawing, MathGL core
@section Text printing
@cindex Puts
@cindex Putsw
@cindex Text
@cindex Title

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. The class mglFont (@pxref{mglFont class}) is used for low-level string parsing and printing. It can use arbitrary font-faces and parse many TeX commands (for detail @pxref{Font styles}). All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function SetFont(), GetFont(). @xref{Font settings}.

The font parameters are described by string. This string may contain several characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. Also it may contain the text color @samp{wkrgbcymhRGBCYMHW} (@pxref{Line styles}) after symbol @samp{:}. The font types are: @samp{r} -- roman font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. For example, string @samp{iC:b} correspond to italic font style for centered text which printed by blue color.

If string contains symbols @samp{aA} then text is printed at arbitrary position @{@var{x}, @var{y}@} (supposed to be in range [0,1]) of subplot (for @samp{a}) or picture (for @samp{A}).

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Puts (@code{mglPoint} p, @code{const char *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1}, @code{char} dir=@code{0}, @code{float} shift=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Putsw (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1}, @code{char} dir=@code{0}, @code{float} shift=@code{0})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
@deftypefnx {C function} @code{void} mgl_puts (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_putsw (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text)
@deftypefnx {C function} @code{void} mgl_puts_ext (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}font, @code{float} size, @code{char} dir)
@deftypefnx {C function} @code{void} mgl_putsw_ext (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text, @code{const char *}font, @code{float} size, @code{char} dir)
The function plots the string @var{text} at position @var{p} with fonts specifying by the criteria @var{how}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Parameter @var{dir} specifies the additional string align. The aligns are: @samp{x} -- align as x-label, @samp{y} -- align as y-label, @samp{z} -- align as z-label, @samp{i} -- align as x-label but inverse writing direction, @samp{t} -- no align (default), @samp{n} -- align in x-y plane.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{float} Puts (@code{mglPoint} p, @code{mglPoint} l, @code{const char *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{float} Putsw (@code{mglPoint} p, @code{mglPoint} l, @code{const wchar_t *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Puts (@code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{char}where=@code{'t'}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{float} size)
@deftypefnx {C function} @code{void} mgl_putsw_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const wchar_t *}text, @code{float} size)
The function plots the string @var{text} at position @var{p} along direction @var{l} with specified @var{size}. Parameter @var{where} set to print text above the line (@samp{T}) or under the line (@samp{t}). Function return the width of the string.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Text (@code{mglPoint} p, @code{const char *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Text (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1}, @code{char} dir=@code{0})
The function plots the string @var{text} at position @var{p} with fonts @var{how}. These functions are obsolete -- use Puts(), Putsw() functions instead.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Printf (@code{mglPoint} p, @code{const char *}arg, ...)
Print formatted string at point @var{p}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Label (@code{float} x, @code{float} y, @code{const char *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Labelw (@code{float} x, @code{float} y, @code{const wchar_t *}text, @code{const char *}font=@code{""}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_label_xy (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const char *}text, @code{const char *}font, @code{float} size)
@deftypefnx {C function} @code{void} mgl_labelw_xy (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const wchar_t *}text, @code{const char *}font, @code{float} size)
The function draws the string @var{text} at position @{@var{x}, @var{y}@} with fonts specifying by @var{font}. The size of font is set by @var{size} parameter (default is @var{FontSize}). Coordiantes @code{x, y} are supposed to be in range [0,1].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Title (@code{const char *}text, @code{const char *}font=@code{0}, @code{float} size=@code{-2})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Title (@code{const wchar_t *}text, @code{const char *}font=@code{0}, @code{float} size=@code{-2})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} Title (@code{const char *}text, @code{const char *}font=@code{0}, @code{int} size=@code{-2})
@deftypefnx {C function} @code{void} mgl_title (@code{HMGL} gr, @code{const char *}text, @code{const char *}font, @code{int} size)
@deftypefnx {C function} @code{void} mgl_titlew (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}font, @code{int} size)
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside SubPlot()).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Text (@code{const mglData &}y, @code{const char *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Text (@code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const wchar_t *}text, @code{const char *}font=@code{""}, float size=@code{-1})
@deftypefnx {C function} @code{void} mgl_text_y (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}text, @code{const char *}font, float size)
@deftypefnx {C function} @code{void} mgl_text_xy (@code{const HMDT} x, @code{const HMDT} y, @code{const char *}text, @code{const char *}font, float size)
@deftypefnx {C function} @code{void} mgl_text_xyz (@code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}text, @code{const char *}font, float size)
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{font} and with size @var{size}. The string @var{font} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @code{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (@pxref{Ranges (bounding box)}). If array @var{z} is not specified then @var{z}[i] = @var{zVal} is used. @sref{Text sample}
@end deftypefn

@c ##################################################################
@node Axis and Colorbar, Legend, Text printing, MathGL core
@section Axis and Colorbar
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings}.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{bool} adjust=@code{false})
@deftypefnx {C function} @code{void} mgl_axis (@code{HMGL} gr, @code{const char *}dir)
Draws axes with ticks (@pxref{Axis settings}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @var{FontDef} (@pxref{Font settings}). Ticks will be adjusted if @var{adjust}=@code{true} (by call of @code{AdjustTicks()}). You may specified an arrow at the end of axis (see @pxref{Line styles})
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Colorbar (@code{const char *}sch=@code{""}, @code{int} where=@code{0})
@deftypefnx {C function} @code{void} mgl_colorbar (@code{HMGL} gr, @code{const char *}sch, @code{int} where)
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=""}) at edge of plot. Parameter @var{where} specifies the position of the colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. If string @var{sch} contains @samp{<>^_} then the parameter @var{pos} is defined as: @code{pos=0} for @samp{>} (right), @code{pos=1} for @samp{<} (left), @code{pos=2} for @samp{^} (top), @code{pos=3} for @samp{_} (bottom). If string have @samp{A} then absolute (relative to picture) coordinates is used. @sref{Dens sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Colorbar (@code{const mglData &}v, @code{const char *}sch=@code{""}, @code{int} where=@code{0})
@deftypefnx {C function} @code{void} mgl_colorbar_val (@code{HMGL} gr, @code{const HMDT} v, @code{const char *}sch, @code{int} where)
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{ContD sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Colorbar (@code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Colorbar (@code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@deftypefnx {C function} @code{void} mgl_colorbar_ext (@code{HMGL} gr, @code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
The same as first one but at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Colorbar (@code{const mglData &}v, @code{const char *}sch, @code{int} where, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{ContD sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B-"})
@deftypefnx {C function} @code{void} mgl_axis_grid (@code{HMGL} gr, @code{const char *}dir, @code{const char *}pen)
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an Axis(). The style of lines is determined by @var{pen} parameter (default value is dark blue solid line @samp{B-}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Box (@code{const char *}col=@code{""}, @code{bool} ticks=@code{true})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Box (@code{mglColor} col, @code{bool} ticks=@code{true})
@deftypefnx {C function} @code{void} mgl_box (@code{HMGL} gr, @code{int} ticks)
@deftypefnx {C function} @code{void} mgl_box_rgb (@code{HMGL} gr, @code{float} r, @code{float} g, @code{float} b, @code{int} ticks)
@deftypefnx {C function} @code{void} mgl_box_str (@code{HMGL} gr, @code{const char *}col, @code{int} ticks)
Draws bounding box outside the plotting volume with color @var{col}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Label (@code{char} dir, @code{const char *}text, @code{float} pos=@code{0}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} Label (@code{char} dir, @code{const wchar_t *}text, @code{float} pos=@code{0}, @code{float} size=@code{-1.4}, @code{float} shift=@code{0})
@deftypefnx {C function} @code{void} mgl_label (@code{HMGL} gr, @code{char} dir, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_label_ext (@code{HMGL} gr, @code{char} dir, @code{const char *}text, @code{float} pos, @code{float} size, @code{float} shift)
@deftypefnx {C function} @code{void} mgl_labelw_ext (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}text, @code{float} pos, @code{float} size, @code{float} shift)
Prints the label @var{text} for axis @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t} (here @samp{t} is ``ternary'' axis @math{t=1-x-y}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. Parameter @var{size} determines the font size for the label. By default the font size is 1.4 times larger than the one for ticks @var{FontSize} (@pxref{Font settings}). @xref{Text printing}.
@end deftypefn

@c ##################################################################
@node Legend, 1D plotting, Axis and Colorbar, MathGL core
@section Legend
@cindex Legend
@cindex AddLegend
@cindex ClearLegend
@cindex SetLegendBox
@cindex SetLegendMarks

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included TeX parsing). The arrays of strings may be used directly or by accumulating first to the internal arrays (by function AddLegend()) and further plotting it. The position of the legend can be selected automatic or manually. Parameters @var{font} and @var{size} specify the font style and size (@pxref{Font settings}). Parameter @var{llen} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. If string @var{font} contains symbol @samp{A} then legend coordinates set position in the picture (not in the current subplot). @sref{Legend sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Legend (@code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
@deftypefnx {C function} @code{void} mgl_legend (@code{HMGL} gr, @code{int} where, @code{const char *}font, @code{float} size, @code{float} llen)
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Legend (@code{int} n, @code{wchar_t **}text, @code{char **}style, @code{int} where=@code{0x3}, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend with @var{n}-th elements of string array @var{text} by font @var{font} with @var{size}. Entry strings @var{text} describe curves with line style @var{style} (including marks). Parameter @var{where} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Legend (@code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
@deftypefnx {C function} @code{void} mgl_legend_xy (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const char *}font, @code{float} size, @code{float} llen)
Draws legend of accumulated legend entries by font @var{font} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Legend (@code{int} n, @code{wchar_t **}text, @code{char **}style, @code{float} x, @code{float} y, @code{const char *}font=@code{"rL"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
Draws legend with @var{n}-th elements of string array @var{text} by font @var{font} with @var{size}. Entry strings @var{text} describe curves with line style @var{style} (including marks). Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legend (@code{HMGL} gr, @code{const char *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legendw (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}style)
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (@pxref{Line styles}). Maximal number of entries is 100.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ClearLegend ()
@deftypefnx {C function} @code{void} mgl_clear_legend (@code{HMGL} gr)
Clears saved legend strings.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetLegendBox (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_legend_box (@code{HMGL} gr, @code{int} enable)
Switch on/off drawing box near legend. By default (=@code{true}) box is drawn.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SetLegendMarks (@code{int} num)
@deftypefnx {C function} @code{void} mgl_set_legend_marks (@code{HMGL} gr, @code{int} num)
Set the number of marks in the legend. By default 1 mark is used.
@end deftypefn

@deftypecv {@emph{Obsolete option}} mglGraph @code{bool} LegendBox
Switch on/off drawing box near legend. See @code{SetLegendBox()}.
@end deftypecv

@c ##################################################################
@node 1D plotting, 2D plotting, Legend, MathGL core
@section 1D plotting

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is "" then solid line with color from palette Pal is used (@pxref{Palette and colors}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}. @sref{1D plot sample}


@menu
* Plot:: 
* Radar:: 
* Tens:: 
* Area:: 
* Region:: 
* Stem:: 
* Bars:: 
* Barh:: 
* Chart:: 
* Step:: 
* Torus:: 
* Tube:: 
* Mark:: 
* TextMark:: 
* Error:: 
* BoxPlot::
@end menu

@c ==================================================================
@node Plot, Radar, , 1D plotting
@subsection Plot
@cindex Plot

These functions draw continuous lines between points. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Step}, @ref{Stem}, @ref{Tube}, @ref{Mark}, @ref{Error}, @ref{Belt}, @ref{Tens}. @sref{Plot sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_plot_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_plot_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Plot (@code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_plot (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Radar, Tens, Plot, 1D plotting
@subsection Radar
@cindex Radar

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Radar (@code{const mglData &}a, @code{const char *}pen=@code{""}, @code{float} r=@code{-1})
@deftypefnx {C function} @code{void} mgl_radar (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}pen, @code{float} r)
This functions draws radar chart which is continuous lines between points located on an radial lines (like plot in Polar coordinates). The plots are drawn for each row if one of the data is the matrix. Parameter @var{r} set the additional shift of data (i.e. the data @var{a}+@var{r} is used instead of @var{a}). If @code{r<0} then @code{r=max(0, -min(a)}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). If @var{pen} containt @samp{#} symbol then "grid" (radial lines and circle for @var{r}) is drawn See also @ref{Plot}. @sref{Radar sample}
@end deftypefn

@c ==================================================================
@node Tens, Area, Radar, 1D plotting
@subsection Tens
@cindex Tens

These functions draw continuous lines between points with color defined by the special array (look like tension plot). The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color scheme (@pxref{Color scheme}) and style and/or width of line (@pxref{Line styles}). By default (@code{pen=""}) solid line with current color scheme is used. See also @ref{Plot}, @ref{Mesh}, @ref{Fall}. @sref{Tens sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tens_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space with color defined by @var{c}[i].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tens_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) with color defined by @var{c}[i].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tens (@code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tens (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} c, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) with color defined by @var{c}[i], where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Area, Region, Tens, 1D plotting
@subsection Area
@cindex Area

These functions draw continuous lines between points and fills it to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). Also you can use gradient filling if number of specified colors is equal to 2*number of curves. If string contain symbol @samp{a} then lines are drawn one above another (like summation) -- you can reach the same effect if call @code{y.CumSum("y");} before plot. See also @ref{Plot}, @ref{Bars}, @ref{Stem}. @sref{Area sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_area_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space and fills it down to @var{z} = Org.z.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_area_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) and fills it down to @var{y} = Org.y.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Area (@code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_area (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous lines between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}) and fills it down to @var{y} = Org.y, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Region, Stem, Area, 1D plotting
@subsection Region
@cindex Region

These functions fill area between 2 curves. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y1.nx=y2.nx} and all dimensions of arrays @var{y1} and @var{y2} must be equal too. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=""}) color from palette is used (@pxref{Palette and colors}). Also you can use gradient filling if number of specified colors is equal to 2*number of curves. See also @ref{Area}, @ref{Bars}, @ref{Stem}. @sref{Region sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Region (@code{const mglData &}x, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{float} zVal=@code{NAN}, @code{bool} inside=@code{true})
@deftypefnx {C function} @code{void} mgl_region_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y1, @code{const HMDT} y2, @code{const char *}pen, @code{int} inside)
The function fills area between curves @{@var{x}[i], @var{y1}[i]@} and @{@var{x}[i], @var{y2}[i]@} at z=@var{zVal}. Parameter @code{inside=false} set to fill are with y1<y<y2 else the area with y2<y<y1 will be also filled.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Region (@code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{float} zVal=@code{NAN}, @code{bool} inside=@code{true})
@deftypefnx {C function} @code{void} mgl_region (@code{HMGL} gr, @code{const HMDT} y1, @code{const HMDT} y2, @code{const char *}pen, @code{int} inside)
The function fills area between curves @{@var{x}[i], @var{y1}[i]@} and @{@var{x}[i], @var{y2}[i]@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] at z=@var{zVal}.
@end deftypefn

@c ==================================================================
@node Stem, Bars, Region, 1D plotting
@subsection Stem
@cindex Stem

These functions draw vertical lines from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Area}, @ref{Bars}, @ref{Plot}, @ref{Mark}. @sref{Stem sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_stem_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_stem_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Stem (@code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_stem (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical lines from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Bars, Barh, Stem, 1D plotting
@subsection Bars
@cindex Bars

These functions draw vertical bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). If string contain symbol @samp{a} then lines are drawn one above another (like summation). If string contain symbol @samp{f} then waterfall chart is drawn for determining the cumulative effect of sequentially introduced positive or negative values. You can different colors for positive and negative values if number of specified colors is equal to 2*number of curves. See also @ref{Barh}, @ref{Area}, @ref{Stem}, @ref{Chart}, @ref{Default sizes}. @sref{Bars sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_bars_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws vertical bars from points @{@var{x}[i], @var{y}[i], @var{z}[i]@} down to @var{z} = Org.z.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_bars_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Bars (@code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_bars (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws vertical bars from points @{@var{x}[i], @var{y}[i]@} down to @var{y} = Org.y in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Barh, Chart, Bars, 1D plotting
@subsection Barh
@cindex Barh

These functions draw horizontal bars from points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). If string contain symbol @samp{a} then lines are drawn one above another (like summation). See also @ref{Barh}, @ref{Default sizes}. @sref{Barh sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Barh (@code{const mglData &}y, @code{const mglData &}v, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_barh_xy (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} v, @code{const char *}pen)
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Barh (@code{const mglData &}v, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_barh (@code{HMGL} gr, @code{const HMDT} v, @code{const char *}pen)
The function draws horizontal bars from points @{@var{v}[i], @var{y}[i]@} down to @var{x} = Org.x in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{y}[i] values are equidistantly distributed in interval [@var{Min}.y, @var{Max}.y].
@end deftypefn

@c ==================================================================
@node Chart, Step, Barh, 1D plotting
@subsection Chart
@cindex Chart

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Chart (@code{const mglData &}a, @code{const char *}col=@code{""})
@deftypefnx {C function} @code{void} mgl_chart (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}col)
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (@pxref{Palette and colors}). Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypefn


@c ==================================================================
@node Step, Torus, Chart, 1D plotting
@subsection Step
@cindex Step

These functions draw continuous stairs for points to axis plane. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Stem}, @ref{Tile}, @ref{Boxs}. @sref{Step sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_step_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i], @var{z}[i]@}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_step_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Step (@code{const mglData &}y, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_step (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}pen)
The function draws continuous stairs for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Torus, Tube, Step, 1D plotting
@subsection Torus
@cindex Torus

These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around @var{AxialDir} axis (@pxref{Other settings}). The sizes of 1st dimension @strong{must be equal} for all arrays @var{r.nx=z.nx}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=""}) color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Axial}. @sref{Torus sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Torus (@code{const mglData &}r, @code{const mglData &}z, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_torus (@code{HMGL} gr, @code{const HMDT} r, @code{const HMDT} z, @code{const char *}pen)
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Torus (@code{const mglData &}z, @code{const char *}pen=@code{""})
The function draws surface which is result of curve @{@var{r}[i], @var{z}[i]@} rotation, where @var{r}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Tube, Mark, Torus, 1D plotting
@subsection Tube
@cindex Tube

These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Tube sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{float} r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tube_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tube_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Tube (@code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_tube_r (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
@deftypefnx {C function} @code{void} mgl_tube (@code{HMGL} gr, @code{const HMDT} y, @code{float} r, @code{const char *}pen)
The function draws tube with radius @var{r} between points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node Mark, TextMark, Tube, 1D plotting
@subsection Mark
@cindex Mark

These functions draw marks with size @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). If you need to draw markers of the same size then you may use @ref{Plot} function. See also @ref{Plot}, @ref{TextMark}, @ref{Stem}, @ref{Error}. @sref{Mark sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_mark_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_mark_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Mark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_mark_y (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}pen)
The function draws marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node TextMark, Error, Mark, 1D plotting
@subsection TextMark
@cindex TextMark

These functions draw string @var{text} as marks with size proportional to @var{r}*@var{MarkSize} (@pxref{Default sizes}) at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Mark}, @ref{Stem}. @sref{TextMark sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmarkw_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark_xyzr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i], @var{z}[i]@} in 3D space.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmarkw_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark_xyr (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}text, @code{const char *}fnt=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}text, @code{const char *}fnt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmarkw_yr (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark_yr (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} r, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TextMark (@code{const mglData &}y, @code{const char *}text, @code{const char *}fnt=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++)} @code{void} TextMark (@code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmarkw (@code{HMGL} gr, @code{const HMDT} y, @code{const wchar_t *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_textmark (@code{HMGL} gr, @code{const HMDT} y, @code{const char *}text, @code{const char *}fnt)
The function draws textual marks for points @{@var{x}[i], @var{y}[i]@} in plane @var{z}=@var{zVal} (default in plane @var{z}=@var{Min.z}), where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x]. The mark sizes @var{r}[i]=1 for all points.
@end deftypefn

@c ==================================================================
@node Error, BoxPlot, TextMark, 1D plotting
@subsection Error
@cindex Error

These functions draw error boxes at points @{@var{x}[i], @var{y}[i]@} on plane @var{z} = @var{zVal} (by default @var{z}=@var{Min.z}). This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx=r.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}. @sref{Error sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ex, @code{const mglData &}ey, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_error_exy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ex, @code{const HMDT} ey, @code{const char *}pen)
Draws a error box @{@var{ex}, @var{ey}@} in point position @{@var{x}, @var{y}@}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ey, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_error_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ey, @code{const char *}pen)
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Error (@code{const mglData &}y, @code{const mglData &}ey, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_error (@code{HMGL} gr, @code{const HMDT} y, @code{const HMDT} ey, @code{const char *}pen)
Draws a error box @var{ey} (along only one direction) in point position @{@var{x}, @var{y}@}, where @var{x}[i] values are equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ==================================================================
@node BoxPlot, , Error, 1D plotting
@subsection BoxPlot
@cindex BoxPlot

These functions draw boxplot (also known as a box-and-whisker diagram) at points @var{x}[i] on plane @var{z} = @var{zVal} (by default @var{z}=@var{Min.z}). This is five-number summaries of data @var{a}[i,j] (minimum, lower quartile (Q1), median (Q2), upper quartile (Q3) and maximum) along second (j-th) direction. The sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=a.nx}. String @var{pen} specifies the color and style of line (@pxref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (@pxref{Palette and colors}). See also @ref{Plot}, @ref{Error}, @ref{Bars}, @ref{Default sizes}. @sref{BoxPlot sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} BoxPlot (@code{const mglData &}x, @code{const mglData &}a, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_boxplot_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} a, @code{const char *}pen)
Draws a boxplot with specified values of coordinate @var{x}[i].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} BoxPlot (@code{const mglData &}a, @code{const char *}pen=@code{""})
@deftypefnx {C function} @code{void} mgl_boxplot (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}pen)
Draws a boxplot with @var{x}[i] values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@c ##################################################################
@node 2D plotting, 3D plotting, 1D plotting, MathGL core
@section 2D plotting

These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are several generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial functions have variants for automatic and manual selection of level values for contours. Also there are functions for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}. @sref{2D plot sample}

@menu
* Mesh:: 
* Fall:: 
* Belt:: 
* Surf:: 
* Boxs:: 
* Tile:: 
* Dens:: 
* Cont:: 
* ContF:: 
* ContD:: 
* Axial:: 
* Grad:: 
* Grid:: 
@end menu

@c ==================================================================
@node Mesh, Fall, , 2D plotting
@subsection Mesh
@cindex Mesh

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Mesh (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_mesh_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Mesh lines are plotted for each z slice of the data. See also @ref{Surf}, @ref{Fall}, MeshNum (@pxref{Other settings}), @ref{Cont}, @ref{Tens}. @sref{Mesh sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Mesh (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_mesh (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Fall, Belt, Mesh, 2D plotting
@subsection Fall
@cindex Fall

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Fall (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_fall_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used for plotting several curves shifted in depth one from another. String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Fall lines are plotted for each z slice of the data. See also @ref{Belt}, @ref{Mesh}, @ref{Tens}, MeshNum (@pxref{Other settings}). @sref{Fall sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Fall (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_fall (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Belt, Surf, Fall, 2D plotting
@subsection Belt
@cindex Belt

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Belt (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_belt_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of Plot (@pxref{Plot}). String @var{sch} sets the color scheme. Previous color scheme is used by default. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Belts are plotted for each z slice of the data. See also @ref{Fall}, @ref{Surf}, @ref{Plot}, MeshNum (@pxref{Other settings}). @sref{Belt sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Belt (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_belt (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Surf, Boxs, Belt, 2D plotting
@subsection Surf
@cindex Surf

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surf_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Mesh}, @ref{Dens}, @ref{Belt}, @ref{Tile}, @ref{Boxs}, @ref{SurfC}, @ref{SurfA}. @sref{Surf sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surf (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Boxs, Tile, Surf, 2D plotting
@subsection Boxs
@cindex Boxs

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Boxs (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_boxs_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Dens}, @ref{Tile}, @ref{Step}. @sref{Boxs sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Boxs (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_boxs (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Tile, Dens, Boxs, 2D plotting
@subsection Tile
@cindex Tile

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tile (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_tile_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of Step (@pxref{Step}). String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Boxs}, @ref{Step}, @ref{TileS}. @sref{Tile sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Tile (@code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_tile (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dens, Cont, Tile, 2D plotting
@subsection Dens
@cindex Dens

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{Cont}, @ref{ContF}, @ref{Boxs}, @ref{Tile}, @ref{DensXYZ}. @sref{Dens sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dens (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cont, ContF, Dens, 2D plotting
@subsection Cont
@cindex Cont

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{ContF}, @ref{ContD}, @ref{Axial}, @ref{ContXYZ}. @sref{Cont sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont__val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContF, ContD, Cont, 2D plotting
@subsection ContF
@cindex ContF

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{Axial}, @ref{ContFXYZ}. @sref{ContF sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContD, Axial, ContF, 2D plotting
@subsection ContD
@cindex ContD

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContD (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contd_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}) with manual colors. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the contour colors: the color of k-th contour is determined by character @code{sch[k%strlen(sch)]}. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}. @sref{ContD sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContD (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contd_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContD (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contd_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContD (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contd (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Axial, Grad, ContD, 2D plotting
@subsection Axial
@cindex Axial

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Axial (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_axial_xy_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @var{AxialDir} (@pxref{Other settings}) will be set to specified direction. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Cont}, @ref{ContF}, @ref{Torus}, @ref{Surf3}. @sref{Axial sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Axial (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_axial_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} z, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Axial (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_axial_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Axial (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_axial (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Grad, Grid, Axial, 2D plotting
@subsection Grad
@cindex Grad

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grad (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}phi, @code{const char *}sch=@code{""}, @code{int} num=@code{5})
@deftypefnx {C function} @code{void} mgl_grad_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The function draws gradient lines for scalar field @var{phi}[i,j,k] specified parametrically @{@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Number of lines is proportional to @var{num}. If @var{num}<0 then lines start from borders only. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{phi} should be equal @code{x.nx=phi.nx && y.nx=phi.ny && z.nx=phi.nz} or @code{x.nx=y.nx=z.nx=phi.nx && x.ny=y.ny=z.ny=phi.ny && x.nz=y.nz=z.nz=phi.nz}. Arrays @var{x}, @var{y} and @var{z} can be vectors (not matrices as @var{phi}). See also @ref{Dens3}, @ref{Cont3}, @ref{Flow}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grad (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{5}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_grad_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The function draws gradient lines for scalar field @var{phi}[i,j] specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{phi}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Number of lines is proportional to @var{num}. If @var{num}<0 then lines start from borders only. The minor dimensions of arrays @var{x}, @var{y}, @var{phi} should be equal @code{x.nx=phi.nx && y.nx=phi.ny} or @code{x.nx=y.nx=phi.nx && x.ny=y.ny=phi.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{phi}). Lines are plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}, @ref{Flow}. @sref{Grad sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grad (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{int} num=@code{5}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_grad (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{int} num, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Grid, , Grad, 2D plotting
@subsection Grid
@cindex Grid

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grid (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_grid_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also @ref{Dens}, @ref{Cont}, @ref{ContF}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grid (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_grid (@code{HMGL} gr, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node 3D plotting, Dual plotting, 2D plotting, MathGL core
@section 3D plotting

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 5 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 functions have variants for automatic and manual selection of level values for surfaces/contours. Also there are functions for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}. @sref{3D plot sample}

@menu
* Surf3:: 
* Dens3:: 
* Cont3:: 
* ContF3:: 
* Grid3:: 
* Cloud:: 
* Beam:: 
@end menu

@c ==================================================================
@node Surf3, Dens3, , 3D plotting
@subsection Surf3
@cindex Surf3

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3 (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Cloud}, @ref{Dens3}, @ref{Surf3C}, @ref{Surf3A}, @ref{Axial}. @sref{Surf3 sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3 (@code{float} val, @code{const mglData &}a, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3 (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dens3, Cont3, Surf3, 3D plotting
@subsection Dens3
@cindex Dens3
@cindex DensA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dens3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens}, @ref{Grid3}. @sref{Dens3 sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dens3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DensA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
Draws density plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DensA (@code{const mglData &}a, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cont3, ContF3, Dens3, 3D plotting
@subsection Cont3
@cindex Cont3
@cindex ContA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3_xyz_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{stl} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. If string @var{stl} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{ContF3}, @ref{Cont}, @ref{Grid3}. @sref{Cont3 sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cont3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContA (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node ContF3, Grid3, Cont3, 3D plotting
@subsection ContF3
@cindex ContF3
@cindex ContFA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3_xyz_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{stl} have symbol @samp{#} then grid lines are drawn. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Dens3}, @ref{Cont3}, @ref{ContF}, @ref{Grid3}. @sref{ContF3 sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF3 (@code{const mglData &}v, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl, @code{int} num)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContF3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{int} num)
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFA (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Grid3, Cloud, ContF3, 3D plotting
@subsection Grid3
@cindex Grid3
@cindex GridA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grid3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}stl)
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Grid is plotted at slice @var{sVal} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Cont3}, @ref{ContF3}, @ref{Dens3}, @ref{Grid}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Grid3 (@code{const mglData &}a, @code{char} dir, @code{int} sVal=@code{-1}, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3 (@code{HMGL} gr, @code{const HMDT} a, @code{char} dir, @code{int} sVal, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} GridA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3_all_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl)
Draws grids at all central slices of the 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} GridA (@code{const mglData &}a, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3_all (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Cloud, Beam, Grid3, 3D plotting
@subsection Cloud
@cindex CloudP
@cindex CloudQ

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cloud (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} alpha=@code{1})
@deftypefnx {C function} @code{void} mgl_cloud_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on MeshNum (@pxref{Other settings}). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{alpha} changes the overall transparency of plot. The minor dimensions of arrays @var{x}, @var{y}, @var{z} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). See also @ref{Surf3}. @sref{Cloud sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Cloud (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} alpha=@code{1})
@deftypefnx {C function} @code{void} mgl_cloud (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} CloudP (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} alpha=@code{1})
@deftypefnx {C function} @code{void} mgl_cloudp_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as first one but the semi-transparent points are used instead of cubes. @sref{CloudP sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} CloudP (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} alpha=@code{1})
@deftypefnx {C function} @code{void} mgl_cloudp (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} alpha=@code{1})
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Beam, , Cloud, 3D plotting
@subsection Beam
@cindex Beam

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Beam (@code{float} val, @code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_beam_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} tr, @code{const HMDT} g1, @code{const HMDT} g2, @code{const HMDT} a, @code{float} r, @code{const char *}stl, @code{int} flag)
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Beam (@code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_beam (@code{HMGL} gr, @code{const HMDT} tr, @code{const HMDT} g1, @code{const HMDT} g2, @code{const HMDT} a, @code{float} r, @code{const char *}stl, @code{int} flag=@code{0}, @code{int} num=@code{3})
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn



@c ##################################################################
@node Dual plotting, Vector fields, 3D plotting, MathGL core
@section Dual plotting

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* SurfC:: 
* Surf3C:: 
* SurfA:: 
* Surf3A:: 
* TileS:: 
* Map:: 
* STFA:: 
@end menu

@c ==================================================================
@node SurfC, Surf3C, , Dual plotting
@subsection SurfC
@cindex SurfC

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SurfC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surfc_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfA}, @ref{Surf3C}. @sref{SurfC sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SurfC (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surfc (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Surf3C, SurfA, SurfC, Dual plotting
@subsection Surf3C
@cindex Surf3C

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3C (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the color of isosurface depends on values of array @var{c}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfC}, @ref{Surf3A}. @sref{Surf3C sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3C (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3C (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3c_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3C (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3c (@code{HMGL} gr, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node SurfA, Surf3A, Surf3C, Dual plotting
@subsection SurfA
@cindex SurfA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SurfA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surfa_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{Surf}, @ref{SurfC}, @ref{Surf3A}, @ref{TileS}. @sref{SurfA sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SurfA (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surfa (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Surf3A, TileS, SurfA, Dual plotting
@subsection Surf3A
@cindex Surf3A

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3A (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a_xyz_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl)
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as Surf3() function but the transparency of isosurface depends on values of @var{b} array. This allows one to remove the part of isosurface where @var{b} is negligibly small (useful for phase plotting of a beam or a pulse). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. All dimensions of arrays @var{z} and @var{c} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{Surf3}, @ref{SurfA}, @ref{Surf3C}. @sref{Surf3A sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3A (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a_val (@code{HMGL} gr, @code{float} val, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3A (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}stl=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3a_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}stl, @code{int} num)
Draws @var{num}-th uniformly distributed in range [@var{Cmin}, @var{Cmax}] isosurfaces for 3d data specified parametrically.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf3A (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_surf3a (@code{HMGL} gr, @code{const HMDT} a, @code{const HMDT} c, @code{const char *}sch, @code{int} num)
The same as previous with @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node TileS, Map, Surf3A, Dual plotting
@subsection TileS
@cindex TileS

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TileS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_tiles_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} r, @code{const char *}sch)
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as Tile() but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Surface is plotted for each z slice of the data. See also @ref{SurfA}, @ref{Tile}. @sref{TileS sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TileS (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_tiles (@code{HMGL} gr, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Map, STFA, TileS, Dual plotting
@subsection Map
@cindex Map

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Map (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
@deftypefnx {C function} @code{void} mgl_map_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} ks, @code{int} pnts)
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The initial position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If @code{pnts=false} then face is drawn otherwise the color ball at matrix knots are drawn. Parameter @var{ks} specifies the slice of matrices which will be used. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{ax} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{ax}). @xref{Color scheme}. @sref{Map sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Map (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{int} ks=@code{0}, @code{bool} pnts=@code{true})
@deftypefnx {C function} @code{void} mgl_map (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} ks, @code{int} pnts)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node STFA, , Map, Dual plotting
@subsection STFA
@cindex STFA

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} STFA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_stfa_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} re, @code{const HMDT} im, @code{int} dn, @code{const char *}sch, @code{float} zVal)
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}).  @sref{STFA sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} STFA (@code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_stfa (@code{HMGL} gr, @code{const HMDT} re, @code{const HMDT} im, @code{int} dn, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node Vector fields, Other plotting, Dual plotting, MathGL core
@section Vector fields

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vectors along the curve (Traj), vector field by dew-drops (Dew), flow threads (Flow, FlowP), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* Traj:: 
* Vect:: 
* VectL:: 
* VectC:: 
* Dew:: 
* Flow:: 
* FlowP:: 
* Pipe:: 
@end menu

@c ==================================================================
@node Traj, Vect, , Vector fields
@subsection Traj
@cindex Traj

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Traj (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{float} len=@code{0})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Traj (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN}, @code{float} len=@code{0})
@deftypefnx {C function} @code{void} mgl_traj_xyz (@code{HMGL} gr, @code{const HMDT}x, @code{const HMDT}y, @code{const HMDT}z, @code{const HMDT}ax, @code{const HMDT}ay, @code{const HMDT}az, @code{const char *}sch, @code{float} len)
@deftypefnx {C function} @code{void} mgl_traj_xy (@code{HMGL} gr, @code{const HMDT}x, @code{const HMDT}y, @code{const HMDT}ax, @code{const HMDT}ay, @code{const char *}sch, @code{float} zVal, @code{float} len)
The function draws vectors @{@var{ax}, @var{ay}, @var{az}@} along a curve @{@var{x}, @var{y}, @var{z}@}. The length of arrows are proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. String @var{pen} specifies the color (@pxref{Line styles}). By default (@code{pen=""}) color from palette is used (@pxref{Palette and colors}). Parameter @var{len} set the vector length factor (if non-zero) or vector length to be proportional the distance between curve points (if @var{len}=0). The minor sizes of all arrays must be equal and large 2. The plots are drawn for each row if one of the data is the matrix. See also @ref{Vect}. @sref{Traj sample}
@end deftypefn

@c ==================================================================
@node Vect, VectL, Traj, Vector fields
@subsection Vect
@cindex Vect

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_vect_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal, @code{int} flag)
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of arrows depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. Parameter @var{flag} is bitwise flag for setup the hachures (arrows): @code{MGL_VEC_COL} for drawing bi-color arrow, @code{MGL_VEC_LEN} for drawing fixed length arrows, @code{MGL_VEC_DOT} for drawing hachures with dots instead of arrows, @code{MGL_VEC_END} for drawing arrows to the cell point, @code{MGL_VEC_MID} for drawing arrows with center at cell point. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{VectL}, @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{Vect sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_vect_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal, @code{int} flag)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_vect_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} flag)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length and color of arrows is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Vect 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_vect_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} flag)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node VectL, VectC, Vect, Vector fields
@subsection VectL
@cindex VectL

These functions are obsolete -- use Vect() functions instead.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectL (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_vectl_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). Points are denote the start of hachures. The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}, @ref{Flow}, @ref{Dew}. @sref{VectL sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectL (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_vectl_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectL (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_vectl_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectL 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectL (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_vectl_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node VectC, Dew, VectL, Vector fields
@subsection VectC
@cindex VectC

These functions are obsolete -- use Vect() functions instead.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_vectc_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of hachures depend on @var{MeshNum} (@pxref{Other settings}). Points are denote the start of hachures. The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectL}, @ref{Flow}, @ref{Dew}. @sref{VectC sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectC (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_vectc_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_vectc_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{VectC 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} VectC (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_vectc_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Dew, Flow, VectC, Vector fields
@subsection Dew
@cindex Dew

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dew (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dew_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z=zVal}. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @var{MeshNum} (@pxref{Other settings}). The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Vect}, @ref{VectC}. @sref{Dew sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dew (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dew (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node Flow, FlowP, Dew, Vector fields
@subsection Flow
@cindex Flow

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_flow_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} num, @code{int} central, @code{float} zVal)
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of threads is proportional to @var{num}. Parameter @var{central} sets the thread start from center (if true) or only from edges (if false). From v.1.11 it is ignored and always equal to (@var{num}>0). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}. @sref{Flow sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_flow_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{int} num, @code{int} central, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{int} num=@code{3}, @code{bool} central=@code{true})
@deftypefnx {C function} @code{void} mgl_flow_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{int} num=@code{3}, @code{bool} central=@code{true})
@deftypefnx {C function} @code{void} mgl_flow_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{int} num, @code{int} central)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@c ==================================================================
@node FlowP, Pipe, Flow, Vector fields
@subsection FlowP
@cindex FlowP

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} FlowP (@code{float} x0, @code{float} y0, @code{float} z0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_xy (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch)
The function draws flow thread for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} from point @var{p0} at level z = @var{p0}.z. The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Pipe}, @ref{VectC}, @ref{Vect}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} FlowP (@code{float} x0, @code{float} y0, @code{float} z0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_2d (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} FlowP (@code{float} x0, @code{float} y0, @code{float} z0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_xyz (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Flow 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (Python)} @code{void} FlowP (@code{float} x0, @code{float} y0, @code{float} z0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_3d (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ==================================================================
@node Pipe, , FlowP, Vector fields
@subsection Pipe
@cindex Pipe

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_pipe_xy (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central, @code{float} zVal)
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level z = @var{zVal}. Number of pipes is proportional to @var{num}. Parameter @var{central} sets the pipe start from center (if true) or only from edges (if false). From v.1.11 it is ignored and always equal to (@var{num}>0). The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). String @var{sch} sets the color scheme. Previous color scheme is used by default. Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{Flow}, @ref{VectC}, @ref{Vect}. @sref{Pipe sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{int} num=@code{5}, @code{bool} central=@code{true}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_pipe_2d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central, @code{float} zVal)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
@deftypefnx {C function} @code{void} mgl_pipe_xyz (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central)
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. @sref{Pipe 3D sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{int} num=@code{3}, @code{bool} central=@code{true})
@deftypefnx {C function} @code{void} mgl_pipe_3d (@code{HMGL} gr, @code{const HMDT} ax, @code{const HMDT} ay, @code{const HMDT} az, @code{const char *}sch, @code{float} r0, @code{int} num, @code{int} central)
The same as previous with @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn


@c ##################################################################
@node Other plotting, Nonlinear fitting, Vector fields, MathGL core
@section Other plotting

These functions perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@menu
* DensXYZ:: 
* ContXYZ:: 
* ContFXYZ:: 
* Dots:: 
* Crust:: 
* TriPlot:: 
* TriCont:: 
* QuadPlot:: 
* Plots by formula:: 
* SimplePlot:: 
@end menu

@c ==================================================================
@node DensXYZ, ContXYZ, , Other plotting
@subsection DensXYZ
@cindex DensX
@cindex DensY
@cindex DensZ

These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->DensX(c.Sum("x"),"BbcyrR",-1);
gr->DensY(c.Sum("y"),0,1);
gr->DensZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{Dens}, @ref{Data distributions}. @sref{Dens projection sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DensX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DensY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} DensZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws density plot for data @var{a} at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node ContXYZ, ContFXYZ, DensXYZ, Other plotting
@subsection ContXYZ
@cindex ContX
@cindex ContY
@cindex ContZ

These plotting functions draw contour lines in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->ContX(c.Sum("x"),"BbcyrR",-1);
gr->ContY(c.Sum("y"),0,1);
gr->ContZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{Cont}, @ref{Data distributions}. @sref{Cont projection sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_cont_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th contour lines for data @var{a} at z = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont_x_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont_y_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_cont_z_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws contour lines for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node ContFXYZ, Dots, ContXYZ, Other plotting
@subsection ContFXYZ
@cindex ContFX
@cindex ContFY
@cindex ContFZ

These plotting functions draw solid contour lines in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. See also @ref{ContXYZ}, @ref{DensXYZ}, @ref{ContF}, @ref{Data distributions}.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf_x (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th solid contours for data @var{a} at x = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf_y (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th solid contours for data @var{a} at y = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{int} num=@code{7})
@deftypefnx {C function} @code{void} mgl_contf_z (@code{HMGL} gr, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal, @code{int} num)
Draws @var{num}-th solid contours for data @var{a} at z = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_x_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at x = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_y_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at y = @var{sVal}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ContFZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_contf_z_val (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} a, @code{const char *}stl, @code{float} sVal)
Draws solid contours for data @var{a}=@var{v}[i] at z = @var{sVal}.
@end deftypefn

@c ==================================================================
@node Dots, Crust, ContFXYZ, Other plotting
@subsection Dots
@cindex Dots

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_dots (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_dots_a (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}sch)
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If array @var{a} is specified then it define the transparency of dots. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also @ref{Crust}, @ref{Mark}, @ref{Plot}. @sref{Dots sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Dots (@code{const mglData &}tr, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_dots_tr (@code{HMGL} gr, @code{const HMDT} tr, @code{const char *}sch)
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:) and if @var{tr}.nx>3 then @var{a=tr}(3,:).
@end deftypefn

@c ==================================================================
@node Crust, TriPlot, Dots, Other plotting
@subsection Crust
@cindex Crust

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Crust (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} er=@code{0})
@deftypefnx {C function} @code{void} mgl_crust (@code{HMGL} gr, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} er)
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Parameter @var{er} set relative radius for (increase it for removing holes). String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{Dots}, @ref{TriPlot}. @sref{Crust sample}
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Crust (@code{const mglData &}tr, @code{const char *}sch=@code{""}, @code{float} er=@code{0})
@deftypefnx {C function} @code{void} mgl_crust_tr (@code{HMGL} gr, @code{const HMDT} tr, @code{const char *}sch, @code{float} er)
The same as previous with @var{x=tr}(0,:), @var{y=tr}(1,:), @var{z=tr}(2,:).
@end deftypefn

@c ==================================================================
@node TriPlot, TriCont, Crust, Other plotting
@subsection TriPlot
@cindex TriPlot

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_triplot_xyz (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_triplot_xyzc (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{Dots}, @ref{Crust}, @ref{QuadPlot}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_triplot_xy (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypefn

@c ==================================================================
@node TriCont, QuadPlot, TriPlot, Other plotting
@subsection TriCont
@cindex TriCont

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TriContV (@code{const mglData &}v, @code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} TriContV (@code{const mglData &}v, @code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_tricont_xyzcv (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch, @code{float} zVal)
@deftypefnx {C function} @code{void} mgl_tricont_xyzv (@code{HMGL} gr, @code{const HMDT} v, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{float} zVal)
The function draws contour lines for surface of triangles at @var{z} = @var{zVal} (or for @var{z=v}[k] if @code{zVal==NAN}). Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Array @var{c} (if specified) is used for contour coloring. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{TriPlot}, @ref{Cont}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} TriCont (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{num}=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} TriCont (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{num}=@code{7}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_tricont_xyzc (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch, @code{num}, @code{float} zVal)
@deftypefnx {C function} @code{void} mgl_tricont_xyz (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch, @code{num}, @code{float} zVal)
The same as first one with vector @var{v} of @var{num}-th elements equidistantly distributed in range [@var{Cmin}, @var{Cmax}].
@end deftypefn

@c ==================================================================
@node QuadPlot, Plots by formula, TriCont, Other plotting
@subsection QuadPlot
@cindex QuadPlot

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_quadplot_xyz (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const char *}sch)
@deftypefnx {C function} @code{void} mgl_quadplot_xyzc (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} c, @code{const char *}sch)
The function draws the surface of quadrangles. Quadrangles vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 4 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of quadrangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{TriPlot}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const char *}sch=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_quadplot_xy (@code{HMGL} gr, @code{const HMDT} id, @code{const HMDT} x, @code{const HMDT} y, @code{const char *}sch, @code{float} zVal)
The same as previous with @var{z}[i]=@var{zVal}.
@end deftypefn

@c ==================================================================
@node Plots by formula, SimplePlot, QuadPlot, Other plotting
@subsection Plots by formula
@cindex Plot
@cindex Surf

These functions perform plotting of 1D or 2D functions specified by textual formula. You do not need to create the data arrays to plot it. The parameter @var{stl} set the line style (@pxref{Line styles}) for @code{Plot()} or color scheme (@pxref{Color scheme}) for @code{Surf()}. The parameter @var{n} set the minimal number of points along coordinate(s) for plots. At this time (v. 1.10) there is adaptive increase of data points numbers but only for 1D variant (i.e. for Plot()).

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Plot (@code{const char *}eqY, @code{const char *}stl=@code{""}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
@deftypefnx {C function} @code{void} mgl_fplot (@code{HMGL} gr, @code{const char *}eqY, @code{const char *}stl, @code{float} zVal, @code{int} n)
The function draws function @samp{eqY(x)} at plane z=@var{zVal} where @samp{x} variable is changed in range [@var{Min}.x, @var{Max}.x]. See also @ref{Plot}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Plot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{""}, @code{float} zVal=@code{NAN}, @code{int} n=@code{100})
@deftypefnx {C function} @code{void} mgl_fplot_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl, @code{float} zVal, @code{int} n)
The function draws parametrical curve @{@samp{eqX(t)}, @samp{eqY(t)}, @samp{eqZ(t)}@} where @samp{t} variable is changed in range [0, 1]. See also @ref{Plot}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf (@code{const char *}eqZ, @code{const char *}stl=@code{""}, @code{int} n=@code{100});
@deftypefnx {C function} @code{void} mgl_fsurf (@code{HMGL} gr, @code{const char *}eqZ, @code{const char *}stl, @code{int} n);
The function draws surface for function @samp{eqY(x,y)} where @samp{x}, @samp{y} variables are changed in range [@var{Min}, @var{Max}]. See also @ref{Surf}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Surf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl=@code{""}, @code{int} n=@code{100})
@deftypefnx {C function} @code{void} mgl_fsurf_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}stl, @code{int} n)
The function draws parametrical surface @{@samp{eqX(u,v)}, @samp{eqY(u,v)}, @samp{eqZ(u,v)}@} where @samp{u}, @samp{v} variables are changed in range [0, 1]. See also @ref{Surf}.
@end deftypefn

@c ==================================================================
@node SimplePlot, , Plots by formula, Other plotting
@subsection SimplePlot
@cindex SimplePlot

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} SimplePlot (@code{const mglData &}a, @code{int} type=@code{0}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_simple_plot (@code{HMGL} gr, @code{const HMDT} a, @code{int} type, @code{const char *}stl)
Plots the array @var{a} depending on it's dimensions and @var{type} parameter. String @var{stl} specifies the style of plotting. For 1d data: @code{type=0} -- @ref{Plot}, @code{type=1} -- @ref{Area}, @code{type=2} -- @ref{Step}, @code{type=3} -- @ref{Stem}, @code{type=4} -- @ref{Bars}. For 2d data: @code{type=0} -- @ref{Surf}, @code{type=1} -- @ref{Dens}, @code{type=2} -- @ref{Mesh}, @code{type=3} -- @ref{Cont}. For 3d data: @code{type=0} -- @ref{Surf3}, @code{type=1} -- @ref{Dens3}, @code{type=2} -- @ref{Cont3}, @code{type=2} -- @ref{Cloud}.
@end deftypefn

@c ##################################################################
@node Nonlinear fitting, Data distributions, Other plotting, MathGL core
@section Nonlinear fitting
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex FitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (@pxref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return the @math{\chi^2} error of approximation. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the interval @var{Min}--@var{Max}. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{FitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xyzas (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyzas_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xyzs (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyzs_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) for each data slice.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xys (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xys_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) for each data slice.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} FitS (@code{mglData &}fit, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_ys (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_ys_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const HMDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array with @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xyza (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyza_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with @var{s}[i,j,k]=1.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xyz (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xyz_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array specified parametrically @var{a}[i,j](@var{x}[i,j], @var{y}[i,j]) with @var{s}[i,j]=1 for each data slice.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_xy (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_xy_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} x, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array specified parametrically @var{a}[i](@var{x}[i]) with @var{s}[i]=1 for each data slice.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{""}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_1 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_1_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-direction for 1d array @var{a} with @var{s}=1 and @var{x} equidistantly distributed in interval [@var{Min}.x, @var{Max}.x].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit2 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit2 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_2 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_2_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, and y-directions for 2d array @var{a} with @var{s}=1 and @var{x}, @var{y} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{float} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{float *}ini=@code{NULL}, @code{bool} print=@code{false})
@deftypefnx {Method on @code{mglGraph} (C++, Python)} @code{float} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{bool} print=@code{false})
@deftypefnx {C function} @code{float} mgl_fit_3 (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{float *}ini)
@deftypefnx {C function} @code{float} mgl_fit_3_d (@code{HMGL} gr, @code{HMDT} fit, @code{const HMDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini)
Fit data along x-, y- and z-directions for 3d array @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{""}, @code{const char *}font=@code{NULL}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_fit (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}prefix, @code{const char *}font, @code{float} size=@code{-1})
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{const char *}GetFit ()
@deftypefnx {C function} @code{const char *} mgl_get_fit (@code{HMGL} gr)
Get last fitted formula with found coefficients (as numbers).
@end deftypefn

@deftypecv {General option (C++)} mglGraph @code{int} FitPnts
Minimal number of points for output array after nonlinear fitting.
@end deftypecv



@c ##################################################################
@node Data distributions, Frames/Animation, Nonlinear fitting, MathGL core
@section Data distributions
@cindex Hist

These functions make distribution (histogram) of data. They do not draw the obtained data themselves. These functions can be useful if user have data defined for random points (for example, after PIC simulation) and he want to produce a plot which require regular data (defined on grid(s)). The range for grids is always selected as axis range Min...Max. Arrays @var{x}, @var{y}, @var{z} define the positions (coordinates) of random points. Array @var{a} define the data value. Number of points in output array @var{res} is selected as maximal value of @var{res} size and the value of @var{FitPnts}.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Hist (@code{mglData &}res, @code{const mglData &}x, @code{const mglData &}a)
@deftypefnx {C function} @code{int} mgl_hist_x (@code{HMGL} gr, @code{HMDT} res, @code{const HMDT} x, @code{const HMDT} a)
Creates 1D distribution of the data values @var{a} in range [Min, Max].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Hist (@code{mglData &}res, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a)
@deftypefnx {C function} @code{int} mgl_hist_xy (@code{HMGL} gr, @code{HMDT} res, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} a)
Creates 2D distribution of the data values @var{a} in range [Min, Max].
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Hist (@code{mglData &}res, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a)
@deftypefnx {C function} @code{int} mgl_hist_xyz (@code{HMGL} gr, @code{HMDT} res, @code{const HMDT} x, @code{const HMDT} y, @code{const HMDT} z, @code{const HMDT} a)
Creates 3D distribution of the data values @var{a} in range [Min, Max].
@end deftypefn


@c ##################################################################
@node Frames/Animation, IDTF functions, Data distributions, MathGL core
@section Frames/Animation
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide ability to create several pictures simultaneously. For most of cases it is useless but for widget classes (@pxref{Widget classes}) they can provide a way to show animation. Also you can write several frames into animated GIF file.

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{int} NewFrame ()
@deftypefnx {C function} @code{int} mgl_new_frame (@code{HMGL} gr)
Creates new frame. Function returns current frame id. This is not thread safe function in OpenGL mode! Use direct list creation in multi-threading drawing. The function @code{EndFrame()} @strong{must} be call after the finishing of the frame drawing for each call of this function.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} EndFrame ()
@deftypefnx {C function} @code{void} mgl_end_frame (@code{HMGL} gr)
Finishes the frame drawing.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{int} GetNumFrame ()
@deftypefnx {C function} @code{int} mgl_get_num_frame (@code{HMGL} gr)
Gets the number of created frames.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} ResetFrames ()
@deftypefnx {C function} @code{int} mgl_reset_frames (@code{HMGL} gr)
Reset frames counter (start it from zero).
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
@deftypefnx {C function} @code{void} mgl_start_gif (@code{HMGL} gr, @code{const char *}fname, @code{int} ms)
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use CloseGIF() to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{int} CloseGIF ()
@deftypefnx {C function} @code{void} mgl_close_gif (@code{HMGL} gr)
Finish writing animated GIF and close connected pointers.
@end deftypefn

@c ##################################################################
@node IDTF functions, , Frames/Animation, MathGL core
@section IDTF functions
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide IDTF specific features. In all other cases they do nothing.

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} VertexColor (@code{bool} enable)
Enables smooth color change.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} Compression (@code{bool} enable)
Gives smaller files, but quality degrades.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} StartGroup (const char *name)
Starts group definition. Groups contain objects and other groups, they are used to select a part of a model to zoom to or to make invizible or to make transparent and so on.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++)} @code{void} EndGroup ()
Ends group definition.
@end deftypefn

