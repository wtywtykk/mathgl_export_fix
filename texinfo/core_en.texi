@c ------------------------------------------------------------------
@chapter MathGL core
@cindex mglGraph

@ifclear UDAV
The core of MathGL is @strong{mglGraph} class defined in @code{#include <mgl/mgl.h>}. It contains a lot of plotting functions for 1D, 2D and 3D data. It also encapsulates parameters for axes drawing. Moreover an arbitrary coordinate transformation can be used for each axis. All plotting functions use data encapsulated in mglData class (see @ref{Data processing}) that allows to check sizes of used arrays easily. Also it have many functions for data handling: modify it by formulas, find momentums and distribution (histogram), apply operator (differentiate, integrate, transpose, Fourier and so on), change data sizes (interpolate, squeeze, crop and so on). Additional information about colors, fonts, formula parsing can be found in @ref{General concepts} and @ref{Other classes}.
@end ifclear

@menu
* Constructor::
* Graphics setup::
* Axis settings::
* Transformation matrix::
* Export picture::
* Primitives drawing::
* Text printing::
* Axis and Colorbar::
* Legend::
* 1D plotting::
* 2D plotting::
* 3D plotting::
* Dual plotting::
* Vector fields::
* Other plotting::
* Nonlinear fitting::
* Data manipulation::
* IDTF functions::
@end menu

@c ##################################################################
@node Constructor, Graphics setup, , MathGL core
@section Create and delete objects

@ifclear UDAV
@deftypefn {Constructor on @code{mglGraph}} {} mglGraph (@code{int} kind=@code{0}, @code{int} width=@code{600}, @code{int} height=@code{400})
@deftypefnx {Constructor on @code{mglGraph}} {} mglGraph (@code{const mglGraph &}gr)
@deftypefnx {Constructor on @code{mglGraph}} {} mglGraph (@code{HMGL} gr)
@deftypefnx {C function} @code{HMGL} mgl_create_graph (@code{int} width, @code{int} height)
@deftypefnx {C function} @code{HMGL} mgl_create_graph_gl ()
Creates the instance of class mglGraph with specified sizes @var{width} and @var{height}. Parameter @var{kind} may have following values: @samp{0} -- use default plotter, @samp{1} -- use OpenGL plotter.
@end deftypefn

@deftypefn {Destructor on @code{mglGraph}} {} ~mglGraph ()
@deftypefnx {C function} @code{HMGL} mgl_delete_graph (@code{HMGL} gr)
Deletes the instance of class mglGraph.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{HMGL} Self ()
Returns the pointer to internal object of type @code{HMGL}.
@end deftypefn
@end ifclear

@ifset UDAV
You don't need to create canvas object in MGL.
@end ifset

@c ##################################################################
@node Graphics setup, Axis settings, Constructor, MathGL core
@section Graphics setup
@cindex MathGL setup

Functions and variables in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting function calls.

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} DefaultPlotParam ()
@deftypefnx {C function} @code{void} mgl_set_def_param (@code{HMGL} gr)
Restore initial values for all of parameters.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetPlotId (@code{const char *}id)
@deftypefnx {C function} @code{void} mgl_set_plotid (@code{HMGL} gr, @code{const char *}id)
Sets name of plot for saving filename (in FLTK window for example).
@end deftypefn
@end ifclear

@menu
* Transparency::
* Lighting::
* Fog::
* Default sizes::
* Cutting::
* Font settings::
* Palette and colors::
* Error handling::
@end menu

@c ==================================================================
@node Transparency, Lighting, , Graphics setup
@subsection Transparency
@cindex Alpha
@ifclear UDAV
@cindex SetAlphaDef
@cindex SetTranspType
@end ifclear
@cindex AlphaDef
@cindex TranspType

There are several functions and variables for setup transparency. The general function is @ref{alpha} which switch on/off the transparency for overall plot. It influence only for graphics which created after @ref{alpha} call (with one exception, OpenGL). Function @ref{alphadef} specify the default value of alpha-channel. Finally, function @ref{transptype} set the kind of transparency. @sref{Transparent surface sample}

@anchor{alpha}
@deftypefn {MGL command} {} alpha @code{[val=on]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Alpha (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_alpha (@code{HMGL} gr, @code{int} enable)
@end ifclear
Sets the transparency on/off and returns previous value of transparency. It is recommended to call this function before any plotting command. Default value is transparency off.
@end deftypefn

@anchor{alphadef}
@deftypefn {MGL command} {} alphadef @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAlphaDef (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_alpha_default (@code{HMGL} gr, @code{float} alpha)
@end ifclear
Sets default value of alpha channel (transparency) for all plotting functions. Initial value is 0.5.
@end deftypefn

@anchor{transptype}
@deftypefn {MGL command} {} transptype @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTranspType (@code{int} type)
@deftypefnx {C function} @code{void} mgl_set_transp_type (@code{HMGL} gr, @code{int} enable)
@end ifclear
Set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{SetAlphaDef(0.3)} or less for lamp-like transparency. @xref{Normal transparency}, @ref{Glass-like transparency}, @ref{Lamp-like transparency}.
@end deftypefn

@c ==================================================================
@node Lighting, Fog, Transparency, Graphics setup
@subsection Lighting
@ifclear UDAV
@cindex SetAmbient
@cindex AddLight
@end ifclear
@cindex Light
@cindex Ambient

There are several functions for setup lighting. The general function is @code{Light(bool)} which switch on/off the lighting for overall plot. It influence only for graphics which created after @ref{light} call (with one exception, OpenGL). Generally MathGL support up to 10 independent light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@anchor{light}
@deftypefn {MGL command} {} light @code{[val=on]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{bool} Light (@code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light (@code{HMGL} gr, @code{int} enable)
@end ifclear
Sets the using of light on/off for overall plot. Function returns previous value of lighting. Default value is lightning off.
@end deftypefn

@deftypefn {MGL command} {} light @code{num} @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Light (@code{int} n, @code{bool} enable)
@deftypefnx {C function} @code{void} mgl_set_light_n (@code{HMGL} gr, @code{int} n, @code{int} enable)
@end ifclear
Switch on/off @var{n}-th light source separately.
@end deftypefn

@deftypefn {MGL command} {} light @code{num xdir ydir zdir} ['col'='w' @code{br=0.5}]
@deftypefnx {MGL command} {} light @code{num xdir ydir zdir xpos ypos zpos} ['col'='w' @code{br=0.5}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{float} bright=@code{0.5}, @code{float} ap=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLight (@code{int} n, @code{mglPoint} r, @code{mglPoint} d, @code{char} c=@code{'w'}, @code{float} bright=@code{0.5}, @code{float} ap=@code{0})
@deftypefnx {C function} @code{void} mgl_add_light (@code{HMGL} gr, @code{int} n, @code{float} dx, @code{float} dy, @code{float} dz)
@deftypefnx {C function} @code{void} mgl_add_light_ext (@code{HMGL} gr, @code{int} n, @code{float} dx, @code{float} dy, @code{float} dz, @code{char} c, @code{float} bright, @code{float} ap)
@deftypefnx {C function} @code{void} mgl_add_light_loc (@code{HMGL} gr, @code{int} n, @code{float} rx, @code{float} ry, @code{float} rz, @code{float} dx, @code{float} dy, @code{float} dz, @code{char} c, @code{float} bright, @code{float} ap)
@end ifclear
The function adds a light source with identification @var{n} in direction @var{d} with color @var{c} and with brightness @var{bright} (which must be in range [0,1]). If position @var{r} is specified and isn't NAN then light source is supposed to be local otherwise light source is supposed to be placed at infinity.
@end deftypefn

@anchor{diffuse}
@ifclear UDAV
@deftypefn {Метод класса @code{mglGraph}} @code{void} SetDifLight (@code{bool} enable)
@deftypefnx {Функция С} @code{void} mgl_set_light_dif (@code{HMGL} gr, @code{int} enable)
Set on/off to use diffusive light (only for local light sources).
@end deftypefn
@end ifclear

@anchor{ambient}
@deftypefn {MGL command} {} ambient @code{val}
@ifclear UDAV
@deftypefnx {Метод класса @code{mglGraph}} @code{void} SetAmbient (@code{float} bright=@code{0.5})
@deftypefnx {Функция С} @code{void} mgl_set_ambbr (@code{HMGL} gr, @code{float} bright)
@end ifclear
Sets the brightness of ambient light. The value should be in range [0,1].
@end deftypefn

@c ==================================================================
@node Fog, Default sizes, Lighting, Graphics setup
@subsection Fog
@cindex Fog

@anchor{fog}
@deftypefn {MGL command} {} fog @code{val [dz=0.25]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fog (@code{float} d, @code{float} dz=@code{0.25})
@deftypefnx {C function} @code{void} mgl_set_fog (@code{HMGL} gr, @code{float} d, @code{float} dz)
@end ifclear
Function imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{d*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{d}=@code{0} then the fog is absent. Note, that fog was applied at stage of image creation, not at stage of drawing. @sref{Surface in fog sample}
@end deftypefn

@c ==================================================================
@node Default sizes, Cutting, Fog, Graphics setup
@subsection Default sizes
@ifclear UDAV
@cindex SetBarWidth
@cindex SetMarkSize
@cindex SetArrowSize
@cindex SetMeshNum
@cindex SetPlotId
@end ifclear
@cindex BarWidth
@cindex MarkSize
@cindex ArrowSize
@cindex MeshNum

These variables control the default (initial) values for most graphics parameters including sizes of markers, arrows, line width and so on. As any other settings these ones will influence only on plots created after the settings change.

@anchor{barwidth}
@deftypefn {MGL command} {} barwidth @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetBarWidth ( @code{float} val)
@deftypefnx {C function} @code{void} mgl_set_bar_width (@code{HMGL} gr, @code{float} val)
@end ifclear
Sets relative width of rectangles in @ref{bars}, @ref{barh}, @ref{boxplot}, @ref{candle}. Default value is @code{0.7}.
@end deftypefn

@anchor{marksize}
@deftypefn {MGL command} {} marksize @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMarkSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_mark_size (@code{HMGL} gr, @code{float} val)
@end ifclear
Sets size of marks for @ref{1D plotting}. Default value is @code{0.02}.
@end deftypefn

@anchor{arrowsize}
@deftypefn {MGL command} {} arrowsize @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetArrowSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_arrow_size (@code{HMGL} gr, @code{float} val)
@end ifclear
Sets size of arrows for @ref{1D plotting}, lines and curves (see @ref{Primitives drawing}). Default value is @code{0.03}.
@end deftypefn

@anchor{meshnum}
@anchor{MeshNum}
@deftypefn {MGL command} {} meshnum @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetMeshNum (@code{int} val)
@deftypefnx {C function} @code{void} mgl_set_meshnum (@code{HMGL} gr, @code{int} num)
@end ifclear
Sets approximate number of lines in @ref{mesh}, @ref{fall}, @ref{grid} and also the number of hachures in @ref{vect}, @ref{dew} and the number of cells in @ref{cloud}. By default (=0) it draws all lines/hachures/cells.
@end deftypefn

@c ==================================================================
@node Cutting, Font settings, Default sizes, Graphics setup
@subsection Cutting
@ifclear UDAV
@cindex SetCut
@cindex SetCutBox
@cindex CutOff
@end ifclear
@cindex Cut

These variables and functions set the condition when the points are excluded (cutted) from the drawing. Note, that a point with NAN value(s) of coordinate or amplitude will be automatically excluded from the drawing. @sref{Cut sample}

@anchor{cut}
@deftypefn {MGL command} {} cut @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCut (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_cut (@code{HMGL} gr, @code{int} val)
@end ifclear
Flag which determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deftypefn

@deftypefn {MGL command} {} cut @code{x1 y1 z1 x2 y2 z2}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCutBox (@code{mglPoint} p1, @code{mglPoint} p1)
@deftypefnx {C function} @code{void} mgl_set_cut_box (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2)
@end ifclear
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty.
@end deftypefn

@deftypefn {MGL command} {} cut 'cond'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} CutOff (@code{const char *}cond)
@deftypefnx {C function} @code{void} mgl_set_cutoff (@code{HMGL} gr, @code{const char *}cond)
@end ifclear
Sets the cutting off condition by formula @var{cond}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{""} to disable cutting off condition.
@end deftypefn

@c ==================================================================
@node Font settings, Palette and colors, Cutting, Graphics setup
@subsection Font settings
@ifclear UDAV
@cindex SetFontSize
@cindex SetFontDef
@cindex SetRotatedText
@cindex SetFontSizePT
@cindex SetFontSizeCM
@cindex SetFontSizeIN
@cindex LoadFont
@cindex CopyFont
@cindex RestoreFont
@end ifclear
@cindex Font
@cindex RotateText

@anchor{font}
@deftypefn {MGL command} {} font 'fnt' [@code{val=6}]
Font style for text and labels (see text). Initial style is 'fnt'=':rC' give Roman font with centering. Parameter @code{val} sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels. For more detail, see @ref{Font styles}.
@end deftypefn

@anchor{rotatetext}
@deftypefn {MGL command} {} rotatetext @code{val}
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRotatedText (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_rotated_text (@code{HMGL} gr, @code{int} val)
Sets to use or not text rotation.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetFontDef (@code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_set_font_def (@code{HMGL} gr, @code{const char *} val)
Sets the font specification (see @ref{Text printing}). Default is @samp{rC} -- Roman font centering.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetFontSize (@code{float} val)
@deftypefnx {C function} @code{void} mgl_set_font_size (@code{HMGL} gr, @code{float} val)
Sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetFontSizePT (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in pt and picture DPI (default is 16 pt for dpi=72).
@end deftypefn
@deftypefn {Method on @code{mglGraph}} @code{inline void} SetFontSizeCM (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in centimeters and picture DPI (default is 0.56 cm = 16 pt).
@end deftypefn
@deftypefn {Method on @code{mglGraph}} @code{inline void} SetFontSizeIN (@code{float} cm, @code{int} dpi=@code{72})
Set FontSize by size in inch and picture DPI (default is 0.22 in = 16 pt).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} LoadFont (@code{const char *}name, @code{const char *}path=@code{""})
@deftypefnx {C function} @code{void} mgl_load_font (@code{HMGL} gr, @code{const char *}name, @code{const char *}path)
Load font typeface from @var{path}/@var{name}.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} CopyFont (@code{mglGraph *} from)
@deftypefnx {C function} @code{void} mgl_copy_font (@code{HMGL} gr, @code{HMGL} gr_from)
Copy font data from another @code{mglGraph} object.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} RestoreFont ()
@deftypefnx {C function} @code{void} mgl_restore_font (@code{HMGL} gr)
Restore font data to default typeface.
@end deftypefn
@end ifclear

@c ==================================================================
@node Palette and colors, Error handling, Font settings, Graphics setup
@subsection Palette and colors
@ifclear UDAV
@cindex SetPalette
@end ifclear
@cindex Palette

@anchor{palette}
@deftypefn {MGL command} {} palette 'colors'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetPalette (@code{const char *}@var{colors})
@deftypefnx {C function} @code{void} mgl_set_palette (@code{HMGL} gr, @code{const char *}@var{colors})
@end ifclear
Sets the palette as selected colors. Default value is @code{"Hbgrcmyhlnqeup"} that corresponds to colors: dark gray @samp{H}, blue @samp{b}, green @samp{g}, red @samp{r}, cyan @samp{c}, magenta @samp{m}, yellow @samp{y}, gray @samp{h}, blue-green @samp{l}, sky-blue @samp{n}, orange @samp{q}, yellow-green @samp{e}, blue-violet @samp{u}, purple @samp{p}. The palette is used mostly in 1D plots (see @ref{1D plotting}) for curves which styles are not specified.
@end deftypefn

@c ==================================================================
@node Error handling, , Palette and colors, Graphics setup
@subsection Error handling
@ifclear UDAV
@cindex Message
@cindex SetWarn
@cindex GetWarn

Normally user should set it to zero by @code{SetWarn(0);} before plotting and check if @var{GetWarn} return non zero after plotting. Only last warning will be saved. All warnings/errors produced by MathGL is not critical -- the plot just will not be drawn.

@deftypefn {Method on @code{mglGraph}} @code{void} SetWarn (@code{int} code, @code{const char *}info=@code{""})
@deftypefnx {C function} @code{void} mgl_set_warn (@code{HMGL} gr, @code{int} code, @code{const char *}info)
Set warning code. Normally you should call this function only for clearing the warning state, i.e. call @code{SetWarn(0);}. Text @var{info} will be printed as is if @var{code}<0.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{const char *}Message ()
@deftypefnx {C function} @code{const char *}mgl_get_mess (@code{HMGL} gr)
Set buffer for writing messages about matters why some plot are not drawn. Set to NULL to disable messages. The buffer length must be at least 1024. If @var{buf}[0]==0 then there are no messages.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetWarnCode ()
@deftypefnx {C function} @code{int} mgl_get_warn_code (@code{HMGL} gr)
Return the numerical ID of warning about the not drawn plot. Possible values are:
@table @code
@item mglWarnNone=0
Everything OK
@item mglWarnDim
Data dimension(s) is incompatible
@item mglWarnLow
Data dimension(s) is too small
@item mglWarnNeg
Minimal data value is negative
@item mglWarnFile
No file or wrong data dimensions
@item mglWarnMem
Not enough memory
@item mglWarnZero
Data values are zero
@item mglWarnLegA
Too many legend entries
@item mglWarnLeg
No legend entries
@item mglWarnSlc
Slice value is out of range
@item mglWarnCnt
Number of contours is zero or negative
@item mglWarnOpen
Couldn't open file
@item mglWarnLId
Light: ID is out of range
@item mglWarnSize
Setsize: size(s) is zero or negative
@item mglWarnFmt
Format is not supported for that build
@end table
@end deftypefn
@end ifclear


@c ==================================================================
@node Axis settings, Transformation matrix, Graphics setup, MathGL core
@section Axis settings

These large set of variables and functions control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected if @code{Cut=true} (see @ref{Cutting}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@menu
* Ranges (bounding box)::
* Curved coordinates::
* Ticks::
@end menu

@c ------------------------------------------------------------------
@node Ranges (bounding box), Curved coordinates, , Axis settings
@subsection Ranges (bounding box)
@cindex CRange
@cindex XRange
@cindex YRange
@cindex ZRange
@cindex Ranges
@cindex Origin
@ifclear UDAV
@cindex SetRange
@cindex SetRanges
@cindex SetOrigin
@end ifclear

@anchor{xrange}
@anchor{yrange}
@anchor{zrange}
@anchor{crange}
@deftypefn {MGL command} {} xrange @code{v1 v2}
@deftypefnx {MGL command} {} yrange @code{v1 v2}
@deftypefnx {MGL command} {} zrange @code{v1 v2}
@deftypefnx {MGL command} {} crange @code{v1 v2}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{float} v1, @code{float} v2)
@deftypefnx {C function} @code{void} mgl_set_range_val (@code{HMGL} gr, @code{char} dir, @code{float} v1, @code{float} v2)
@end ifclear
Sets the range for @samp{x}-,@samp{y}-,@samp{z}- coordinate or coloring (@samp{c}). See also @ref{ranges}.
@end deftypefn


@deftypefn {MGL command} {} xrange dat [@code{add=off}]
@deftypefnx {MGL command} {} yrange dat [@code{add=off}]
@deftypefnx {MGL command} {} zrange dat [@code{add=off}]
@deftypefnx {MGL command} {} crange dat [@code{add=off}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRange (@code{char} dir, @code{const mglData &}dat, @code{bool} add=@code{false})
@deftypefnx {C function} @code{void} mgl_set_range_dat (@code{HMGL} gr, @code{char} dir, @code{const HCDT} a, @code{int} add)
@end ifclear
Sets the range for @samp{x}-,@samp{y}-,@samp{z}- coordinate or coloring (@samp{c}) as minimal and maximal values of data @var{dat}. Parameter @code{add=on} shows that the new range will be joined to existed one (not replace it).
@end deftypefn

@anchor{ranges}
@deftypefn {MGL command} {} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{mglPoint} p1, @code{mglPoint} p2)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1=@code{0}, @code{float} z2=@code{0})
@deftypefnx {C function} @code{void} mgl_set_ranges (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1, @code{float} z2)
@end ifclear
Sets the ranges of coordinates. If minimal and maximal values of the coordinate are the same then they are ignored. Also it sets the range for coloring (analogous to @code{crange z1 z2}). This is default color range for 2d plots. Initial ranges are [-1, 1].
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglData &}xx, @code{const mglData &}yy)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglData &}xx, @code{const mglData &}yy, @code{const mglData &}zz)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetRanges (@code{const mglData &}xx, @code{const mglData &}yy, @code{const mglData &}zz, @code{const mglData &}cc)
Sets the ranges of x-,y-,z-coordinates and coloring as minimal and maximal values of data @var{xx}, @var{yy}, @var{zz}, @var{cc} correspondingly.
@end deftypefn
@end ifclear

@anchor{origin}
@deftypefn {MGL command} {} origin @code{x0 y0 [z0=nan]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetOrigin (@code{mglPoint} p0)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetOrigin (@code{float} x0, @code{float} y0, @code{float} z0=@code{NAN})
@deftypefnx {C function} @code{void} mgl_set_origin (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0)
@end ifclear
Sets center of axis cross section. If one of values is NAN then MathGL try to select optimal axis position.
@end deftypefn



@c ------------------------------------------------------------------
@node Curved coordinates, Ticks, Ranges (bounding box), Axis settings
@subsection Curved coordinates
@cindex Axis
@ifclear UDAV
@cindex SetFunc
@cindex SetCoor
@cindex Ternary
@end ifclear

@deftypefn {MGL command} {} axis 'fx' 'fy' ['fz'='' 'fa'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetFunc (@code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ=@code{""}, @code{const char *}EqA=@code{""})
@deftypefnx {C function} @code{void} mgl_set_func (@code{HMGL} gr, @code{const char *}EqX, @code{const char *}EqY, @code{const char *}EqZ, @code{const char *}EqA)
@end ifclear
Sets transformation formulas for curvilinear coordinate. Each string should contain mathematical expression for real coordinate depending on internal coordinates @samp{x}, @samp{y}, @samp{z} and @samp{a} or @samp{c} for colorbar. For example, the cylindrical coordinates are introduced as @code{Axis("x*cos(y)", "x*sin(y)", "z");}. For removing of formulas the corresponding parameter should be empty or @code{NULL}. Using transformation formulas will slightly slowing the program. Parameter @var{EqA} set the similar transformation formula for color scheme. @xref{Textual formulas}.
@end deftypefn

@deftypefn {MGL command} {} axis @code{how}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetCoor (@code{int} how)
@deftypefnx {C function} @code{void} mgl_set_coor (@code{HMGL} gr, @code{int} how)
@end ifclear
Sets one of the predefined transformation formulas for curvilinear coordinate. Paramater @var{how} define the coordinates: @code{mglCartesian=0} -- Cartesian coordinates (no transformation); @code{mglPolar=1} -- Polar coordiantes @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @code{mglSpherical=2} -- Sperical coordinates @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @code{mglParabolic=3} -- Parabolic coordinates @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @code{mglParaboloidal=4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @code{mglOblate=5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @code{mglProlate=6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @code{mglElliptic=7} -- Elliptic coordinates @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @code{mglToroidal=8} -- Toroidal coordinates @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @code{mglBispherical=9} -- Bispherical coordinates @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @code{mglBipolar=10} -- Bipolar coordinates @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}; @code{mglLogLog=11} -- log-log coordiantes @math{x_n=lg(x), y_n=lg(y), z_n=lg(z)}; @code{mglLogX=12} -- log-x coordiantes @math{x_n=lg(x), y_n=y, z_n=z}; @code{mglLogY=13} -- log-y coordiantes @math{x_n=x, y_n=lg(y), z_n=z}.
@end deftypefn

@anchor{ternary}
@deftypefn {MGL command} {} ternary @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ternary (@code{int} tern)
@deftypefnx {C function} @code{void} mgl_set_ternary (@code{HMGL} gr, @code{int} tern)
@end ifclear
The function sets to draws Ternary or Quaternary plot. Ternary plot is special plot for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. Correspondingly Quaternary plot is plot for 4 dependent coordinates @var{a}, @var{b}, @var{c} and @var{d} so that @var{a}+@var{b}+@var{c}+@var{d}=1. Use @code{Ternary(0)} for returning to usual axis. @sref{Ternary plot sample}
@end deftypefn

@c ------------------------------------------------------------------
@node Ticks, , Curved coordinates, Axis settings
@subsection Ticks
@cindex AxisStl
@cindex TickLen
@cindex Adjust
@cindex XTick
@cindex YTick
@cindex ZTick
@cindex CTick
@ifclear UDAV
@cindex SetAxisStl
@cindex SetTickLen
@cindex SetTicks
@cindex SetTicksVal
@cindex SetTuneTicks
@cindex SetTickTime
@cindex SetTickTempl
@cindex SetTickRotate
@cindex SetTickSkip
@end ifclear

@anchor{adjust}
@deftypefn {MGL command} {} adjust ['dir'='xyzc']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Adjust (@code{const char *}dir=@code{"xyzc"})
@deftypefnx {C function} @code{void} mgl_adjust_ticks (@code{HMGL} gr, @code{const char *}dir)
@end ifclear
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}. Also set @code{SetTuneTicks(true)}. Usually you don't need to call this function except the case of returning to default settings.
@end deftypefn

@anchor{xtick}
@anchor{ytick}
@anchor{ztick}
@anchor{ctick}
@deftypefn {MGL command} {} xtick @code{val [sub=0 org=nan]}
@deftypefnx {MGL command} {} ytick @code{val [sub=0 org=nan]}
@deftypefnx {MGL command} {} ztick @code{val [sub=0 org=nan]}
@deftypefnx {MGL command} {} ctick @code{val [sub=0 org=nan]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicks (@code{char} dir, @code{float} d=@code{0}, @code{int} ns=@code{0}, @code{float} org=@code{NAN})
@deftypefnx {C function} @code{void} mgl_set_ticks_dir (@code{HMGL} gr, @code{char} dir, @code{float} d, @code{int} ns, @code{float} org)
@deftypefnx {C function} @code{void} mgl_set_ticks (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} nz)
@end ifclear
Set the ticks step @var{d}, number of sub-ticks @var{ns} and initial ticks position @var{org} for the axis along direction @var{dir} (use 'c' for colorbar ticks). Variable @var{d} set step for axis ticks (if positive) or it's number on the axis range (if negative). Zero value set automatic ticks. If @var{org} value is NAN then axis origin is used.
@end deftypefn

@deftypefn {MGL command} {} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deftypefnx {MGL command} {} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglData &}val, @code{const char *}lbl, @code{bool} add=@code{false})
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTicksVal (@code{char} dir, @code{const mglData &}val, @code{const wchar_t *}lbl, @code{bool} add=@code{false})
@deftypefnx {C function} @code{void} mgl_set_ticks_str (@code{HMGL} gr, @code{char} dir, @code{const char *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_wcs (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_val (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const char *}lbl, @code{bool} add)
@deftypefnx {C function} @code{void} mgl_set_ticks_valw (@code{HMGL} gr, @code{char} dir, @code{HCDT} val, @code{const wchar_t *}lbl, @code{bool} add)
@end ifclear
Set the manual positions @var{val} and its labels @var{lbl} for ticks along axis @var{dir}. If array @var{val} is absent then values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] are used. Labels are separated by @samp{\n} symbol. Use @code{SetTicks()} to restore automatic ticks.
@end deftypefn

@deftypefn {MGL command} {} xtick 'templ'
@deftypefnx {MGL command} {} ytick 'templ'
@deftypefnx {MGL command} {} ztick 'templ'
@deftypefnx {MGL command} {} ctick 'templ'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const char *}templ)
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickTempl (@code{char} dir, @code{const wchar_t *}templ)
@deftypefnx {C function} @code{void} mgl_set_tick_templ (@code{HMGL} gr, @code{const char *}templ)
@deftypefnx {C function} @code{void} mgl_set_tick_templw (@code{HMGL} gr, @code{const wchar_t *}templ)
@end ifclear
Set template @var{templ} for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{templ}=@code{""} then default template is used (in simplest case it is @samp{%.2g}). Setting on template switch off automatic ticks tuning.
@end deftypefn

@deftypefn {MGL command} {} ticktime 'dir' [@code{dv} 'tmpl']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickTime (@code{char} dir, @code{float} val, @code{const char *}templ)
@deftypefnx {C function} @code{void} mgl_set_tick_time (@code{HMGL} gr, @code{float} val, @code{const char *}templ)
@end ifclear
Set time labels with step @var{val} and template @var{templ} for x-,y-,z-axis ticks or colorbar ticks. It may contain TeX symbols also. The format of template @var{templ} is the same as described in @url{http://www.manpagez.com/man/3/strftime/}. Most common variants are @samp{%X} for national representation of time, @samp{%x} for national representation of date, @samp{%Y} for year with century. If @var{val}=0 and/or @var{templ}="" then automatic tick step and/or template will be selected.
@end deftypefn

@deftypefn {MGL command} {} tuneticks @code{val} [@code{pos=1.15}]
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTuneTicks (@code{bool} tune, @code{float} pos=@code{1.15})
@deftypefnx {C function} @code{void} mgl_tune_ticks (@code{HMGL} gr, @code{bool} tune, @code{float} pos)
Switch on/off ticks enhancing by factoring common multiplier (for small, like from 0.001 to 0.002, or large, like from 1000 to 2000, coordinate values) or common component (for narrow range, like from 0.999 to 1.000). Also set the position @var{pos} of common multiplier/component on the axis: =0 at minimal axis value, =1 at maximal axis value. Default value is 1.15.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} SetTickRotate (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_tick_rotate (@code{HMGL} gr, @code{bool} val)
Enable/disable ticks rotation if there are too many ticks or ticks labels are too long.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetTickSkip (@code{bool} val)
@deftypefnx {C function} @code{void} mgl_set_tick_skip (@code{HMGL} gr, @code{bool} val)
Enable/disable ticks skipping if there are too many ticks or ticks labels are too long.
@end deftypefn
@end ifclear

@anchor{ticklen}
@deftypefn {MGL command} {} ticklen @code{val} [@code{stt=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetTickLen (@code{float} val, @code{float} stt=@code{1})
@deftypefnx {C function} @code{void} mgl_set_tick_len (@code{HMGL} gr, @code{float} val, @code{float} stt)
@end ifclear
The relative length of axis ticks. Default value is @code{0.1}. Parameter @var{stt}>0 set relative length of subticks which is in @code{sqrt(1+stt)} times smaller.
@end deftypefn

@deftypefn {MGL command} {} axisstl 'stl' ['tck'='' 'sub'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetAxisStl (@code{const char *}stl=@code{"k"}, @code{const char *}tck=@code{0}, @code{const char *}sub=@code{0})
@deftypefnx {C function} @code{void} mgl_set_axis_stl (@code{HMGL} gr, @code{const char *}stl, @code{const char *}tck, @code{const char *}sub)
@end ifclear
The line style of axis, (@var{stl}) ticks (@var{tck}) and subticks (@var{sub}). If @var{stl} is empty then default style is used (@samp{k} or @samp{w} depending on transparency type). If @var{sub} or @var{sub} is empty then axis style is used (i.e. @var{stl}).
@end deftypefn

@c ##################################################################
@node Transformation matrix, Export picture, Axis settings, MathGL core
@section Transformation matrix
@cindex Aspect
@cindex Rotate
@cindex RotateN
@cindex SubPlot
@cindex MultiPlot
@cindex StickPlot
@cindex ColumnPlot
@cindex InPlot
@cindex Title
@cindex Perspective
@cindex View
@cindex Push
@cindex Pop

These functions control how and where further plotting will be placed. There is a certain calling order of these functions for the better plot appearance. First one should be @ref{subplot}, @ref{multiplot} or @ref{inplot} for specifying the place. Second one can be @ref{title} for adding title for the subplot. After it a @ref{rotate} and @ref{aspect}. And finally any other plotting functions may be called. Alternatively you can use @ref{columnplot}, @ref{gridplot}, @ref{stickplot} or relative @ref{inplot} for positioning plots in the column (or grid, or stick) one by another without gap between plot axis (bounding boxes). @sref{InPlot sample}

@anchor{subplot}
@deftypefn {MGL command} {} subplot @code{nx ny m ['stl'='<>_^' dx=0 dy=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SubPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl=@code{"<>_^"}, @code{float} dx=@code{0}, @code{float} dy=@code{0})
@deftypefnx {C function} @code{void} mgl_subplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl)
@deftypefnx {C function} @code{void} mgl_subplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{const char *}stl, @code{float} dx, @code{float} dy)
@end ifclear
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations. So it should be used first for creating the subplot. Extra space will be reserved for axis/colorbar if @var{stl} contain: @samp{L} or @samp{<} -- at left side, @samp{R} or @samp{>} -- at right side, @samp{A} or @samp{^} -- at top side, @samp{U} or @samp{_} -- at bottom side. From the aesthetical point of view it is not recommended to use this function with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deftypefn

@anchor{multiplot}
@deftypefn {MGL command} {} multiplot @code{nx ny m dx dy} ['style'='<>_^']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} MultiPlot (@code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl=@code{"<>_^"})
@deftypefnx {C function} @code{void} mgl_multiplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} m, @code{int} dx, @code{int} dy, @code{const char *}stl)
@end ifclear
Puts further plotting in a rectangle of @var{dx}*@var{dy} cells starting from @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This function set off any aspects or rotations.  So it should be used first for creating subplot. Extra space will be reserved for axis/colorbar if @var{stl} contain: @samp{L} or @samp{<} -- at left side, @samp{R} or @samp{>} -- at right side, @samp{A} or @samp{^} -- at top side, @samp{U} or @samp{_} -- at bottom side.
@end deftypefn

@anchor{inplot}
@deftypefn {MGL command} {} inplot @code{x1 x2 y1 y2 [rel=off]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} InPlot (@code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{bool} rel=@code{false})
@deftypefnx {C function} @code{void} mgl_inplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_relplot (@code{HMGL} gr, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2)
@end ifclear
Puts further plotting in some region of the whole frame surface. This function allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{true} then the relative position to current @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}) is used. This function set off any aspects or rotations. So it should be used first for creating subplot.
@end deftypefn

@anchor{columnplot}
@deftypefn {MGL command} {} columnplot @code{num ind [d=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ColumnPlot (@code{int} num, @code{int} ind, @code{float} d=@code{0})
@deftypefnx {C function} @code{void} mgl_columnplot (@code{HMGL} gr, @code{int} num, @code{int} ind)
@deftypefnx {C function} @code{void} mgl_columnplot_d (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{float} d)
@end ifclear
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}). Parameter @var{d} set extra gap between cells.
@end deftypefn

@anchor{gridplot}
@deftypefn {MGL command} {} gridplot @code{nx ny ind [d=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} GridPlot (@code{int} nx, @code{int} ny, @code{int} ind, @code{float} d=@code{0})
@deftypefnx {C function} @code{void} mgl_gridplot (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind)
@deftypefnx {C function} @code{void} mgl_gridplot_d (@code{HMGL} gr, @code{int} nx, @code{int} ny, @code{int} ind, @code{float} d)
@end ifclear
Puts further plotting in @var{ind}-th cell of @var{nx}*@var{ny} grid. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}). Parameter @var{d} set extra gap between cells. @sref{ColumnPlot sample}
@end deftypefn

@anchor{stickplot}
@deftypefn {MGL command} {} stickplot @code{num ind tet phi}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} StickPlot (@code{int} num, @code{int} ind, @code{float} tet, @code{float} phi)
@deftypefnx {C function} @code{void} mgl_stickplot (@code{HMGL} gr, @code{int} num, @code{int} ind, @code{float} tet, @code{float} phi)
@end ifclear
Puts further plotting in @var{ind}-th cell of stick with @var{num} cells. At this, stick is rotated on angles @var{tet}, @var{phi}. The position is relative to previous @ref{subplot} (or @ref{inplot} with @var{rel}=@code{false}).
@end deftypefn

@anchor{title}
@deftypefn {MGL command} {} title 'title' ['stl'='' @code{size=-2}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Title (@code{const char *}txt, @code{const char *}stl=@code{""}, @code{float} size=@code{-2})
@deftypefnx {Method on @code{mglGraph}} @code{void} Title (@code{const wchar_t *}txt, @code{const char *}stl=@code{""}, @code{float} size=@code{-2})
@deftypefnx {C function} @code{void} mgl_title (@code{HMGL} gr, @code{const char *}txt, @code{const char *}stl, @code{float} size)
@deftypefnx {C function} @code{void} mgl_titlew (@code{HMGL} gr, @code{const wchar_t *}txt, @code{const char *}stl, @code{float} size)
@end ifclear
Add text @var{title} for current subplot/inplot by font @var{stl} with specified @var{size}. If @var{stl} contains @samp{#} then bounding box around title will be drawn. This function set off any aspects or rotations. So it should be used just after creating subplot.
@end deftypefn

@anchor{rotate}
@deftypefn {MGL command} {} rotate @code{tetz tetx [tety=0]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Rotate (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
@deftypefnx {C function} @code{void} mgl_rotate (@code{HMGL} gr, @code{float} TetX, @code{float} TetZ, @code{float} TetY)
@end ifclear
Rotates a further plotting relative to each axis @{x, z, y@} consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}.
@end deftypefn

@deftypefn {MGL command} {} rotate @code{tet x y z}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} RotateN (@code{float} Tet, @code{float} x, @code{float} y, @code{float} z)
@deftypefnx {C function} @code{void} mgl_rotate_vector (@code{HMGL} gr, @code{float Tet}, @code{float x}, @code{float y}, @code{float z})
@end ifclear
Rotates a further plotting around vector @{@var{x}, @var{y}, @var{z}@} on angle @var{Tet}.
@end deftypefn

@anchor{aspect}
@deftypefn {MGL command} {} aspect @code{ax ay [az=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Aspect (@code{float} Ax, @code{float} Ay, @code{float} Az=@code{1})
@deftypefnx {C function} @code{void} mgl_aspect (@code{HMGL} gr, @code{float} Ax, @code{float} Ay, @code{float} Az)
@end ifclear
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{Ax:Ay:Az}. For the best effect it should be used after @ref{rotate} function.
@end deftypefn

@anchor{perspective}
@deftypefn {MGL command} {} perspective @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Perspective (@code{float} a)
@deftypefnx {C function} @code{void} mgl_perspective (@code{HMGL} gr, @code{float} a)
@end ifclear
Add (switch on) the perspective to plot. The parameter @math{a ~ 1/z_@{eff@} \in [0,1)}. By default (@code{a=0}) the perspective is off.
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} Push ()
@deftypefnx {C function} @code{void} mgl_mat_push (@code{HMGL} gr)
Push transformation matrix into stack. Later you can restore its current state by Pop() function. Stack can keep up to 10 matrices.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} Pop ()
@deftypefnx {C function} @code{void} mgl_mat_pop (@code{HMGL} gr)
Pop (restore last 'pushed') transformation matrix into stack.
@end deftypefn

There are 2 functions @code{View()} and @code{Zoom()} which transform whole image. I.e. they act as secondary transformation matrix. They were introduced for rotating/zooming the whole plot by mouse.

@deftypefn {Method on @code{mglGraph}} @code{void} View (@code{float} TetX, @code{float} TetZ, @code{float} TetY=@code{0})
@deftypefnx {C function} @code{void} mgl_view (@code{HMGL} gr, @code{float} TetX, @code{float} TetZ, @code{float} TetY)
Rotates a further plotting relative to each axis @{x, z, y@} consecutively on angles @var{TetX}, @var{TetZ}, @var{TetY}. Rotation is done independently on @ref{rotate}. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@deftypefn {Method on @code{mglGraph} (C++, Python)} @code{void} Zoom (@code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
@deftypefnx {C function} @code{void} mgl_set_zoom (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} x2, @code{float} y2)
The function changes the scale of graphics that correspond to zoom in/out of the picture. After function call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Attention! this settings can not be overwritten by any other functions. Use @code{Zoom(0,0,1,1)} to return default view.
@end deftypefn

@end ifclear

@c ##################################################################
@node Export picture, Primitives drawing, Transformation matrix, MathGL core
@section Export picture
@cindex SetSize

Functions in this group save or give access to produced picture. So, usually they should be called after plotting is done.

@anchor{setsize}
@deftypefn {MGL command} {} setsize @code{w h}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetSize (@code{int} width, @code{int} height)
@deftypefnx {C function} @code{void} mgl_set_size (@code{HMGL} gr, @code{int} width, @code{int} height)
@end ifclear
Sets size of picture in pixels. This function @strong{must be} called before any other plotting because it completely remove picture contents.
@end deftypefn

@anchor{quality}
@deftypefn {MGL command} {} quality @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetQuality (@code{int} val=@code{MGL_DRAW_NORM})
@deftypefnx {C function} @code{void} mgl_set_quality (@code{HMGL} gr, @code{int} val)
@end ifclear
Sets quality of the plot depending on value @var{val}: @code{MGL_DRAW_WIRE=0} --	no face drawing (fastest), @code{MGL_DRAW_FAST=1} -- no color interpolation (fast), @code{MGL_DRAW_NORM=2} -- high quality (normal). If @code{MGL_DRAW_LMEM=0x4} is set then direct bitmap drawing is used (low memory usage).
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} StartGroup (const char *name)
@deftypefnx {C function} @code{void} mgl_start_group (@code{HMGL} gr, @code{const char *}name)
Starts group definition. Groups contain objects and other groups, they are used to select a part of a model to zoom to or to make invizible or to make semitransparent and so on.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} EndGroup ()
@deftypefnx {C function} @code{void} mgl_end_group (@code{HMGL} gr)
Ends group definition.
@end deftypefn
@end ifclear


@menu
* Export to file::
* Frames/Animation::
* Bitmap in memory::
* Parallelization::
@end menu

@c ==================================================================
@node Export to file, Frames/Animation, , Export picture
@subsection Export to file
@cindex Write
@ifclear UDAV
@cindex WriteFrame
@cindex WritePNG
@cindex WriteGIF
@cindex WriteIDTF
@cindex WriteSVG
@cindex WriteBMP
@cindex WriteEPS
@cindex WriteBPS
@cindex WriteTGA
@cindex WriteTEX
@cindex WriteOBJ
@cindex WriteWGL
@cindex WriteJPEG
@cindex ShowImage
@end ifclear

These functions export current view to a graphic file. The filename @var{fname} should have appropriate extension. Parameter @var{descr} gives the short description of the picture. Just now the transparency is supported in PNG and SVG files.

@anchor{write}
@deftypefn {MGL command} {} write 'fname'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} WriteFrame (@code{const char *}fname=@code{""}, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_frame (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@end ifclear
Exports current frame to a file @var{fname} which type is determined by the extension. Parameter @var{descr} adds description to file (can be @code{""}). If @var{fname}=@code{""} then the file @samp{frame####.jpg} is used, where @samp{####} is current frame id and name @samp{frame} is defined by @var{PlotId} class property.
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} WritePNG (@code{const char *}fname, @code{const char *}descr=@code{""}, @code{int} compr=@code{""}, @code{bool} alpha=@code{true})
@deftypefnx {C function} @code{void} mgl_write_png (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
@deftypefnx {C function} @code{void} mgl_write_png_solid (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to PNG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file, @var{alpha} gives the transparency type. By default there are no description added and semitransparent image used. This function does nothing if NO_PNG is defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteJPEG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_jpg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to JPEG file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. This function does nothing if NO_JPEG is defined during compilation of MathGL library.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteGIF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_gif (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to GIF file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteBMP (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_bmp (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to BMP file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteTGA (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_tga (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to TGA file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. There is no compression used.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteEPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file using vector representation. So it is not recommended for the export of large data plot. It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. If file name is terminated by @samp{z} (for example, @samp{fname.eps.gz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteBPS (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_eps (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to EPS file using bitmap representation. Parameter @var{fname} specifies the file name, @var{descr} adds description to file. By default there is no description added. If file name is terminated by @samp{z} (for example, @samp{fname.eps.gz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteSVG (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_svg (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to SVG (Scalable Vector Graphics) file using vector representation. In difference of EPS format, SVG format support transparency that allows to correctly draw semitransparent plot (like @ref{surfa}, @ref{surf3a} or @ref{cloud}). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name). If file name is terminated by @samp{z} (for example, @samp{fname.svgz}) then file will be compressed in gzip format.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteTEX (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_tex (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to LaTeX (package Tikz/PGF) file using vector representation. Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{void} WriteOBJ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to OBJ/MTL file using vector representation (see @url{http://en.wikipedia.org/wiki/Wavefront_.obj_file, OBJ format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteXYZ (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_xyz (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to XYZ/XYZL/XYZF files using vector representation (see @url{http://people.sc.fsu.edu/~jburkardt/data/xyz/xyz.html, XYZ format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteSTL (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to STL file using vector representation (see @url{http://en.wikipedia.org/wiki/STL_(file_format), STL format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteOFF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to OFF file using vector representation (see @url{http://people.sc.fsu.edu/~jburkardt/data/off/off.html, OFF format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} WriteX3D (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_obj (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to OBJ/MTL file using vector representation (see @url{http://en.wikipedia.org/wiki/X3d, X3D format} for details). Note, the output file may be too large for graphic of large data array (especially for surfaces). It is better to use bitmap format (for example PNG or JPEG). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{void} WriteIDTF (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_write_idtf (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports current frame to IDTF file. Later this file can be converted to U3D format. The vector representation is used. So, the output file may be too large for graphic of large data array (especially for surfaces). However, program has no internal limitations for size of output file. Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ShowImage (@code{const char *}viewer, @code{bool} nowait=@code{false})
@deftypefnx {C function} @code{void} mgl_show_image (@code{const char *}viewer, @code{int} nowait)
Displays the current picture using external program @var{viewer} for viewing. The function save the picture to temporary file and call @var{viewer} to display it. If @var{nowait}=@code{true} then the function return immediately (it will not wait while window will be closed).
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{void} ExportMGLD (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_export_mgld (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Exports points and primitives in file using MGLD format. Later this file can be used for faster loading and viewing by @code{mglview} utility (see @ref{Utilities}). Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ImportMGLD (@code{const char *}fname, @code{const char *}descr=@code{""})
@deftypefnx {C function} @code{void} mgl_import_mgld (@code{HMGL} gr, @code{const char *}fname, @code{const char *}descr)
Imports points and primitives in file using MGLD format. Later this file can be used for faster loading and viewing by @code{mglview} utility (see @ref{Utilities}). Parameter @var{fname} specifies the file name, @var{descr} adds description to file (default is file name).
@end deftypefn

@end ifclear


@c ##################################################################
@node Frames/Animation, Bitmap in memory, Export to file, Export picture
@subsection Frames/Animation

@ifset UDAV
There are no commands for making animation in MGL. However you can use features of utilities (see @ref{Utilities}). For example, by busing special comments @samp{##a } or @samp{##c }.
@end ifset

@ifclear UDAV
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame
@cindex ResetFrames
@cindex StartGIF
@cindex CloseGIF

These functions provide ability to create several pictures simultaneously. For most of cases it is useless but for widget classes (see @ref{Widget classes}) they can provide a way to show animation. Also you can write several frames into animated GIF file.

@deftypefn {Method on @code{mglGraph}} @code{int} NewFrame ()
@deftypefnx {C function} @code{int} mgl_new_frame (@code{HMGL} gr)
Creates new frame. Function returns current frame id. This is not thread safe function in OpenGL mode! Use direct list creation in multi-threading drawing. The function @code{EndFrame()} @strong{must} be call after the finishing of the frame drawing for each call of this function.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} EndFrame ()
@deftypefnx {C function} @code{void} mgl_end_frame (@code{HMGL} gr)
Finishes the frame drawing.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetNumFrame ()
@deftypefnx {C function} @code{int} mgl_get_num_frame (@code{HMGL} gr)
Gets the number of created frames.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} ResetFrames ()
@deftypefnx {C function} @code{int} mgl_reset_frames (@code{HMGL} gr)
Reset frames counter (start it from zero).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} StartGIF (@code{const char *}fname, @code{int} ms=@code{100})
@deftypefnx {C function} @code{void} mgl_start_gif (@code{HMGL} gr, @code{const char *}fname, @code{int} ms)
Start writing frames into animated GIF file @var{fname}. Parameter @var{ms} set the delay between frames in milliseconds. You @strong{should not} change the picture size during writing the cinema. Use @code{CloseGIF()} to finalize writing. Note, that this function is disabled in OpenGL mode.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} CloseGIF ()
@deftypefnx {C function} @code{void} mgl_close_gif (@code{HMGL} gr)
Finish writing animated GIF and close connected pointers.
@end deftypefn
@end ifclear

@c ------------------------------------------------------------------
@node Bitmap in memory, Parallelization, Frames/Animation, Export picture
@subsection Bitmap in memory

@ifclear UDAV
These functions return the created picture (bitmap), its width and height. You may display it by yourself in any graphical library (see also, @ref{Widget classes}) or save in file (see also, @ref{Export to file}).

@deftypefn {Method on @code{mglGraph}} @code{const unsigned char *} GetRGB ()
@deftypefnx {Method on @code{mglGraph}} @code{void} GetRGB (@code{char *}buf, @code{int} size)
@deftypefnx {Method on @code{mglGraph}} @code{void} GetBGRN (@code{char *}buf, @code{int} size)
@deftypefnx {C function} @code{const unsigned char *} mgl_get_rgb (@code{HMGL} gr)
Gets RGB bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue@}. Number of elements is Width*Height. Position of element @{i,j@} is [3*i + 3*Width*j] (or is [4*i + 4*Width*j] for @code{GetBGRN()}). You have to provide the proper @var{size} of the buffer, @var{buf}, i.e. the code for Python should look like
@verbatim
from mathgl import *
gr = mglGraph();
bits='\t';
bits=bits.expandtabs(4*gr.GetWidth()*gr.GetHeight());
gr.GetBGRN(bits, len(bits));
@end verbatim
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{const unsigned char *} GetRGBA ()
@deftypefnx {Method on @code{mglGraph}} @code{void} GetRGBA (@code{char *}buf, @code{int} size)
@deftypefnx {C function} @code{const unsigned char *} mgl_get_rgba (@code{HMGL} gr)
Gets RGBA bitmap of the current state of the image. Format of each element of bits is: @{red, green, blue, alpha@}. Number of elements is Width*Height. Position of element @{i,j@} is [4*i + 4*Width*j].
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetWidth ()
@deftypefnx {Method on @code{mglGraph}} @code{int} GetHeight ()
@deftypefnx {C function} @code{int} mgl_get_width (@code{HMGL} gr)
@deftypefnx {C function} @code{int} mgl_get_height (@code{HMGL} gr)
Gets width and height of the image.
@end deftypefn


@deftypefn {Method on @code{mglGraph}} @code{mglPoint} CalcXYZ (@code{int} xs, @code{int} ys)
@deftypefnx {C function} @code{void} mgl_calc_xyz (@code{HMGL} gr, @code{int} xs, @code{int} ys, @code{float *}x, @code{float *}y, @code{float *}z)
Calculate 3D coordinate @{x,y,z@} for screen point @{xs,ys@}. At this moment it ignore perspective and transformation formulas (curvilinear coordinates). The calculation are done for the last used InPlot (see @ref{Transformation matrix}).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{mglPoint} CalcScr (@code{mglPoint} p)
@deftypefnx {C function} @code{void} mgl_calc_scr (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{int *}xs, @code{int *}ys)
Calculate screen point @{xs,ys@} for 3D coordinate @{x,y,z@}. The calculation are done for the last used InPlot (see @ref{Transformation matrix}).
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} SetObjId (@code{int} id)
@deftypefnx {C function} @code{void} mgl_set_obj_id (@code{HMGL} gr, @code{int} id)
Set the numeric id for object or subplot/inplot.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetObjId (@code{long} xs, @code{long} ys)
@deftypefnx {C function} @code{int} mgl_get_obj_id (@code{HMGL} gr, @code{long} xs, @code{long} ys)
Get the numeric id for most upper object at pixel @{xs, ys@} of the picture.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} GetSplId (@code{long} xs, @code{long} ys)
@deftypefnx {C function} @code{int} mgl_get_spl_id (@code{HMGL} gr, @code{long} xs, @code{long} ys)
Get the numeric id for most subplot/inplot at pixel @{xs, ys@} of the picture.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} Highlight (@code{int} id)
@deftypefnx {C function} @code{void} mgl_highlight (@code{HMGL} gr, @code{int} id)
Highlight the object with given @var{id}.
@end deftypefn

@end ifclear


@c ------------------------------------------------------------------
@node Parallelization, , Bitmap in memory, Export picture
@subsection Parallelization

@ifclear UDAV
@cindex Combine
@cindex MPI_Send
@cindex MPI_Recv

Many of things MathGL do in parallel by default (if MathGL was built with pthread). However, there is function which set the number of threads to be used.

@deftypefn {C function} @code{int} mgl_set_num_thr (@code{int} n)
Set the number of threads to be used by MathGL. If @var{n}<1 then the number of threads is set as maximal number of processors (cores). If @var{n}=1 then single thread will be used (this is default if pthread was disabled).
@end deftypefn

Another option is combining bitmap image (taking into account Z-ordering) from different instances. This method is most appropriate for computer clusters when the data size is so large that it exceed the memory of single computer node.

@deftypefn {Method on @code{mglGraph}} @code{int} Combine (@code{const mglGraph *}g)
@deftypefnx {C function} @code{int} mgl_combine_gr (@code{HMGL} gr, @code{HMGL} g)
Combine drawing from instance @var{g} with @var{gr} (or with this) taking into account Z-ordering of pixels. The width and height of both instances must be the same.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} MPI_Send (@code{int} id)
@deftypefnx {C function} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Send graphical information from node @var{id} using MPI. The width and height in both nodes must be the same.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{int} MPI_Recv (@code{int} id)
@deftypefnx {C function} @code{int} mgl_mpi_send (@code{HMGL} gr, @code{int} id)
Receive graphical information from node @var{id} using MPI. The width and height in both nodes must be the same.
@end deftypefn
@end ifclear



@c ##################################################################
@node Primitives drawing, Text printing, Export picture, MathGL core
@section Primitives drawing
@cindex Ball
@cindex Clf
@cindex Line
@cindex Curve
@cindex Glyph
@cindex Face
@cindex FaceX
@cindex FaceY
@cindex FaceZ
@cindex Cone
@cindex Drop
@cindex Sphere

@ifclear UDAV
@cindex Mark
@cindex Error
@end ifclear


These functions draw some simple objects like line, point, sphere, drop, cone and so on. @sref{Primitives sample}

@anchor{clf}
@deftypefn {MGL command} {} clf
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf ()
@deftypefnx {Method on @code{mglGraph}} @code{void} Clf (@code{float} r, @code{float} g, @code{float} b)
@deftypefnx {C function} @code{void} mgl_clf (@code{HMGL} gr)
@deftypefnx {C function} @code{void} mgl_clf_rgb (@code{HMGL} gr, @code{float} r, @code{float} g, @code{float} b)
@end ifclear
Clear the picture and fill it by color specified color.
@end deftypefn

@anchor{ball}
@deftypefn {MGL command} {} ball @code{x y} ['col'='r.']
@deftypefnx {MGL command} {} ball @code{x y z} ['col'='r.']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ball (@code{mglPoint} p, @code{char} col=@code{'r'})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{mglPoint} p, @code{const char *}mark)
@deftypefnx {C function} @code{void} mgl_mark (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}mark)
@end ifclear
Draws a mark (point @samp{.} by default) at position @var{p}=@{@var{x}, @var{y}, @var{z}@} with color @var{col}.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} Error (@code{mglPoint} p, @code{mglPoint} e, @code{char} *stl=@code{""})
@deftypefnx {C function} @code{void} mgl_error_box (@code{HMGL} gr, @code{float} px, @code{float} py, @code{float} pz, @code{float} ex, @code{float} ey, @code{float} ez, @code{char *}stl)
Draws a 3d error box at position @var{p} with sizes @var{e} and style @var{stl}. Use NAN for component of @var{e} to reduce number of drawn elements.
@end deftypefn
@end ifclear

@anchor{line}
@deftypefn {MGL command} {} line @code{x1 y1 x2 y2} ['stl'='']
@deftypefnx {MGL command} {} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Line (@code{mglPoint} p1, @code{mglPoint} p2, @code{char *}stl=@code{"B"}, @code{int} num=@code{2})
@deftypefnx {C function} @code{void} mgl_line (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{char *}stl, @code{int} num)
@end ifclear
Draws a geodesic line (straight line in Cartesian coordinates) from point @var{p1} to @var{p2} using line style @var{stl}. Parameter @var{num} define the ``quality'' of the line. If @var{num}=@code{2} then the stright line will be drawn in all coordinate system (independently on transformation formulas (see @ref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the geodesic line will be drawn in corresponding coordinate system (straight line in Cartesian coordinates, circle in polar coordinates and so on). Line will be drawn even if it lies out of bounding box.
@end deftypefn

@anchor{curve}
@deftypefn {MGL command} {} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deftypefnx {MGL command} {} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Curve (@code{mglPoint} p1, @code{mglPoint} d1, @code{mglPoint} p2, @code{mglPoint} d2, @code{const char *}stl=@code{"B"}, @code{int} num=@code{100})
@deftypefnx {C function} @code{void} mgl_curve (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} dx1, @code{float} dy1, @code{float} dz1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} dx2, @code{float} dy2, @code{float} dz2, @code{const char *}stl, @code{int} num)
@end ifclear
Draws Bezier-like curve from point @var{p1} to @var{p2} using line style @var{stl}. At this tangent is codirected with @var{d1}, @var{d2} and proportional to its amplitude. Parameter @var{num} define the ``quality'' of the curve. If @var{num}=@code{2} then the straight line will be drawn in all coordinate system (independently on transformation formulas, see @ref{Curved coordinates}). Contrary, for large values (for example, =@code{100}) the spline like Bezier curve will be drawn in corresponding coordinate system. Curve will be drawn even if it lies out of bounding box.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} Face (@code{mglPoint} p1, @code{mglPoint} p2, @code{mglPoint} p3, @code{mglPoint} p4, @code{const char *}stl=@code{"w"})
@deftypefnx {C function} @code{void} mgl_face (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} x3, @code{float} y3, @code{float} z3, @code{float} x4, @code{float} y4, @code{float} z4, @code{const char *}stl)
Draws the solid quadrangle (face) with vertexes @var{p1}, @var{p2}, @var{p3}, @var{p4} and with color(s) @var{stl}. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Face will be drawn even if it lies out of bounding box.
@end deftypefn
@end ifclear

@anchor{facex}
@anchor{facey}
@anchor{facez}
@deftypefn {MGL command} {} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {MGL command} {} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {MGL command} {} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceX (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} d1=@code{0}, @code{float} d2=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceY (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl=@code{"w"}, @code{float} d1=@code{0}, @code{float} d2=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} FaceZ (@code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl=@code{"w"}, @code{float} d1=@code{0}, @code{float} d2=@code{0})
@deftypefnx {C function} @code{void} mgl_facex (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wy, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facey (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wz, @code{const char *}stl, @code{float} d1, @code{float} d2)
@deftypefnx {C function} @code{void} mgl_facez (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} wx, @code{float} wy, @code{const char *}stl, @code{float} d1, @code{float} d2)
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or separately if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deftypefn

@anchor{sphere}
@deftypefn {MGL command} {} sphere @code{x0 y0 r} ['col'='r']
@deftypefnx {MGL command} {} sphere @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Sphere (@code{mglPoint} p, @code{float} r, @code{const char *}stl=@code{"r"})
@deftypefnx {C function} @code{void} mgl_sphere (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} r, @code{const char *}stl)
@end ifclear
Draw the sphere with radius @var{r} and center at point @var{p}=@{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deftypefn

@anchor{drop}
@deftypefn {MGL command} {} drop @code{x0 y0 dx dy r} ['col'='r' @code{sh=1 asp=1}]
@deftypefnx {MGL command} {} drop @code{x0 y0 z0 dx dy dz r} ['col'='r' @code{sh=1 asp=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Drop (@code{mglPoint} p, @code{mglPoint} d, @code{float} r, @code{const char *}stl=@code{"r"}, @code{float} shift=@code{1}, @code{float} ap=@code{1})
@deftypefnx {C function} @code{void} mgl_drop (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} dx, @code{float} dy, @code{float} dz, @code{float} r, @code{const char *}col, @code{float} shift, @code{float} ap)
@end ifclear
Draw the drop with radius @var{r} at point @var{p} elongated in direction @var{d} and with color @var{col}. Parameter @var{shift} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{ap} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deftypefn

@anchor{cone}
@deftypefn {MGL command} {} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='' @code{edge=off}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cone (@code{mglPoint} p1, @code{mglPoint} p2, @code{float} r1, @code{float} r2=@code{-1}, @code{const char *}stl=@code{"B"}, @code{bool} edge=@code{false})
@deftypefnx {C function} @code{void} mgl_cone (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r1, @code{float} r2, @code{const char *}stl, @code{int} draw_edge)
@end ifclear
Draw tube (or truncated cone if @var{edge}=@code{false}) between points @var{p1}, @var{p2} with radius at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is supposed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deftypefn

@anchor{circle}
@deftypefn {MGL command} {} circle @code{x0 y0 r} ['col'='r']
@deftypefnx {MGL command} {} circle @code{x0 y0 z0 r} ['col'='r']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Circle (@code{mglPoint} p, @code{float} r, @code{const char *}stl=@code{"r"})
@end ifclear
Draw the circle with radius @var{r} and center at point @var{p}=@{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}. If @var{col} contain: @samp{#} then wire figure is drawn, @samp{@@} then boundary is drawn (by second color of @var{col} or by black).
@end deftypefn

@anchor{ellipse}
@deftypefn {MGL command} {} ellipse @code{x1 y1 x2 y2 r} ['col'='r' @code{sh=1 asp=1}]
@deftypefnx {MGL command} {} ellipse @code{x1 y1 z1 x2 y2 z2 r} ['col'='r' @code{sh=1 asp=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Ellipse (@code{mglPoint} p1, @code{mglPoint} p2, @code{float} r, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_ellipse (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r, @code{const char *}col)
@end ifclear
Draw the ellipse with radius @var{r} and focal points @var{p1}, @var{p2} by color @var{col}. If @var{col} contain: @samp{#} then wire figure is drawn, @samp{@@} then boundary is drawn (by second color of @var{col} or by black).
@end deftypefn

@anchor{rhomb}
@deftypefn {MGL command} {} rhomb @code{x1 y1 x2 y2 r} ['col'='r' @code{sh=1 asp=1}]
@deftypefnx {MGL command} {} rhomb @code{x1 y1 z1 x2 y2 z2 r} ['col'='r' @code{sh=1 asp=1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Rhomb (@code{mglPoint} p1, @code{mglPoint} p2, @code{float} r, @code{const char *}col=@code{"r"})
@deftypefnx {C function} @code{void} mgl_rhomb (@code{HMGL} gr, @code{float} x1, @code{float} y1, @code{float} z1, @code{float} x2, @code{float} y2, @code{float} z2, @code{float} r, @code{const char *}col)
@end ifclear
Draw the rhombus with width @var{r} and edge points @var{p1}, @var{p2} by color @var{col}.  If @var{col} contain: @samp{#} then wire figure is drawn, @samp{@@} then boundary is drawn (by second color of @var{col} or by black). If @var{col} contain 3 colors then gradient filling is used.
@end deftypefn

@c ##################################################################
@node Text printing, Axis and Colorbar, Primitives drawing, MathGL core
@section Text printing
@ifclear UDAV
@cindex Puts
@cindex Putsw
@end ifclear
@cindex Text
@cindex Label
@cindex fgets

These functions draw the text. There are functions for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. MathGL can use arbitrary font-faces and parse many TeX commands (for more details see @ref{Font styles}). All these functions have 2 variant: for printing 8-bit text (@code{char *}) and for printing Unicode text (@code{wchar_t *}). In first case the conversion in current locale is used. So sometimes you need to specify it by @code{setlocale()} function. The size argument control the size of text: if positive it give the value, if negative it give the value relative to @var{FontSize}. The font type (STIX, arial, courier, times and so on) can be selected by function LoadFont(). @xref{Font settings}.

The font parameters are described by string. This string may set the text color @samp{wkrgbcymhRGBCYMHW} (see @ref{Color styles}). Also,  after delimiter symbol @samp{:}, it can contain characters of font type (@samp{rbiwou}) and/or align (@samp{LRC}) specification. The font types are: @samp{r} -- roman (or regular) font, @samp{i} -- italic style, @samp{b} -- bold style, @samp{w} -- wired style, @samp{o} -- over-lined text, @samp{u} -- underlined text. By default roman font is used. The align types are: @samp{L} -- align left (default), @samp{C} -- align center, @samp{R} -- align right. For example, string @samp{b:iC} correspond to italic font style for centered text which printed by blue color.

If string contains symbols @samp{aA} then text is printed at arbitrary position @{@var{x}, @var{y}@} (supposed to be in range [0,1]) of subplot (for @samp{a}) or picture (for @samp{A}). If string contains symbol @samp{@@} then box around text is drawn.

@sref{Text sample}

@anchor{text}
@deftypefn {MGL command} {} text @code{x y} 'text' ['fnt'='' @code{size=-1}]
@deftypefnx {MGL command} {} text @code{x y z} 'text' ['fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{const char *}text, @code{const char *}fnt=@code{":C"}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{const wchar_t *}text, @code{const char *}fnt=@code{":C"}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{float} x, @code{float} y, @code{const char *}text, @code{const char *}fnt=@code{":AC"}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{float} x, @code{float} y, @code{const wchar_t *}text, @code{const char *}fnt=@code{":AC"}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}text, @code{const char *}fnt, @code{float} size)
@deftypefnx {C function} @code{void} mgl_putsw (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{float} size)
@end ifclear
The function plots the string @var{text} at position @var{p} with fonts specifying by the criteria @var{fnt}. The size of font is set by @var{size} parameter (default is @var{FontSize}).
@end deftypefn

@deftypefn {MGL command} {} text @code{x y dx dy} 'text' ['fnt'=':L' @code{size=-1}]
@deftypefnx {MGL command} {} text @code{x y z dx dy dz} 'text' ['fnt'=':L' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Puts (@code{mglPoint} p, @code{mglPoint} d, @code{const char *}text, @code{const char *}fnt=@code{":L"}, @code{float} size=@code{-1})
@deftypefnx {Method on @code{mglGraph}} @code{void} Putsw (@code{mglPoint} p, @code{mglPoint} d, @code{const wchar_t *}text, @code{const char *}fnt=@code{":L"}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const char *}text, @code{const char *}fnt, @code{float} size)
@deftypefnx {C function} @code{void} mgl_putsw_dir (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{float} dx, @code{float} dy, @code{float} dz, @code{const wchar_t *}text, @code{const char *}fnt, @code{float} size)
@end ifclear
The function plots the string @var{text} at position @var{p} along direction @var{d} with specified @var{size}. Parameter @var{fnt} set text style and text position: above (@samp{T}) or under (@samp{t}) the line.
@end deftypefn

@anchor{fgets}
@deftypefn {MGL command} {} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deftypefnx {MGL command} {} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Draws unrotated @var{n}-th line of file @var{fname} at position @{@var{x},@var{y},@var{z}@} with specified @var{size}. By default parameters from @ref{font} command are used.
@end deftypefn

@anchor{label}
@deftypefn {MGL command} {} label @code{x y} 'text' ['fnt'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{float} x, @code{float} y, @code{const char *}text, @code{const char *}fnt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Labelw (@code{float} x, @code{float} y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""})
@deftypefnx {C function} @code{void} mgl_label_pos (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const char *}text, @code{const char *}fnt)
@deftypefnx {C function} @code{void} mgl_labelw_pos (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const wchar_t *}text, @code{const char *}fnt)
@end ifclear
The function draws the string @var{text} at position @{@var{x}, @var{y}@} with fonts specifying by @var{fnt}. Coordinates @code{x, y} are supposed to be in range [0,1].
@end deftypefn


@deftypefn {MGL command} {} text ydat 'text' ['fnt'='']
@deftypefnx {MGL command} {} text xdat ydat 'text' ['fnt'='']
@deftypefnx {MGL command} {} text xdat ydat zdat 'text' ['fnt'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Text (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const wchar_t *}text, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_text_y (@code{HMGL} gr, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_y (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_text_xy (@code{HCDT} x, @code{HCDT} y, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_xy (@code{HCDT} x, @code{HCDT} y, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_text_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}text, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textw_xyz (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const wchar_t *}text, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
The function draws @var{text} along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} by font style @var{fnt}. The string @var{fnt} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @code{x.nx=y.nx=z.nx}. If array @var{x} is not specified then its an automatic array is used with values equidistantly distributed in interval [@var{Min}.x, @var{Max}.x] (see @ref{Ranges (bounding box)}). If array @var{z} is not specified then @var{z}[i] = @var{Min}.z is used. String @var{opt} contain command options (see @ref{Command options}). 
@end deftypefn

@c ##################################################################
@node Axis and Colorbar, Legend, Text printing, MathGL core
@section Axis and Colorbar
@cindex Axis
@cindex Box
@cindex Grid
@cindex Colorbar
@cindex Label

These functions draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information see @ref{Axis settings}.

@anchor{axis}
@deftypefn {MGL command} {} axis ['dir'='xyz' 'stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axis (@code{const char *}dir=@code{"xyz"}, @code{const char *}stl=@code{""})
@deftypefnx {C function} @code{void} mgl_axis (@code{HMGL} gr, @code{const char *}dir, @code{const char *}stl)
@end ifclear
Draws axes with ticks (see @ref{Axis settings}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by @var{FontDef} (see @ref{Font settings}). Ticks will be adjusted if @var{stl} contain @samp{a} (by call of @code{AdjustTicks()}). You can specified an arrow at the end of axis (see see @ref{Line styles}). Styles of ticks and axis can be overrided by using @var{stl} string.
@end deftypefn

@anchor{colorbar}
@deftypefn {MGL command} {} colorbar ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_colorbar (@code{HMGL} gr, @code{const char *}sch)
@end ifclear
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=""}) at edge of plot. If string @var{sch} contains @samp{<>^_} then the colorbar is placed at left, at right, at top or at bottom correspondingly. If string have @samp{I} then colorbar will be located near bounding box otherwise at the edge of the subplot. If string have @samp{A} then absolute (relative to picture) coordinates is used. @sref{Dens sample}
@end deftypefn

@deftypefn {MGL command} {} colorbar vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const mglData &}v, @code{const char *}sch=@code{""})
@deftypefnx {C function} @code{void} mgl_colorbar_val (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch)
@end ifclear
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{ContD sample}
@end deftypefn

@deftypefn {MGL command} {} colorbar 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const char *}sch, @code{float} x, @code{float} y, @code{float} w=@code{1}, @code{float} h=@code{1})
@deftypefnx {C function} @code{void} mgl_colorbar_ext (@code{HMGL} gr, @code{const char *}sch, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@end ifclear
The same as first one but at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deftypefn

@deftypefn {MGL command} {} colorbar vdat 'sch' @code{x y [w=1 h=1]}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Colorbar (@code{const mglData &}v, @code{const char *}sch, @code{float} x, @code{float} y, @code{float} w=@code{1}, @code{float} h=@code{1})
@deftypefnx {C function} @code{void} mgl_colorbar_val_ext (@code{HMGL} gr, @code{HCDT} v, @code{const char *}sch, @code{float} x, @code{float} y, @code{float} w, @code{float} h)
@end ifclear
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{ContD sample}
@end deftypefn

@anchor{grid}
@deftypefn {MGL command} {} grid ['dir'='xyz' 'pen'='B']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const char *}dir=@code{"xyz"}, @code{const char *}pen=@code{"B"})
@deftypefnx {C function} @code{void} mgl_axis_grid (@code{HMGL} gr, @code{const char *}dir, @code{const char *}pen)
@end ifclear
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for @ref{axis}. The style of lines is determined by @var{pen} parameter (default value is dark blue solid line @samp{B-}).
@end deftypefn

@anchor{box}
@deftypefn {MGL command} {} box ['stl'='k' @code{ticks=on}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Box (@code{const char *}col=@code{""}, @code{bool} ticks=@code{true})
@deftypefnx {C function} @code{void} mgl_box (@code{HMGL} gr, @code{int} ticks)
@deftypefnx {C function} @code{void} mgl_box_str (@code{HMGL} gr, @code{const char *}col, @code{int} ticks)
@end ifclear
Draws bounding box outside the plotting volume with color @var{col}. If @var{col} contain @samp{@@} then filled faces are drawn. At this first color is used for faces (default is light yellow), last one for edges. @sref{Box sample}
@end deftypefn

@anchor{xlabel}
@anchor{ylabel}
@anchor{zlabel}
@anchor{tlabel}
@deftypefn {MGL command} {} xlabel 'text' [@code{pos=1 shift=0}]
@deftypefnx {MGL command} {} ylabel 'text' [@code{pos=1 shift=0}]
@deftypefnx {MGL command} {} zlabel 'text' [@code{pos=1 shift=0}]
@deftypefnx {MGL command} {} tlabel 'text' [@code{pos=1 shift=0}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const char *}text, @code{float} pos=@code{1}, @code{float} shift=@code{0})
@deftypefnx {Method on @code{mglGraph}} @code{void} Label (@code{char} dir, @code{const wchar_t *}text, @code{float} pos=@code{1}, @code{float} shift=@code{0})
@deftypefnx {C function} @code{void} mgl_label (@code{HMGL} gr, @code{char} dir, @code{const char *}text)
@deftypefnx {C function} @code{void} mgl_label_ext (@code{HMGL} gr, @code{char} dir, @code{const char *}text, @code{float} pos, @code{float} shift)
@deftypefnx {C function} @code{void} mgl_labelw_ext (@code{HMGL} gr, @code{char} dir, @code{const wchar_t *}text, @code{float} pos, @code{float} shift)
@end ifclear
Prints the label @var{text} for axis @var{dir}=@samp{x},@samp{y},@samp{z},@samp{t} (here @samp{t} is ``ternary'' axis @math{t=1-x-y}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis. If @var{pos}<0 then label is printed at the minimum of axis. @xref{Text printing}.
@end deftypefn

@c ##################################################################
@node Legend, 1D plotting, Axis and Colorbar, MathGL core
@section Legend
@cindex Legend
@cindex AddLegend
@cindex ClearLegend
@cindex SetLegendBox
@cindex SetLegendMarks

These functions draw legend to the graph (useful for @ref{1D plotting}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included TeX parsing). The arrays of strings may be used directly or by accumulating first to the internal arrays (by function @ref{addlegend}) and further plotting it. The position of the legend can be selected automatic or manually. Parameters @var{fnt} and @var{size} specify the font style and size (see @ref{Font settings}). Parameter @var{llen} set the relative width of the line sample and the text indent. If line style string for entry is empty then the corresponding text is printed without indent. If string @var{fnt} contains symbol @samp{A} then legend coordinates set position in the picture (not in the current subplot). If string @var{fnt} contains symbol @samp{#} then box around legend is drawn. @sref{Legend sample}

@anchor{legend}
@deftypefn {MGL command} {} legend [@code{pos=3} 'fnt'='#' @code{size=-0.8 llen=0.1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Legend (@code{int} pos=@code{0x3}, @code{const char *}fnt=@code{"#"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
@deftypefnx {C function} @code{void} mgl_legend (@code{HMGL} gr, @code{int} pos, @code{const char *}fnt, @code{float} size, @code{float} llen)
@end ifclear
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Parameter @var{pos} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default). Paramater font can contain colors for face (1st one), for border (2nd one) and for text (last one). If less than 3 colors are specified then the color for border is black (for 2 and less colors), and the color for face is white (for 1 or none colors). If string @var{fnt} contain @samp{#} then border around the legend is drawn.
@end deftypefn

@deftypefn {MGL command} {} legend @code{x y} ['fnt'='#' @code{size=-1 llen=0.1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Legend (@code{float} x, @code{float} y, @code{const char *}fnt=@code{"#"}, @code{float} size=@code{-0.8}, @code{float} llen=@code{0.1})
@deftypefnx {C function} @code{void} mgl_legend_pos (@code{HMGL} gr, @code{float} x, @code{float} y, @code{const char *}fnt, @code{float} size, @code{float} llen)
@end ifclear
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deftypefn

@anchor{addlegend}
@deftypefn {MGL command} {} addlegend 'text' 'stl'
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLegend (@code{const char *}text, @code{const char *}style)
@deftypefnx {Method on @code{mglGraph}} @code{void} AddLegend (@code{const wchar_t *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legend (@code{HMGL} gr, @code{const char *}text, @code{const char *}style)
@deftypefnx {C function} @code{void} mgl_add_legendw (@code{HMGL} gr, @code{const wchar_t *}text, @code{const char *}style)
@end ifclear
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{style} (see @ref{Line styles}).
@end deftypefn

@anchor{clearlegend}
@deftypefn {MGL command} {} clearlegend
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ClearLegend ()
@deftypefnx {C function} @code{void} mgl_clear_legend (@code{HMGL} gr)
@end ifclear
Clears saved legend strings.
@end deftypefn

@anchor{legendmarks}
@deftypefn {MGL command} {} legendmarks @code{val}
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SetLegendMarks (@code{int} num)
@deftypefnx {C function} @code{void} mgl_set_legend_marks (@code{HMGL} gr, @code{int} num)
@end ifclear
Set the number of marks in the legend. By default 1 mark is used.
@end deftypefn

@c ##################################################################
@node 1D plotting, 2D plotting, Legend, MathGL core
@section 1D plotting
@cindex Plot
@cindex Radar
@cindex Tens
@cindex Area
@cindex Region
@cindex Stem
@cindex Bars
@cindex Barh
@cindex Chart
@cindex Step
@cindex Torus
@cindex Tube
@cindex Mark
@cindex TextMark
@cindex Error
@cindex BoxPlot
@cindex Candle

These functions perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x[i],y[i],z[i]@}, i=1...n. By default (if absent) values of @var{x}[i] are equidistantly distributed in axis range, and @var{z}[i]=@var{Min}.z. The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @code{x.nx=y.nx=z.nx}.

String @var{pen} specifies the color and style of line and marks (see @ref{Line styles}). By default (@code{pen=""}) solid line with color from palette is used (see @ref{Palette and colors}). String @var{opt} contain command options (see @ref{Command options}). @sref{1D plot sample}

@anchor{plot}
@deftypefn {MGL command} {} plot ydat ['stl'='']
@deftypefnx {MGL command} {} plot xdat ydat ['stl'='']
@deftypefnx {MGL command} {} plot xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Plot (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_plot (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_plot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_plot_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. See also @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}. @sref{Plot sample}
@end deftypefn

@anchor{radar}
@deftypefn {MGL command} {} radar adat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Radar (@code{const mglData &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_radar (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
This functions draws radar chart which is continuous lines between points located on an radial lines (like plot in Polar coordinates). Parameter @var{value} in options @var{opt} set the additional shift of data (i.e. the data @var{a}+@var{value} is used instead of @var{a}). If @code{value<0} then @code{r=max(0, -min(value)}. If @var{pen} containt @samp{#} symbol then "grid" (radial lines and circle for @var{r}) is drawn See also @ref{plot}. @sref{Radar sample}
@end deftypefn

@anchor{step}
@deftypefn {MGL command} {} step ydat ['stl'='']
@deftypefnx {MGL command} {} step xdat ydat ['stl'='']
@deftypefnx {MGL command} {} step xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Step (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_step (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_step_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_step_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous stairs for points to axis plane. See also @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}. @sref{Step sample}
@end deftypefn

@anchor{tens}
@deftypefn {MGL command} {} tens ydat cdat ['stl'='']
@deftypefnx {MGL command} {} tens xdat ydat cdat ['stl'='']
@deftypefnx {MGL command} {} tens xdat ydat zdat cdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tens (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tens_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points @{@var{x}[i], @var{y}[i], @var{z}[i]@} with color defined by the special array @var{c}[i] (look like tension plot). String @var{pen} specifies the color scheme (see @ref{Color scheme}) and style and/or width of line (see @ref{Line styles}). By default (@code{pen=""}) solid line with current color scheme is used. See also @ref{plot}, @ref{mesh}, @ref{fall}. @sref{Tens sample}
@end deftypefn

@anchor{area}
@deftypefn {MGL command} {} area ydat ['stl'='']
@deftypefnx {MGL command} {} area xdat ydat ['stl'='']
@deftypefnx {MGL command} {} area xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Area (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_area (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_area_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_area_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw continuous lines between points and fills it to axis plane. Also you can use gradient filling if number of specified colors is equal to 2*number of curves. See also @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{Area sample}
@end deftypefn

@anchor{region}
@deftypefn {MGL command} {} region ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} region xdat ydat1 ydat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Region (@code{const mglData &}x, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_region (@code{HMGL} gr, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_region_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions fill area between 2 curves. Dimensions of arrays @var{y1} and @var{y2} must be equal. Also you can use gradient filling if number of specified colors is equal to 2*number of curves. If @var{pen} contain symbol @samp{i} then only area with y1<y<y2 will be filled else the area with y2<y<y1 will be filled too. See also @ref{area}, @ref{bars}, @ref{stem}. @sref{Region sample}
@end deftypefn

@anchor{stem}
@deftypefn {MGL command} {} stem ydat ['stl'='']
@deftypefnx {MGL command} {} stem xdat ydat ['stl'='']
@deftypefnx {MGL command} {} stem xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Stem (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_stem (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stem_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stem_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw vertical lines from points to axis plane. See also @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{Stem sample}
@end deftypefn

@anchor{bars}
@deftypefn {MGL command} {} bars ydat ['stl'='']
@deftypefnx {MGL command} {} bars xdat ydat ['stl'='']
@deftypefnx {MGL command} {} bars xdat ydat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Bars (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_bars (@code{HMGL} gr, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_bars_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_bars_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw vertical bars from points to axis plane. If string contain symbol @samp{a} then lines are drawn one above another (like summation). If string contain symbol @samp{f} then waterfall chart is drawn for determining the cumulative effect of sequentially introduced positive or negative values. You can give different colors for positive and negative values if number of specified colors is equal to 2*number of curves. See also @ref{barh}, @ref{area}, @ref{stem}, @ref{chart}, @ref{barwidth}. @sref{Bars sample}
@end deftypefn

@anchor{barh}
@deftypefn {MGL command} {} barh vdat ['stl'='']
@deftypefnx {MGL command} {} barh ydat vdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Barh (@code{const mglData &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Barh (@code{const mglData &}y, @code{const mglData &}v, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_barh (@code{HMGL} gr, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_barh_xy (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} v, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw horizontal bars from points to axis plane. If string contain symbol @samp{a} then lines are drawn one above another (like summation). If string contain symbol @samp{f} then waterfall chart is drawn for determining the cumulative effect of sequentially introduced positive or negative values. You can give different colors for positive and negative values if number of specified colors is equal to 2*number of curves. See also @ref{bars}, @ref{barwidth}. @sref{Barh sample}
@end deftypefn

@anchor{chart}
@deftypefn {MGL command} {} chart adat ['col'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Chart (@code{const mglData &}a, @code{const char *}col=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_chart (@code{HMGL} gr, @code{HCDT} a, @code{const char *}col, @code{const char *}opt)
@end ifclear
The function draws colored stripes (boxes) for data in array @var{a}. The number of stripes is equal to the number of rows in @var{a} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette Pal (see @ref{Palette and colors}). Spaces in colors denote transparent ``color'' (i.e. corresponding stripe(s) are not drawn). The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deftypefn

@anchor{boxplot}
@deftypefn {MGL command} {} boxplot adat ['stl'='']
@deftypefnx {MGL command} {} boxplot xdat adat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} BoxPlot (@code{const mglData &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} BoxPlot (@code{const mglData &}x, @code{const mglData &}a, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_boxplot (@code{HMGL} gr, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_boxplot_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw boxplot (also known as a box-and-whisker diagram) at points @var{x}[i]. This is five-number summaries of data @var{a}[i,j] (minimum, lower quartile (Q1), median (Q2), upper quartile (Q3) and maximum) along second (j-th) direction. See also @ref{plot}, @ref{error}, @ref{bars}, @ref{barwidth}. @sref{BoxPlot sample}
@end deftypefn

@anchor{candle}
@deftypefn {MGL command} {} candle vdat1 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 vdat2 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} candle vdat1 vdat2 ydat1 ydat2 ['stl'='']
@deftypefnx {MGL command} {} candle xdat vdat1 vdat2 ydat1 ydat2 ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglData &}v1, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglData &}v1, @code{const mglData &}v2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglData &}v1, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglData &}v1, @code{const mglData &}v2, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Candle (@code{const mglData &}x, @code{const mglData &}v1, @code{const mglData &}v2, @code{const mglData &}y1, @code{const mglData &}y2, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_candle (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_candle_yv (@code{HMGL} gr, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_candle_xyv (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} v1, @code{HCDT} v2, @code{HCDT} y1, @code{HCDT} y2, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw candlestick chart at points @var{x}[i]. This is a combination of a line-chart and a bar-chart, in that each bar represents the range of price movement over a given time interval. Wire (or white) candle correspond to price growth @var{v1}[i]<@var{v2}[i], opposite case -- solid (or dark) candle. "Shadows" show the minimal @var{y1} and maximal @var{y2} prices. If @var{v2} is absent then it is determined as @var{v2}[i]=@var{v1}[i+1]. See also @ref{plot}, @ref{bars}, @ref{barwidth}.
@c TODO @sref{Candle sample}
@end deftypefn


@anchor{error}
@deftypefn {MGL command} {} error ydat yerr ['stl'='']
@deftypefnx {MGL command} {} error xdat ydat yerr ['stl'='']
@deftypefnx {MGL command} {} error xdat ydat xerr yerr ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglData &}y, @code{const mglData &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Error (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ex, @code{const mglData &}ey, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_error (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_error_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_error_exy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ex, @code{HCDT} ey, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw error boxes @{@var{ex}[i], @var{ey}[i]@} at points @{@var{x}[i], @var{y}[i]@}. This can be useful, for example, in experimental points, or to show numeric error or some estimations and so on. If string @var{pen} contain symbol @samp{@@} than large semitransparent mark is used instead of error box. See also @ref{plot}, @ref{plot}. @sref{Error sample}
@end deftypefn

@anchor{mark}
@deftypefn {MGL command} {} mark ydat rdat ['stl'='']
@deftypefnx {MGL command} {} mark xdat ydat rdat ['stl'='']
@deftypefnx {MGL command} {} mark xdat ydat zdat rdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_mark_y (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mark_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mark_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw marks with size @var{r}[i]*@ref{marksize} at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. If you need to draw markers of the same size then you can use @ref{plot} function with empty line style @samp{ }. For markers with size in axis range use @ref{error} with style @samp{@@}. See also @ref{plot}, @ref{textmark}, @ref{error}, @ref{stem}. @sref{Mark sample}
@end deftypefn

@anchor{textmark}
@deftypefn {MGL command} {} textmark ydat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark ydat rdat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark xdat ydat rdat 'txt' ['stl'='']
@deftypefnx {MGL command} {} textmark xdat ydat zdat rdat 'txt' ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}y, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}y, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TextMark (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const wchar_t *}txt, @code{const char *}fnt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_textmark (@code{HMGL} gr, @code{HCDT} y, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw (@code{HMGL} gr, @code{HCDT} y, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_yr (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmark_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}txt, @code{const char *}fnt, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_textmarkw_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const wchar_t *}txt, @code{const char *}fnt, @code{const char *}opt)
@end ifclear
These functions draw string @var{txt} as marks with size proportional to @var{r}[i]*@var{marksize} at points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. By default (if omitted) @var{r}[i]=1. See also @ref{plot}, @ref{mark}, @ref{stem}. @sref{TextMark sample}
@end deftypefn

@anchor{tube}
@deftypefn {MGL command} {} tube ydat rdat ['stl'='']
@deftypefnx {MGL command} {} tube ydat @code{rval} ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat rdat ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat @code{rval} ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat zdat rdat ['stl'='']
@deftypefnx {MGL command} {} tube xdat ydat zdat @code{rval} ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{float} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tube (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{float} r, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tube_r (@code{HMGL} gr, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube (@code{HMGL} gr, @code{HCDT} y, @code{float} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{float} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyzr (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}pen, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tube_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{float} r, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw the tube with variable radius @var{r}[i] along the curve between points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. See also @ref{plot}. @sref{Tube sample}
@end deftypefn

@anchor{torus}
@deftypefn {MGL command} {} torus rdat zdat ['stl'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Torus (@code{const mglData &}r, @code{const mglData &}z, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_torus (@code{HMGL} gr, @code{HCDT} r, @code{HCDT} z, @code{const char *}pen, @code{const char *}opt)
@end ifclear
These functions draw surface which is result of curve @{@var{r}, @var{z}@} rotation around axis. If string @var{pen} contain symbols @samp{x} or @samp{z} then rotation axis will be set to specified direction (default is @samp{y}). See also @ref{plot}, @ref{axial}. @sref{Torus sample}
@end deftypefn

@c ##################################################################
@node 2D plotting, 3D plotting, 1D plotting, MathGL core
@section 2D plotting
@cindex Mesh
@cindex Fall
@cindex Belt
@cindex Surf
@cindex Boxs
@cindex Tile
@cindex Dens
@cindex Cont
@cindex ContF
@cindex ContD
@cindex Axial
@cindex Grad
@cindex Grid


These functions perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}.  By default (if absent) values of @var{x}, @var{y} are equidistantly distributed in axis range. The plots are drawn for each z slice of the data. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. Previous color scheme is used by default. String @var{opt} contain command options (see @ref{Command options}). @sref{2D plot sample}

@anchor{surf}
@deftypefn {MGL command} {} surf zdat ['sch'='']
@deftypefnx {MGL command} {} surf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. If string @var{sch} have symbol @samp{#} then grid lines are drawn. See also @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{Surf sample}
@end deftypefn

@anchor{mesh}
@deftypefn {MGL command} {} mesh zdat ['sch'='']
@deftypefnx {MGL command} {} mesh xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Mesh (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Mesh (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_mesh (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_mesh_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws mesh lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}.  See also @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{Mesh sample}
@end deftypefn

@anchor{fall}
@deftypefn {MGL command} {} fall zdat ['sch'='']
@deftypefnx {MGL command} {} fall xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fall (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fall (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fall (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_fall_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws fall lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used for plotting several curves shifted in depth one from another. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. See also @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{Fall sample}
@end deftypefn

@anchor{belt}
@deftypefn {MGL command} {} belt zdat ['sch'='']
@deftypefnx {MGL command} {} belt xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Belt (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Belt (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_belt (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_belt_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws belts for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. This plot can be used as 3d generalization of @ref{plot}). If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) belts are drawn along y-direction. See also @ref{fall}, @ref{surf}, @ref{plot}, @ref{meshnum}. @sref{Belt sample}
@end deftypefn

@anchor{boxs}
@deftypefn {MGL command} {} boxs zdat ['sch'='']
@deftypefnx {MGL command} {} boxs xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Boxs (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Boxs (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_boxs (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_boxs_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vertical boxes for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. See also @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{Boxs sample}
@end deftypefn

@anchor{tile}
@deftypefn {MGL command} {} tile zdat ['sch'='']
@deftypefnx {MGL command} {} tile xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Tile (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Tile (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tile (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tile_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Such plot can be used as 3d generalization of @ref{step}. See also @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{Tile sample}
@end deftypefn

@anchor{dens}
@deftypefn {MGL command} {} dens zdat ['sch'='']
@deftypefnx {MGL command} {} dens xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{float} zVal=@code{NAN})
@deftypefnx {C function} @code{void} mgl_dens (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws density plot for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{Min}.z. If string @var{sch} have symbol @samp{#} then grid lines are drawn. See also @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{Dens sample}
@end deftypefn

@anchor{cont}
@deftypefn {MGL command} {} cont vdat zdat ['sch'='']
@deftypefnx {MGL command} {} cont vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont__val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k] or at @var{z} = @var{Min}.z if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. See also @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{Cont sample}
@end deftypefn

@deftypefn {MGL command} {} cont zdat ['sch'='']
@deftypefnx {MGL command} {} cont xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contf}
@deftypefn {MGL command} {} contf vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contf vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k] or at @var{z} = @var{Min}.z if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). If string @var{sch} have symbol @samp{#} then grid lines are drawn. See also @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{ContF sample}
@end deftypefn

@deftypefn {MGL command} {} contf zdat ['sch'='']
@deftypefnx {MGL command} {} contf xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContF (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contd}
@deftypefn {MGL command} {} contd vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contd vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contd_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contd_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k] (or at @var{z} = @var{Min}.z if @var{sch} contain symbol @samp{_}) with manual colors. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v} (must be @code{v.nx>2}). String @var{sch} sets the contour colors: the color of k-th contour is determined by character @code{sch[k%strlen(sch)]}. See also @ref{dens}, @ref{cont}, @ref{contf}. @sref{ContD sample}
@end deftypefn

@deftypefn {MGL command} {} contd zdat ['sch'='']
@deftypefnx {MGL command} {} contd xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContD (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contd (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contd_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contv}
@deftypefn {MGL command} {} contv vdat zdat ['sch'='']
@deftypefnx {MGL command} {} contv vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contv_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contv_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vertical cylinder at contour lines for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z}=@var{v}[k] or at @var{z} = @var{Min}.z if @var{sch} contain symbol @samp{_}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{#} then grid lines are drawn. If string @var{sch} have symbol @samp{t} or @samp{T} then contour labels @var{v}[k] will be drawn below (or above) the contours. See also @ref{cont}, @ref{contf}. @sref{ContV sample}
@end deftypefn

@deftypefn {MGL command} {} contv zdat ['sch'='']
@deftypefnx {MGL command} {} contv xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContV (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contv (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contv_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{axial}
@deftypefn {MGL command} {} axial vdat zdat ['sch'='']
@deftypefnx {MGL command} {} axial vdat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglData &}v, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_axial_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_axial_xy_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface which is result of contour plot rotation for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string contain symbols @samp{x} or @samp{z} then rotation axis will be set to specified direction (default is @samp{y}). See also @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{Axial sample}
@end deftypefn

@deftypefn {MGL command} {} axial zdat ['sch'='']
@deftypefnx {MGL command} {} axial xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {Method on @code{mglGraph}} @code{void} Axial (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""}, @code{int} num=@code{3})
@deftypefnx {C function} @code{void} mgl_axial (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_axial_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{grid2}
@deftypefn {MGL command} {} grid2 zdat ['sch'='']
@deftypefnx {MGL command} {} grid2 xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grid (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grid_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws grid lines for density plot of surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} at @var{z} = @var{zVal}. String @var{sch} sets the color scheme. Previous color scheme is used by default. The minor dimensions of arrays @var{x}, @var{y}, @var{z} should be equal @code{x.nx=z.nx && y.nx=z.ny} or @code{x.nx=y.nx=z.nx && x.ny=y.ny=z.ny}. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{z}). Grid is plotted for each z slice of the data. See also @ref{dens}, @ref{cont}, @ref{contf}, @ref{meshnum}.
@end deftypefn


@c ##################################################################
@node 3D plotting, Dual plotting, 2D plotting, MathGL core
@section 3D plotting
@cindex Surf3
@cindex Dens3
@cindex Cont3
@cindex ContF3
@cindex Grid3
@cindex Cloud
@cindex Beam

These functions perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}.By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{a} should be equal @code{x.nx=a.nx && y.nx=a.ny && z.nz=a.nz} or @code{x.nx=y.nx=z.nx=a.nx && x.ny=y.ny=z.ny=a.ny && x.nz=y.nz=z.nz=a.nz}. Arrays @var{x}, @var{y} and @var{z} can be vectors (not matrices as @var{a}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. Previous color scheme is used by default. String @var{opt} contain command options (see @ref{Command options}). @sref{3D plot sample}

@anchor{surf3}
@deftypefn {MGL command} {} surf3 adat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3 xdat ydat zdat adat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{float} val, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3_val (@code{HMGL} gr, @code{float} val, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3_xyz_val (@code{HMGL} gr, @code{float} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. If string contain @samp{#} then wire plot is produced. Note, that there is possibility of incorrect plotting due to uncertainty of cross-section defining if there are two or more isosurface intersections inside one cell. See also @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{Surf3 sample}
@end deftypefn

@deftypefn {MGL command} {} surf3 adat ['sch'='']
@deftypefnx {MGL command} {} surf3 xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{cloud}
@deftypefn {MGL command} {} cloud adat ['sch'='']
@deftypefnx {MGL command} {} cloud xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cloud (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cloud (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cloud (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cloud_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws cloud plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{a}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on @ref{MeshNum}. If string @var{sch} contain symbol @samp{.} then lower quality plot will produced with much low memory usage. If string @var{sch} contain symbol @samp{!} then transparency will be inversed, i.e. higher become transparent and lower become not transparent. See also @ref{surf3}. @sref{Cloud sample}
@end deftypefn

@anchor{dens3}
@deftypefn {MGL command} {} dens3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} dens3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dens3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dens3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The function draws density plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Density is plotted at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{Dens3 sample}
@end deftypefn

@anchor{cont3}
@deftypefn {MGL command} {} cont3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} cont3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The function draws contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{stl} have symbol @samp{#} then grid lines are drawn. If string @var{stl} have symbol @samp{t} or @samp{T} then contour labels will be drawn below (or above) the contours. See also @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{Cont3 sample}
@end deftypefn

@deftypefn {MGL command} {} cont3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} cont3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Cont3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{contf3}
@deftypefn {MGL command} {} contf3 vdat adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} contf3 vdat xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglData &}v, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf3_xyz_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The function draws solid (or filled) contour plot for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Contours are plotted for values specified in array @var{v} at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). If string @var{stl} have symbol @samp{#} then grid lines are drawn. If string @var{stl} have symbol @samp{t} or @samp{T} then contour labels will be drawn below (or above) the contours. See also @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{Cont3 sample}
@end deftypefn

@deftypefn {MGL command} {} contf3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} contf3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Contf3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The same as previous with vector @var{v} of @var{num}-th elements equidistantly distributed in color range. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 7).
@end deftypefn

@anchor{grid3}
@deftypefn {MGL command} {} grid3 adat ['sch'='' @code{sval=-1}]
@deftypefnx {MGL command} {} grid3 xdat ydat zdat adat ['sch'='' @code{sval=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid3 (@code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grid3 (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{float} sVal=@code{-1}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grid3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grid3_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{float} sVal, @code{const char *}opt)
@end ifclear
The function draws grid for 3d data specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]). Grid is plotted at slice @var{sVal} in direction @{@samp{x}, @samp{y}, @samp{z}@} if @var{sch} contain corresponding symbol (by default, @samp{y} direction is used). See also @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}, @ref{meshnum}.
@end deftypefn

@anchor{beam}
@deftypefn {MGL command} {} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Beam (@code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0}, @code{int} num=@code{3})
@deftypefnx {Method on @code{mglGraph}} @code{void} Beam (@code{float} val, @code{const mglData &}tr, @code{const mglData &}g1, @code{const mglData &}g2, @code{const mglData &}a, @code{float} r, @code{const char *}stl=@code{""}, @code{int} flag=@code{0})
@deftypefnx {C function} @code{void} mgl_beam (@code{HMGL} gr, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{float} r, @code{const char *}stl, @code{int} flag, @code{int} num)
@deftypefnx {C function} @code{void} mgl_beam_val (@code{HMGL} gr, @code{float} val, @code{HCDT} tr, @code{HCDT} g1, @code{HCDT} g2, @code{HCDT} a, @code{float} r, @code{const char *}stl, @code{int} flag)
@end ifclear
Draws the isosurface for 3d array @var{a} at constant values of @var{a}=@var{val}. This is special kind of plot for @var{a} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{r}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. See also @ref{surf3}.
@end deftypefn



@c ##################################################################
@node Dual plotting, Vector fields, 3D plotting, MathGL core
@section Dual plotting

@cindex SurfC
@cindex SurfA
@cindex Surf3C
@cindex Surf3A
@cindex TileS
@cindex Map
@cindex STFA

These plotting functions draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{c} should be equal. Arrays @var{x}, @var{y} (and @var{z} for @code{Surf3C, Surf3A}) can be vectors (not matrices as @var{c}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. Previous color scheme is used by default. String @var{opt} contain command options (see @ref{Command options}).

@anchor{surfc}
@deftypefn {MGL command} {} surfc zdat cdat ['sch'='']
@deftypefnx {MGL command} {} surfc xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfC (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfC (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surfc (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surfc_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and color it by matrix @var{c}[i,j]. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. Surface is plotted for each z slice of the data. See also @ref{surf}, @ref{surfa}, @ref{surf3c}. @sref{SurfC sample}
@end deftypefn

@anchor{surf3c}
@deftypefn {MGL command} {} surf3c adat cdat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c_val (@code{HMGL} gr, @code{float} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3c_xyz_val (@code{HMGL} gr, @code{float} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} function but the color of isosurface depends on values of array @var{c}. If string contain @samp{#} then wire plot is produced. See also @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{Surf3C sample}
@end deftypefn

@deftypefn {MGL command} {} surf3c adat cdat ['sch'='']
@deftypefnx {MGL command} {} surf3c xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3C (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3c (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3c_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. Here @var{num} is equal to parameter @var{value} in options @var{opt} (default is 3).
@end deftypefn


@anchor{surfa}
@deftypefn {MGL command} {} surfa zdat cdat ['sch'='']
@deftypefnx {MGL command} {} surfa xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfA (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} SurfA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surfa (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@} and transparent it by matrix @var{c}[i,j]. If string @var{sch} have symbol @samp{#} then grid lines are drawn. All dimensions of arrays @var{z} and @var{c} must be equal. Surface is plotted for each z slice of the data. See also @ref{surf}, @ref{surfc}, @ref{surf3a}. @sref{SurfA sample}
@end deftypefn

@anchor{surf3a}
@deftypefn {MGL command} {} surf3a adat cdat @code{val} ['sch'='']
@deftypefnx {MGL command} {} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{float} val, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{float} val, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a_val (@code{HMGL} gr, @code{float} val, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3a_xyz_val (@code{HMGL} gr, @code{float} val, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws isosurface plot for 3d array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} function but the color of isosurface depends on values of array @var{c}. If string contain @samp{#} then wire plot is produced. See also @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{Surf3C sample}
@end deftypefn

@deftypefn {MGL command} {} surf3a adat cdat ['sch'='']
@deftypefnx {MGL command} {} surf3a xdat ydat zdat adat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Surf3A (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_surf3a (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_surf3a_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws @var{num}-th uniformly distributed in color range isosurfaces for 3d data. At this array @var{c} can be vector with values of transparency and @var{num}=@var{c}.nx. In opposite case @var{num} is equal to parameter @var{value} in options @var{opt} (default is 3).
@end deftypefn

@anchor{tiles}
@deftypefn {MGL command} {} tiles zdat rdat ['sch'='']
@deftypefnx {MGL command} {} tiles xdat ydat zdat rdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TileS (@code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TileS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}r, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tiles (@code{HMGL} gr, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tiles_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} r, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws horizontal tiles for surface specified parametrically @{@var{x}[i,j], @var{y}[i,j], @var{z}[i,j]@}. It is mostly the same as @ref{tile} but the size of tiles is determined by @var{r} array. This is some kind of ``transparency'' useful for exporting to EPS files. Tiles is plotted for each z slice of the data. See also @ref{surfa}, @ref{tile}. @sref{TileS sample}
@end deftypefn

@anchor{map}
@deftypefn {MGL command} {} map udat vdat ['sch'='']
@deftypefnx {MGL command} {} map xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Map (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Map (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_map (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_map_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws mapping plot for matrices @{@var{ax}, @var{ay} @} which parametrically depend on coordinates @var{x}, @var{y}. The initial position of the cell (point) is marked by color. Height is proportional to Jacobian(ax,ay). This plot is like Arnold diagram ???. If string @var{sch} contain symbol @samp{.} then the color ball at matrix knots are drawn otherwise face is drawn. @sref{Map sample}
@end deftypefn

@anchor{stfa}
@deftypefn {MGL command} {} stfa re im @code{dn} ['sch'='']
@deftypefnx {MGL command} {} stfa xdat ydat re im @code{dn} ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} STFA (@code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} STFA (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}re, @code{const mglData &}im, @code{int} dn, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_stfa (@code{HMGL} gr, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_stfa_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} re, @code{HCDT} im, @code{int} dn, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z}=@var{Min}.z. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. At this array @var{re}, @var{im} parametrically depend on coordinates @var{x}, @var{y}. The size of @var{re} and @var{im} must be the same. The minor dimensions of arrays @var{x}, @var{y}, @var{re} should be equal. Arrays @var{x}, @var{y} can be vectors (not matrix as @var{re}).  @sref{STFA sample}
@end deftypefn


@c ##################################################################
@node Vector fields, Other plotting, Dual plotting, MathGL core
@section Vector fields

@cindex Traj
@cindex Vect
@cindex Dew
@cindex Flow
@cindex FlowP
@cindex Pipe

These functions perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vectors along the curve (Traj), vector field by dew-drops (Dew), flow threads (Flow, FlowP), flow pipes (Pipe). By default (if absent) values of @var{x}, @var{y}, @var{z} are equidistantly distributed in axis range. The minor dimensions of arrays @var{x}, @var{y}, @var{z}, @var{ax} should be equal. The size of @var{ax}, @var{ay} and @var{az} must be equal. Arrays @var{x}, @var{y}, @var{z} can be vectors (not matrices as @var{ax}). String @var{sch} sets the color scheme (see @ref{Color scheme}) for plot. Previous color scheme is used by default. String @var{opt} contain command options (see @ref{Command options}).

@anchor{traj}
@deftypefn {MGL command} {} traj xdat ydat udat vdat ['sch'='']
@deftypefnx {MGL command} {} traj xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Traj (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Traj (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_traj_xyz (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}z, @code{HCDT}ax, @code{HCDT}ay, @code{HCDT}az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_traj_xy (@code{HMGL} gr, @code{HCDT}x, @code{HCDT}y, @code{HCDT}ax, @code{HCDT}ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws vectors @{@var{ax}, @var{ay}, @var{az}@} along a curve @{@var{x}, @var{y}, @var{z}@}. The length of arrows are proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}. String @var{pen} specifies the color (see @ref{Line styles}). By default (@code{pen=""}) color from palette is used (see @ref{Palette and colors}). Parameter @var{len} set the vector length factor (if non-zero) or vector length to be proportional the distance between curve points (if @var{len}=0). The minor sizes of all arrays must be equal and large 2. The plots are drawn for each row if one of the data is the matrix. See also @ref{vect}. @sref{Traj sample}
@end deftypefn

@anchor{vect}
@deftypefn {MGL command} {} vect udat vdat ['sch'='']
@deftypefnx {MGL command} {} vect xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_vect_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_vect_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws plane vector field plot for the field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z}=@var{Min}.z. The length and color of arrows are proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of arrows depend on @ref{meshnum}. The apperance of the hachures (arrows) can be changed by symbols: @samp{f} for drawing fixed length arrows, @samp{>}, @samp{<} for drawing arrows to or from the cell point (default is centering), @samp{.} for drawing hachures with dots instead of arrows, @samp{=} for enabling color gradient along arrows. See also @ref{flow}, @ref{dew}. @sref{Vect sample}
@end deftypefn

@deftypefn {MGL command} {} vect udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} vect xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Vect (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_vect_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_vect_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the length and color of arrows is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@anchor{dew}
@deftypefn {MGL command} {} dew udat vdat ['sch'='']
@deftypefnx {MGL command} {} dew xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dew (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dew (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dew (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dew_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws dew-drops for plane vector field @{@var{ax}, @var{ay}@} depending parametrically on coordinates @var{x}, @var{y} at level @var{z}=@var{Min}.z. Note that this is very expensive plot in memory usage and creation time! The color of drops is proportional to @math{\sqrt@{ax^2+ay^2@}}. The number of drops depend on @ref{meshnum}. See also @ref{vect}. @sref{Dew sample}
@end deftypefn

@anchor{flow}
@deftypefn {MGL command} {} flow udat vdat ['sch'='']
@deftypefnx {MGL command} {} flow xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flow_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flow_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws flow threads for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level @var{z} = @var{Min}.z. Number of threads is proportional to @var{value} option (default is 5). If @samp{#} symbol is specified then threads start only from edges of axis range. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). If string @var{sch} contain symbol @samp{v} then arrows are drawn on flow threads. See also @ref{pipe}, @ref{vect}. @sref{Flow sample}
@end deftypefn

@deftypefn {MGL command} {} flow udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} flow xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Flow (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flow_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flow_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn

@deftypefn {MGL command} {} flow @code{x0 y0} udat vdat ['sch'='']
@deftypefnx {MGL command} {} flow @code{x0 y0} xdat ydat udat vdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_2d (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flowp_xy (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The same as first one (@ref{flow}) but draws single flow thread starting from point @var{p0}=@{@var{x0},@var{y0},@var{z0}@}.
@end deftypefn

@deftypefn {MGL command} {} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deftypefnx {MGL command} {} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} FlowP (@code{mglPoint} p0, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_flowp_3d (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_flowp_xyz (@code{HMGL} gr, @code{float} x0, @code{float} y0, @code{float} z0, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{const char *}opt)
@end ifclear
This is 3D version of the previous functions.
@end deftypefn

@anchor{grad}
@deftypefn {MGL command} {} grad pdat ['sch'='']
@deftypefnx {MGL command} {} grad xdat ydat pdat ['sch'='']
@deftypefnx {MGL command} {} grad xdat ydat zdat pdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Grad (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}phi, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_grad (@code{HMGL} gr, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grad_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_grad_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws gradient lines for scalar field @var{phi}[i,j,k] specified parametrically @{@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]@}. Number of lines is proportional to @var{value} option (default is 5). If @var{value}<0 then lines start only from edges of axis range. Warm color corresponds to normal flow (like minimum). Cold one corresponds to inverse flow (like maximum). If string @var{sch} contain symbol @samp{v} then arrows are drawn on flow threads. See also @ref{dens3}, @ref{cont3}, @ref{flow}.
@end deftypefn

@anchor{pipe}
@deftypefn {MGL command} {} pipe udat vdat ['sch'='' @code{r0=0.05}]
@deftypefnx {MGL command} {} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}ax, @code{const mglData &}ay, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_pipe_2d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{float} r0, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pipe_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} ax, @code{HCDT} ay, @code{const char *}sch, @code{float} r0, @code{const char *}opt)
@end ifclear
The function draws flow pipes for the plane vector field @{@var{ax}, @var{ay}@} parametrically depending on coordinates @var{x}, @var{y} at level @var{z} = @var{Min}.z. Number of pipes is proportional to @var{value} option (default is 5). If @samp{#} symbol is specified then pipes start only from edges of axis range. The color of lines is proportional to @math{\sqrt@{ax^2+ay^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). Parameter @var{r0} set the base pipe radius. If @var{r0}<0 or symbol @samp{i} is specified then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. The minor dimensions of arrays @var{x}, @var{y} and @var{ax} must be equal too. Arrays @var{x} and @var{y} can be vectors (not matrices as @var{ax}). The vector field is plotted for each z slice of @var{ax}, @var{ay}. See also @ref{flow}, @ref{vect}. @sref{Pipe sample}
@end deftypefn

@deftypefn {MGL command} {} pipe udat vdat wdat ['sch'='' @code{r0=0.05}]
@deftypefnx {MGL command} {} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Pipe (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}ax, @code{const mglData &}ay, @code{const mglData &}az, @code{const char *}sch=@code{""}, @code{float} r0=@code{0.05}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_pipe_3d (@code{HMGL} gr, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{float} r0, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_pipe_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} ax, @code{HCDT} ay, @code{HCDT} az, @code{const char *}sch, @code{float} r0, @code{const char *}opt)
@end ifclear
This is 3D version of the first functions. Here arrays @var{ax}, @var{ay}, @var{az} must be 3-ranged tensors with equal sizes and the color of line is proportional to @math{\sqrt@{ax^2+ay^2+az^2@}}.
@end deftypefn


@c ##################################################################
@node Other plotting, Nonlinear fitting, Vector fields, MathGL core
@section Other plotting

@cindex DensXYZ
@cindex ContXYZ
@cindex ContFXYZ
@cindex Dots
@cindex Crust
@cindex TriPlot
@cindex TriCont
@cindex QuadPlot
@cindex Plots by formula

These functions perform miscellaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@anchor{densz} @anchor{densy} @anchor{densx} @anchor{DensXYZ}
@deftypefn {MGL command} {} densx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} densy dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} densz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} DensX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} DensY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} DensZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dens_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dens_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw density plot in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->DensX(c.Sum("x"),"BbcyrR",-1);
gr->DensY(c.Sum("y"),"",1);
gr->DensZ(c.Sum("z"),"",-1);
@end example
will produce the following picture. See also @ref{ContXYZ}, @ref{ContFXYZ}, @ref{dens}, @ref{Data manipulation}. @sref{Dens projection sample}
@end deftypefn

@anchor{contz} @anchor{conty} @anchor{contx} @anchor{ContXYZ}
@deftypefn {MGL command} {} contx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} conty dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw contour lines in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->ContX(c.Sum("x"),"BbcyrR",-1);
gr->ContY(c.Sum("y"),0,1);
gr->ContZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{Cont projection sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} ContX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_cont_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_cont_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
The same as previous with manual contour levels.
@end deftypefn
@end ifclear

@anchor{contfz} @anchor{contfy} @anchor{contfx} @anchor{ContFXYZ}
@deftypefn {MGL command} {} contfx dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contfy dat ['sch'='' @code{sval=nan}]
@deftypefnx {MGL command} {} contfz dat ['sch'='' @code{sval=nan}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFX (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFY (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFZ (@code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_x (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_z (@code{HMGL} gr, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@end ifclear
These plotting functions draw solid contours in x, y, or z plain. If @var{a} is a tensor (3-dimensional data) then interpolation to a given @var{sVal} is performed. These functions are useful for creating projections of the 3D data array to the bounding box. For example, code like
@example
gr->ContFX(c.Sum("x"),"BbcyrR",-1);
gr->ContFY(c.Sum("y"),0,1);
gr->ContFZ(c.Sum("z"),0,-1);
@end example
will produce the following picture. See also @ref{ContFXYZ}, @ref{DensXYZ}, @ref{cont}, @ref{Data manipulation}. @sref{Cont projection sample}
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{void} ContFX (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFY (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} ContFZ (@code{const mglData &}v, @code{const mglData &}a, @code{const char *}stl=@code{""}, @code{float} sVal=@code{NAN}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_contf_x_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_y_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_contf_z_val (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} a, @code{const char *}stl, @code{float} sVal, @code{const char *}opt)
The same as previous with manual contour levels.
@end deftypefn
@end ifclear

@anchor{fplot}
@deftypefn {MGL command} {} fplot 'y(x)' ['pen'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FPlot (@code{const char *}eqY, @code{const char *}pen=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fplot (@code{HMGL} gr, @code{const char *}eqY, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Draws command function @samp{y(x)} at plane @var{z}=@var{Min}.z where @samp{x} variable is changed in @code{xrange}. You do not need to create the data arrays to plot it.  See also @ref{plot}.
@end deftypefn

@deftypefn {MGL command} {} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FPlot (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fplot_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}pen, @code{const char *}opt)
@end ifclear
Draws command parametrical curve @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@} where @samp{t} variable is changed in range [0, 1]. You do not need to create the data arrays to plot it. See also @ref{plot}.
@end deftypefn

@anchor{fsurf}
@deftypefn {MGL command} {} fsurf 'z(x,y)' ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FSurf (@code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""});
@deftypefnx {C function} @code{void} mgl_fsurf (@code{HMGL} gr, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt);
@end ifclear
Draws command surface for function @samp{z(x,y)} where @samp{x}, @samp{y} variable are changed in @code{xrange, yrange}. You do not need to create the data arrays to plot it. See also @ref{surf}.
@end deftypefn

@deftypefn {MGL command} {} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} FSurf (@code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_fsurf_xyz (@code{HMGL} gr, @code{const char *}eqX, @code{const char *}eqY, @code{const char *}eqZ, @code{const char *}sch, @code{const char *}opt)
@end ifclear
Draws command parametrical surface @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@} where @samp{u}, @samp{v} variable are changed in range [0, 1]. You do not need to create the data arrays to plot it. See also @ref{surf}.
@end deftypefn

@anchor{triplot}
@deftypefn {MGL command} {} triplot idat xdat ydat ['sch'='']
@deftypefnx {MGL command} {} triplot idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} triplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_triplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_triplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_triplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the surface of triangles. Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{dots}, @ref{crust}, @ref{quadplot}.
@end deftypefn

@anchor{tricont}
@deftypefn {MGL command} {} tricont vdat idat xdat ydat zdat cdat ['sch'='']
@deftypefnx {MGL command} {} tricont vdat idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} tricont idat xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} TriCont (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriCont (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriContV (@code{const mglData &}v, @code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} TriContV (@code{const mglData &}v, @code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_tricont_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyzcv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_tricont_xyzv (@code{HMGL} gr, @code{HCDT} v, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws contour lines for surface of triangles at @var{z}=@var{v}[k] (or at  @var{z} = @var{Min}.z if @var{sch} contain symbol @samp{_}). Triangle vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. Contours are plotted for @var{z}[i,j]=@var{v}[k] where @var{v}[k] are values of data array @var{v}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Array @var{c} (if specified) is used for contour coloring. First dimensions of @var{id} must be 3 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of triangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{triplot}, @ref{cont}.
@end deftypefn

@anchor{quadplot}
@deftypefn {MGL command} {} quadplot idat xdat ydat ['sch'='']
@deftypefnx {MGL command} {} quadplot idat xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} quadplot idat xdat ydat zdat cdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}c, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} QuadPlot (@code{const mglData &}id, @code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_quadplot_xy (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_quadplot_xyz (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_quadplot_xyzc (@code{HMGL} gr, @code{HCDT} id, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} c, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the surface of quadrangles. Quadrangles vertexes are set by indexes @var{id} of data points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. First dimensions of @var{id} must be 4 or greater. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. Parameter @var{c} set the colors of quadrangles (if @var{id}.ny=@var{c}.nx) or colors of vertexes (if @var{x}.nx=@var{c}.nx). See also @ref{triplot}.
@end deftypefn

@anchor{dots}
@deftypefn {MGL command} {} dots xdat ydat zdat ['sch'='']
@deftypefnx {MGL command} {} dots xdat ydat zdat adat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Dots (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_dots (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@deftypefnx {C function} @code{void} mgl_dots_a (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function draws the arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If array @var{a} is specified then it define the transparency of dots. Arrays @var{x}, @var{y}, @var{z}, @var{a} must have equal sizes. See also @ref{crust}, @ref{mark}, @ref{plot}. @sref{Dots sample}
@end deftypefn

@anchor{crust}
@deftypefn {MGL command} {} crust xdat ydat zdat ['sch'='']
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Crust (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const char *}sch=@code{""}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_crust (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{const char *}sch, @code{const char *}opt)
@end ifclear
The function reconstruct and draws the surface for arbitrary placed points @{@var{x}[i], @var{y}[i], @var{z}[i]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. If string contain @samp{#} then wire plot is produced. Arrays @var{x}, @var{y}, @var{z} must have equal sizes. See also @ref{dots}, @ref{triplot}. @sref{Crust sample}
@end deftypefn

@c ##################################################################
@node Nonlinear fitting, Data manipulation, Other plotting, MathGL core
@section Nonlinear fitting
@cindex Fit
@cindex FitS
@cindex PutsFit
@cindex mglFitPnts
@cindex Fit2
@cindex Fit3

These functions fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The function @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used. Parameter @var{print}=@code{true} switch on printing the found coefficients to @var{Message} (see @ref{Error handling}).

Functions Fit() and FitS() do not draw the obtained data themselves. They fill the data @var{fit} by formula @samp{f} with found coefficients and return it. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the axis range. Number of points in @var{fit} is selected as maximal value of @var{fit} size and the value of @var{mglFitPnts}. Note, that this functions use GSL library and do something only if MathGL was compiled with GSL support. @sref{Fitting sample}

@anchor{fits}
@deftypefn {MGL command} {} fits res adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat ydat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fits res xdat ydat zdat adat sdat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} FitS (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const mglData &}s, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_ys (@code{HMGL} gr, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xys (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyzs (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyzas (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{HCDT} s, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
Fit data along x-, y- and z-directions for array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with weight factor @var{s}[i,j,k].
@end deftypefn

@anchor{fit}
@deftypefn {MGL command} {} fit res adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat ydat adat sdat 'func' 'var' [ini=0]
@deftypefnx {MGL command} {} fit res xdat ydat zdat adat sdat 'func' 'var' [ini=0]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_y (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_xyza (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@end ifclear
Fit data along x-, y- and z-directions for array specified parametrically @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) with weight factor 1.
@end deftypefn


@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{mglData} Fit2 (@code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit2 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Fit3 (@code{mglData &}fit, @code{const mglData &}a, @code{const char *}func, @code{const char *}var, @code{mglData &}ini, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_fit_2 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_fit_3 (@code{HMGL} gr, @code{HCDT} a, @code{const char *}func, @code{const char *}var, @code{HMDT} ini, @code{const char *}opt)
Fit data along all directions for 2d or 3d arrays @var{a} with @var{s}=1 and @var{x}, @var{y}, @var{z} equidistantly distributed in interval [@var{Min}, @var{Max}].
@end deftypefn
@end ifclear

@anchor{putsfit}
@deftypefn {MGL command} {} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} PutsFit (@code{mglPoint} p, @code{const char *}prefix=@code{""}, @code{const char *}font=@code{""}, @code{float} size=@code{-1})
@deftypefnx {C function} @code{void} mgl_puts_fit (@code{HMGL} gr, @code{float} x, @code{float} y, @code{float} z, @code{const char *}prefix, @code{const char *}font, @code{float} size)
@end ifclear
Print last fitted formula with found coefficients (as numbers) at position @var{p0}. The string @var{prefix} will be printed before formula. All other parameters are the same as in @ref{Text printing}.
@end deftypefn

@ifclear UDAV
@deftypefn {Method on @code{mglGraph}} @code{const char *}GetFit ()
@deftypefnx {C function} @code{const char *} mgl_get_fit (@code{HMGL} gr)
Get last fitted formula with found coefficients (as numbers).
@end deftypefn
@end ifclear


@c ##################################################################
@node Data manipulation, IDTF functions, Nonlinear fitting, MathGL core
@section Data manipulation
@cindex Hist

@deftypefn {MGL command} {} hist @sc{res} xdat adat
@deftypefnx {MGL command} {} hist @sc{res} xdat ydat adat
@deftypefnx {MGL command} {} hist @sc{res} xdat ydat zdat adat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglData &}x, @code{const mglData &}a, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}a, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{mglData} Hist (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z, @code{const mglData &}a, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_hist_x (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_hist_xy (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} a, @code{const char *}opt)
@deftypefnx {C function} @code{HMDT} mgl_hist_xyz (@code{HMGL} gr, @code{HCDT} x, @code{HCDT} y, @code{HCDT} z, @code{HCDT} a, @code{const char *}opt)
@end ifclear
These functions make distribution (histogram) of data. They do not draw the obtained data themselves. These functions can be useful if user have data defined for random points (for example, after PIC simulation) and he want to produce a plot which require regular data (defined on grid(s)). The range for grids is always selected as axis range. Arrays @var{x}, @var{y}, @var{z} define the positions (coordinates) of random points. Array @var{a} define the data value. Number of points in output array @var{res} is selected as maximal value of @var{res} size and the value of @var{mglFitPnts}.
@end deftypefn


@deftypefn {MGL command} {} fill dat 'eq'
@deftypefnx {MGL command} {} fill dat 'eq' vdat
@deftypefnx {MGL command} {} fill dat 'eq' vdat wdat
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglData &}v, @code{const char *}opt=@code{""})
@deftypefnx {Method on @code{mglGraph}} @code{void} Fill (@code{mglData &}u, @code{const char *}eq, @code{const mglData &}v, @code{const mglData &}w, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{void} mgl_data_fill_eq (@code{HMGL} gr, @code{HMDT} u, @code{const char *}eq, @code{HCDT}v, @code{HCDT}w, @code{const char *}opt)
@end ifclear
Fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in axis range. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of arrays @var{v}, @var{w} which can be @code{NULL} (i.e. can be omitted).
@end deftypefn

@deftypefn {MGL command} {} pde @sc{res} 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
@ifclear UDAV
@deftypefnx {Method on @code{mglGraph}} @code{mglData} PDE (@code{const char *}ham, @code{const mglData &}ini_re, @code{const mglData &}ini_im, @code{float} dz=@code{0.1}, @code{float} k0=@code{100}, @code{const char *}opt=@code{""})
@deftypefnx {C function} @code{HMDT} mgl_pde_solve (@code{HMGL} gr, @code{const char *}ham, @code{HCDT} ini_re, @code{HCDT} ini_im, @code{float} dz, @code{float} k0, @code{const char *}opt)
@end ifclear
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{Min}, @var{Max} set the bounding box for the solution. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. You may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE sample}  @sref{PDE sample}
@end deftypefn

@c ##################################################################
@node IDTF functions, , Data manipulation, MathGL core
@section IDTF functions
@cindex NewFrame
@cindex EndFrame
@cindex GetNumFrame

These functions provide IDTF specific features. In all other cases they do nothing.

@ifclear UDAV

@deftypefn {Method on @code{mglGraph}} @code{void} VertexColor (@code{bool} enable)
Enables smooth color change.
@end deftypefn

@deftypefn {Method on @code{mglGraph}} @code{void} Compression (@code{bool} enable)
Gives smaller files, but quality degrades.
@end deftypefn

@c	inline void DoubleSided(bool){}		// NOTE: Add later -- IDTF
@c	inline void TextureColor(bool){}	// NOTE: Add later -- IDTF

@end ifclear
