@c ------------------------------------------------------------------
@chapter Data processing

Class for working with data array. This class is defined in @code{#include <mgl/mgl_data.h>}. The class has functions for easy and safe allocation, resizing, loading and saving, modifying of data arrays. Also it can numerically differentiate and integrate data, interpolate, fill data by formula and so on. Class supports data with dimensions up to 3 (like function of 3 variables -- x,y,z). The internal representation of numbers is float. Float type was chosen because it has smaller size in memory and usually it has enough precision in plotting purposes. You can change it by selecting option @code{--enable-double} at the library configuring (@pxref{Installation and usage}).

@menu
* Public variables::
* Data creation::
* Fill::
* Rearrange::
* File I/O::
* Make another data::
* Change data::
* Interpolation::
* Informational functions::
* Operators::
* Global functions::
@end menu

@c ------------------------------------------------------------------
@node Public variables, Data creation, , Data processing
@section Public variables

@ifset UDAV
MGL don't support direct access to data arrays. @pxref{Fill}
@end ifset

@ifclear UDAV
@deftypecv {Variable} mglData @code{float *} a
Data array itself. The flat data representation is used. For example, matrix [nx x ny] is presented as flat (1d-) array with length nx*ny. The element with indexes @{i, j, k@} is a[i+nx*j+nx*ny*k] (indexes are zero based).
@end deftypecv
@deftypecv {Variable} mglData @code{int} nx
Number of points in 1st dimensions ('x' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{int} ny
Number of points in 2nd dimensions ('y' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{int} nz
Number of points in 3d dimensions ('z' dimension).
@end deftypecv
@deftypecv {Variable} mglData @code{char *} id
Column (or slice if nz>1) names -- one character per column.
@end deftypecv
@deftypecv {Variable} mglData @code{bool} link
Flag to use external data, i.e. don't delete it.
@end deftypecv

@deftypefn {Method on @code{mglData}} @code{float} GetVal (@code{long} i)
@deftypefnx {Method on @code{mglData}} @code{void} SetVal (@code{float} val, @code{long} i)
@deftypefnx {Method on @code{mglData}} @code{float} vthr (@code{long} i)
Gets or sets the value in by "flat" index @var{i} without border checking. Index @var{i} should be in range [0, nx*ny*nz].
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{long} GetNx ()
@deftypefnx {Method on @code{mglData}} @code{long} GetNy ()
@deftypefnx {Method on @code{mglData}} @code{long} GetNz ()
@deftypefnx {C function} @code{long} mgl_data_get_nx (@code{HCDT} dat)
@deftypefnx {C function} @code{long} mgl_data_get_ny (@code{HCDT} dat)
@deftypefnx {C function} @code{long} mgl_data_get_nz (@code{HCDT} dat)
Gets the x-, y-, z-size of the data.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{float} v (@code{long} i, @code{long} j=@code{0}, @code{long} k=@code{0})
@deftypefnx {C function} @code{float} mgl_data_get_value (@code{HCDT} dat, @code{int} i, @code{int} j, @code{int} k)
@deftypefnx {C function} @code{float *} mgl_data_value (@code{HMDT} dat, @code{int} i, @code{int} j, @code{int} k)
@deftypefnx {C function} @code{void} mgl_data_set_value (@code{HMDT} dat, @code{float} v, @code{int} i, @code{int} j, @code{int} k)
Gets or sets the value in specified cell of the data with border checking.
@end deftypefn
@deftypefn {C function} @code{const float *} mgl_data_data (@code{HCDT} dat)
Returns pointer to internal data array.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{float} dvx (@code{long} i, @code{long} j=@code{0}, @code{long} k=@code{0})
@deftypefnx {Method on @code{mglData}} @code{float} dvy (@code{long} i, @code{long} j=@code{0}, @code{long} k=@code{0})
@deftypefnx {Method on @code{mglData}} @code{float} dvz (@code{long} i, @code{long} j=@code{0}, @code{long} k=@code{0})
Returns numerical derivate along x-, y- or z-direction.
@end deftypefn
@end ifclear

@c ------------------------------------------------------------------
@node Data creation, Fill, Public variables, Data processing
@section Data creation
@cindex mglData
@cindex Set
@cindex Read
@cindex New
@cindex Delete
@cindex Copy
@cindex List
@cindex Var

@anchor{new}
@deftypefn {MGL command} {} new dat [@code{nx=1 ny=1 nz=1}]
@ifclear UDAV
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{int} mx=@code{1}, @code{int} my=@code{1}, @code{int} mz=@code{1})
@deftypefnx {C function} @code{HMDT} mgl_create_data ()
@deftypefnx {C function} @code{HMDT} mgl_create_data_size (@code{int} mx=@code{1}, @code{int} my=@code{1}, @code{int} mz=@code{1})
@end ifclear
Default constructor. Allocates the memory for data array and initializes it by zero.
@end deftypefn

@anchor{var}
@deftypefn {MGL command} {} var dat @code{num v1 [v2=nan]}
Creates new variable with name @var{dat} for one-dimensional array of size @var{num}. Array elements are equidistantly distributed in range [@var{v1}, @var{v2}]. If @var{v2}=@code{nan} then @var{v2=v1} is used.
@end deftypefn

@anchor{list}
@deftypefn {MGL command} {} list dat @code{v1 ...}
Creates new variable with name @var{dat} and fills it by numeric values of command arguments @code{v1 ...}. Command can create one-dimensional and two-dimensional arrays with arbitrary values. For creating 2d array the user should use delimiter @samp{|} which means that the following values lie in next row. Array sizes are [maximal of row sizes * number of rows]. For example, command @code{list 1 | 2 3} creates the array [1 0; 2 3]. Note, that the maximal number of arguments is 1000.
@end deftypefn
@deftypefn {MGL command} {} list dat d1 ...
Creates new variable with name @var{dat} and fills it by data values of arrays of command arguments @var{d1 ...}. Command can create two-dimensional or three-dimensional (if arrays in arguments are 2d arrays) arrays with arbitrary values. Minor dimensions of all arrays in arguments should be equal to dimensions of first array d1. In the opposite case the argument will be ignored. Note, that the maximal number of arguments is 1000.
@end deftypefn

@anchor{copy}
@deftypefn {MGL command} {} copy dat1 dat2 ['eq'='']
@deftypefnx {MGL command} {} copy dat1 @code{val}
@ifclear UDAV
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const mglData &}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const mglData *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const mglDataA *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{int} size, @code{const float *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{int} size, @code{int} cols, @code{const float *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{int} size, @code{const double *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{int} size, @code{int} cols, @code{const double *}dat2)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const double *}dat2, @code{int} size)
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const double *}dat2, @code{int} size, @code{int} cols)
@end ifclear
Copy constructor. Allocates the memory for data array and copy values from other array. At this, if parameter @var{eq} is specified then the data will be modified by corresponding formula similarly to @ref{fill} function.
@end deftypefn

@anchor{read}
@deftypefn {MGL command} {} read dat 'fname'
@ifclear UDAV
@deftypefnx {Constructor on @code{mglData}} {} mglData (@code{const char *}fname)
@deftypefnx {C function} @code{HMDT} mgl_create_data_file (@code{const char *}fname)
@end ifclear
Reads data from tab-separated text file with auto determining sizes of the data.
@end deftypefn

@anchor{delete}
@deftypefn {MGL command} {} delete dat
@ifclear UDAV
@deftypefnx {Destructor on @code{mglData}} {} ~mglData ()
@deftypefnx {C function} @code{void} mgl_delete_data (@code{HMDT} dat)
@end ifclear
Deletes the instance of class mglData.
@end deftypefn

@ifclear UDAV

@deftypefn {Method on @code{mglData}} @code{void} Create (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1})
@deftypefnx {C function} @code{void} mgl_data_create (@code{HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
Creates or recreates the array with specified size and fills it by zero. This function does nothing if one of parameters @var{mx}, @var{my}, @var{mz} is zero or negative.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const float *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
@deftypefnx {Method on @code{mglData}} @code{void} Set (@code{const double *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
@deftypefnx {C function} @code{void} mgl_data_set_float (@code{HMDT} dat, @code{const float *}A, @code{int} NX, @code{int} NY, @code{int} NZ)
@deftypefnx {C function} @code{void} mgl_data_set_double (@code{HMDT} dat, @code{const double *}A, @code{int} NX, @code{int} NY, @code{int} NZ)
Allocates memory and copies the data from the @strong{flat} @code{float*} or @code{double*} array.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const float **}A, @code{int} N1, @code{int} N2)
@deftypefnx {Method on @code{mglData}} @code{void} Set (@code{const double **}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_float2 (@code{HMDT} dat, @code{const float **}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_double2 (@code{HMDT} dat, @code{const double **}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{float**} or @code{double**} array with dimensions @var{N1}, @var{N2}, i.e. from array defined as @code{float a[N1][N2];}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const float ***}A, @code{int} N1, @code{int} N2)
@deftypefnx {Method on @code{mglData}} @code{void} Set (@code{const double ***}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_float3 (@code{HMDT} dat, @code{const float ***}A, @code{int} N1, @code{int} N2)
@deftypefnx {C function} @code{void} mgl_data_set_double3 (@code{HMDT} dat, @code{const double ***}A, @code{int} N1, @code{int} N2)
Allocates memory and copies the data from the @code{float***} or @code{double***} array with dimensions @var{N1}, @var{N2}, @var{N3}, i.e. from array defined as @code{float a[N1][N2][N3];}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{gsl_vector *}v)
@deftypefnx {C function} @code{void} mgl_data_set_vector (@code{HMDT} dat, @code{gsl_vector *}v)
Allocates memory and copies the data from the @code{gsl_vector *} structure.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Set (@code{gsl_matrix *}m)
@deftypefnx {C function} @code{void} mgl_data_set_matrix (@code{HMDT} dat, @code{gsl_matrix *}m)
Allocates memory and copies the data from the @code{gsl_matrix *} structure.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const mglData &}from)
@deftypefnx {C function} @code{void} mgl_data_set (@code{HMDT} dat, @code{HCDT} from)
Copies the data from mglData instance @var{from}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const std::vector<int> &}d)
@deftypefnx {Method on @code{mglData}} @code{void} Set (@code{const std::vector<float> &}d)
@deftypefnx {Method on @code{mglData}} @code{void} Set (@code{const std::vector<double> &}d)
Allocates memory and copies the data from the @code{std::vector<T>} array.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Set (@code{const char *}str, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
@deftypefnx {C function} @code{void} mgl_data_set_values (@code{const char *}str, @code{int} NX, @code{int} NY, @code{int} NZ)
Allocates memory and scanf the data from the string.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Link (@code{const mglData &}from)
@deftypefnx {Method on @code{mglData}} @code{void} Link (@code{const float *}A, @code{int} NX, @code{int} NY=@code{1}, @code{int} NZ=@code{1})
@deftypefnx {C function} @code{void} mgl_data_link (@code{HMDT} dat, @code{const float *}A, @code{int} NX, @code{int} NY, @code{int} NZ)
Link external data array, i.e. don't delete it at exit.
@end deftypefn

@end ifclear

@c ------------------------------------------------------------------
@node Fill, Rearrange, Data creation, Data processing
@section Fill
@cindex Fill
@cindex Modify

@deftypefn {Method on @code{mglData}} @code{void} Fill (@code{float} x1, @code{float} x2, @code{char} dir=@code{'x'})
@deftypefnx {C function} @code{void} mgl_data_fill (@code{HMDT} dat, @code{float} x1, @code{float} x2, @code{char} dir)
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Fill (@code{const char *}eq, @code{mglPoint} Min, @code{mglPoint} Max, @code{const mglData *}vdat=0, @code{const mglData *}wdat=0)
@deftypefnx {C function} @code{void} mgl_data_fill (@code{HMGL} gr, @code{HMDT} dat, @code{const char *}eq, @code{const HMDT *}vdat, @code{const HMDT *}wdat)
Fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in range @var{Min} x @var{Max} (in difference from @code{Modify} functions). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat} which can be @code{NULL} (i.e. can be omitted).
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Modify (@code{const char *}eq, @code{int} dim=@code{0})
@deftypefnx {Method on @code{mglData}} @code{void} Modify (@code{const char *}eq, @code{const mglData &}v)
@deftypefnx {Method on @code{mglData}} @code{void} Modify (@code{const char *}eq, @code{const mglData &}v, @code{const mglData &}w)
@deftypefnx {C function} @code{void} mgl_data_modify (@code{HMDT} dat, @code{const char *}eq, @code{int} dim)
@deftypefnx {C function} @code{void} mgl_data_modify_vw (@code{HMDT} dat, @code{const char *}eq, @code{HCDT} v, @code{HCDT} w)
Fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in range [0,1] (in difference from @code{Fill} functions). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat} which can be @code{NULL} (i.e. can be omitted). If @var{dim}>0 is specified then modification will be fulfilled only for slices >=@var{dim}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Put (@code{float} val, @code{int} i=@code{-1}, @code{int} j=@code{-1}, @code{int} k=@code{-1})
@deftypefnx mglData @code{void} mgl_data_put_val (@code{HMDT} a, @code{float} val, @code{int} i, @code{int} j, @code{int} k)
Function sets value(s) of array a[@var{i}, @var{j}, @var{k}] = @var{val}. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the value @var{val} to whole range in corresponding direction(s). For example, @code{Put(val,-1,0,-1);} sets a[i,0,j]=@var{val} for i=0...(nx-1), j=0...(nz-1).
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Put (@code{const mglData &}v, @code{int} i=@code{-1}, @code{int} j=@code{-1}, @code{int} k=@code{-1})
@deftypefnx mglData @code{void} mgl_data_put_dat (@code{HMDT} a, @code{HCDT} v, @code{int} i, @code{int} j, @code{int} k)
Function copies value(s) from array @var{v} to the range of original array. Negative indexes @var{i}, @var{j}, @var{k}=-1 set the range in corresponding direction(s). At this minor dimensions of array @var{v} should be large than corresponding dimensions of this array. For example, @code{Put(v,-1,0,-1);} sets a[i,0,j]=v.ny>nz ? v[i,j] : v[i], where i=0...(nx-1), j=0...(nz-1) and condition v.nx>=nx is true.
@end deftypefn



@c ------------------------------------------------------------------
@node Rearrange, File I/O, Fill, Data processing
@section Rearrange
@cindex Rearrange
@cindex Extend
@cindex Transpose
@cindex Squeeze
@cindex Crop
@cindex InsertRows
@cindex InsertColumns
@cindex InsertSlices
@cindex DeleteRows
@cindex DeleteColumns
@cindex DeleteSlices
@cindex Insert
@cindex Delete

@deftypefn {Method on @code{mglData}} @code{void} Rearrange (@code{int} mx, @code{int} my=@code{0}, @code{int} mz=@code{0})
@deftypefnx {C function} @code{void} mgl_data_rearrange (@code{HMDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Extend (@code{int} n1, @code{int} n2=@code{0})
@deftypefnx {C function} @code{void} mgl_data_extend (@code{HMDT} dat, @code{int} n1, @code{int} n2)
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Transpose (@code{const char *}dim=@code{"yx"})
@deftypefnx {C function} @code{void} mgl_data_transpose (@code{const char *}dim)
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This function may be useful also for the reading of one-dimensional data.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Squeeze (@code{int} rx, @code{int} ry=@code{1}, @code{int} rz=@code{1}, @code{bool} smooth=@code{false})
@deftypefnx {C function} @code{void} mgl_data_squeeze (@code{HMDT} dat, @code{int} rx, @code{int} ry, @code{int} rz, @code{int} smooth)
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly. Parameter @var{smooth} set to use smoothing
@iftex
(i.e. @math{a_{out}[i]=\sum_{j=i,i+r}a[j]/r}) or not (i.e. @math{a_{out}[i]=a[j*r]}).
@end iftex
@ifnottex
(i.e. out[i]=\sum_@{j=i,i+r@} a[j]/r) or not (i.e. out[i]=a[j*r]).
@end ifnottex
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Crop (@code{int} n1, @code{int} n2, @code{char} dir=@code{'x'})
@deftypefnx {C function} @code{void} mgl_data_crop (@code{HMDT} dat, @code{int} n1, @code{int} n2, @code{char} dir)
Cuts off edges of the data @var{i}<@var{n1} and @var{i}>@var{n2} if @var{n2}>0 or @var{i}>@code{n[xyz]}-@var{n2} if @var{n2}<=0 along direction @var{dir}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} InsertRows (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} rows (slice along y-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} InsertColumns (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} columns (slice along x-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} InsertSlices (@code{int} at, @code{int} num=@code{1}, @code{const char *}eq=@code{NULL})
Insert @var{num} slices (slice along z-direction) at position @var{at} and fill it by formula @var{eq} (if @var{eq}!=0) or by zeros.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} DeleteRows (@code{int} at, @code{int} num=@code{1})
Delete @var{num} rows (slice along y-direction) at position @var{at}.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} DeleteColumns (@code{int} at, @code{int} num=@code{1})
Delete @var{num} columns (slice along x-direction) at position @var{at}.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} DeleteSlices (@code{int} at, @code{int} num=@code{1})
Delete @var{num} slices (slice along z-direction) at position @var{at}.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{void} Insert (@code{char} dir, @code{int} pos=@code{0}, @code{int} num=@code{1})
@deftypefnx {C function} @code{void} mgl_data_insert (@code{HMDT} dat, @code{char} dir, @code{int} pos, @code{char} num)
Insert @var{num} slices along @var{dir}-direction at position @var{pos} and fill it by zeros.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Delete (@code{char} dir, @code{int} pos=@code{0}, @code{int} num=@code{1})
@deftypefnx {C function} @code{void} mgl_data_delete (@code{HMDT} dat, @code{char} dir, @code{int} pos, @code{char} num)
Delete @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deftypefn

@c ------------------------------------------------------------------
@node File I/O, Make another data, Rearrange, Data processing
@section File I/O
@cindex Read
@deftypefn {Method on @code{mglData}} @code{void} Read (@code{const char *}fname)
@deftypefnx {C function} @code{void} mgl_data_read (@code{HMDT} dat, @code{const char *}fname)
Reads data from tab-separated text file with auto determining sizes of the data.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} Read (@code{const char *}fname, @code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1})
@deftypefnx {C function} @code{void} mgl_data_read_dim (@code{HMDT} dat, @code{const char *}fname, @code{int} mx, @code{int} my, @code{int} mz)
Reads data from text file with specified data sizes. This function does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deftypefn
@cindex ReadMat
@deftypefn {Method on @code{mglData}} @code{void} ReadMat (@code{const char *}fname, @code{int} dim=@code{2})
@deftypefnx {C function} @code{void} mgl_data_read_mat (@code{HMDT} dat, @code{const char *}fname, @code{int} dim)
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deftypefn

@cindex ReadRange
@deftypefn {Method on @code{mglData}} @code{void} ReadRange (@code{const char *}templ, @code{float} from, @code{float} to, @code{float} step=@code{1.f}, @code{bool} as_slice=@code{false})
Join data arrays from several text files. The file names are determined by function call @code{sprintf(fname,templ,val);}, where @var{val} changes from @var{from} to @var{to} with step @var{step}. The data load one-by-one in the same slice if @var{as_slice}=@code{false} or as slice-by-slice if @var{as_slice}=@code{true}.
@end deftypefn
@cindex ReadAll
@deftypefn {Method on @code{mglData}} @code{void} ReadAll (@code{const char *}templ, @code{bool} as_slice=@code{false})
Join data arrays from several text files which filenames satisfied the template @var{templ} (for example, @var{templ}=@code{"t_*.dat"}). The data load one-by-one in the same slice if @var{as_slice}=@code{false} or as slice-by-slice if @var{as_slice}=@code{true}.
@end deftypefn

@cindex Save
@deftypefn {Method on @code{mglData}} @code{void} Save (@code{const char *}fname, @code{int} ns=@code{-1}) @code{const}
@deftypefnx {C function} @code{void} mgl_data_save (@code{HCDT} dat, @code{const char *}fname, @code{int} ns)
Saves the whole data array (for @var{ns}=@code{-1}) or only @var{ns}-th slice to text file.
@end deftypefn

@cindex ReadHDF
@deftypefn {Method on @code{mglData}} @code{void} ReadHDF (@code{const char *}fname, @code{const char *}dname)
Reads data array named @var{dname} from HDF5 or HDF4 file. This function does nothing if NO_HDF5|NO_HDF4 was defined during library compilation.
@end deftypefn
@cindex SaveHDF
@deftypefn {Method on @code{mglData}} @code{void} SaveHDF (@code{const char *}fname, @code{const char *}dname, @code{bool} rewrite=@code{false}) @code{const}
Saves data array named @var{dname} from HDF5 or HDF4 file. This function does nothing if NO_HDF5|NO_HDF4 was defined during library compilation.
@end deftypefn

@cindex Import
@deftypefn {Method on @code{mglData}} @code{void} Import (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{1})
@deftypefnx {C function} @code{void} mgl_data_import (@code{HMDT} dat, @code{const char *}fname, @code{const char *}scheme, @code{float} v1, float v2)
Reads data from bitmap file (now support only PNG format). The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{scheme} (@pxref{Color scheme}).
@end deftypefn
@cindex Export
@deftypefn {Method on @code{mglData}} @code{void} Export (@code{const char *}fname, @code{const char *}scheme, @code{float} v1=@code{0}, float v2=@code{0}, @code{int} ns=@code{-1}) const
@deftypefnx {C function} @code{void} mgl_data_export (@code{HMDT} dat, @code{const char *}fname, @code{const char *}scheme, @code{float} v1, float v2, @code{int} ns) const
Saves data matrix (or @code{ns}-th slice for 3d data) to bitmap file (now support only PNG format). The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{scheme} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deftypefn

@c ------------------------------------------------------------------
@node Make another data, Change data, File I/O, Data processing
@section Make another data

@cindex SubData
@deftypefn {Method on @code{mglData}} @code{mglData} SubData (@code{int} xx, @code{int} yy=@code{-1}, @code{int} zz=@code{-1}) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_subdata (@code{HCDT} dat, @code{int} xx, @code{int} yy, @code{int} zz)
Extracts sub-array data from the original data array keeping fixed positive index. For example @code{SubData(-1,2)} extracts 3d row (indexes are zero based), @code{SubData(4,-1)} extracts 5th column, @code{SubData(-1,-1,3)} extracts 4th slice and so on.
@end deftypefn

@deftypefn {Method on @code{mglData}} @code{mglData} SubData (@code{const mglData &}xx, @code{const mglData &}yy, @code{const mglData &}zz) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_subdata_ext (@code{HCDT} dat, @code{HCDT} xx, @code{HCDT} yy, @code{HCDT} zz)
Extracts sub-array data from the original data array for indexes specified by arrays @var{xx}, @var{yy}, @var{zz} (indirect access). The resulting array have the same dimensions as input arrays for 2D and 3D arguments. This function work like previous one for 1D arguments (or numbers). The dimensions of all argument must be the same if they are 2D or 3D arrays.
@end deftypefn

@cindex Column
@deftypefn {Method on @code{mglData}} @code{mglData} Column (@code{const char *}eq) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_column (@code{HCDT} dat, @code{const char *}eq)
Get column (or slice) of the data filled by formula @var{eq} of other named columns. For example, @code{Column("n*w^2/exp(t)");}. The column ids must be defined first by @code{SetColumnId()} function.
@end deftypefn

@cindex SetColumnId
@deftypefn {Method on @code{mglData}} @code{void} SetColumnId (@code{const char *}ids)
@deftypefnx {C function} @code{void} mgl_data_set_id (@code{HMDT} dat, @code{const char *}ids)
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deftypefn

@cindex Trace
@deftypefn {Method on @code{mglData}} @code{mglData} Trace () @code{const}
Gets array of diagonal elements a[i,i] (for 2D case) or a[i,i,i] (for 3D case) where i=0...nx-1. Function return copy of itself for 1D case. Data array must have dimensions ny,nz >= nx or ny,nz = 1.
@end deftypefn

@cindex Hist
@deftypefn {Method on @code{mglData}} @code{mglData} Hist (@code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0}) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_hist (@code{HCDT} dat, @code{int} n, @code{float} v1, @code{float} v2, @code{int} nsub)
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{mglData} Hist (@code{const mglData &}w, @code{int} n, @code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{int} nsub=@code{0}) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_hist_w (@code{HCDT} dat, @code{HCDT} w, @code{int} n, @code{float} v1, @code{float} v2, @code{int} nsub)
Creates @var{n}-th points distribution of the data values in range [@var{v1}, @var{v2}]. Array @var{w} specifies weights of the data elements. Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deftypefn

@cindex Momentum
@deftypefn {Method on @code{mglData}} @code{mglData} Momentum (@code{char} dir, @code{const char *}how) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_momentum (@code{HCDT} dat, @code{char} dir, @code{const char *}how)
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum. The momentum is defined like as
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) a_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
@end ifnottex
if @var{var}=@samp{z} and so on. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1].
@end deftypefn

@cindex Sum
@deftypefn {Method on @code{mglData}} @code{mglData} Sum (@code{const char *}dir) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_sum (@code{HCDT} dat, @code{const char *}dir)
Gets array which is the result of summation in given direction or direction(s).
@end deftypefn
@cindex Max
@deftypefn {Method on @code{mglData}} @code{mglData} Max (@code{const char *}dir) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_max_dir (@code{HCDT} dat, @code{const char *}dir)
Gets array which is the maximal data values in given direction or direction(s).
@end deftypefn
@cindex Min
@deftypefn {Method on @code{mglData}} @code{mglData} Min (@code{const char *}dir) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_min_dir (@code{HCDT} dat, @code{const char *}dir)
Gets array which is the maximal data values in given direction or direction(s).
@end deftypefn

@cindex Combine
@deftypefn {Method on @code{mglData}} @code{mglData} Combine (@code{const mglData &}a) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_combine (@code{HCDT} dat, @code{HCDT} a)
Return direct multiplication of arrays (like, res[i,j] = this[i]*a[j] and so on).
@end deftypefn

@cindex Evaluate
@deftypefn {Method on @code{mglData}} @code{mglData} Evaluate (@code{const mglData &}idat, @code{bool} norm=@code{true}) @code{const}
@deftypefnx {Method on @code{mglData}} @code{mglData} Evaluate (@code{const mglData &}idat, @code{const mglData &}jdat, @code{bool} norm=@code{true}) @code{const}
@deftypefnx {Method on @code{mglData}} @code{mglData} Evaluate (@code{const mglData &}idat, @code{const mglData &}jdat, @code{const mglData &}kdat, @code{bool} norm=@code{true}) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_evaluate_i (@code{HCDT} dat, @code{HCDT} idat, @code{int} norm)
@deftypefnx {C function} @code{HMDT} mgl_data_evaluate_ij (@code{HCDT} dat, @code{HCDT} idat, @code{HCDT} jdat, @code{int} norm)
@deftypefnx {C function} @code{HMDT} mgl_data_evaluate_ijk (@code{HCDT} dat, @code{HCDT} idat, @code{HCDT} jdat, @code{HCDT} kdat, @code{int} norm)
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in ranges [0,nx], [0,ny], [0,nz] correspondingly.
@end deftypefn

@cindex Resize
@deftypefn {Method on @code{mglData}} @code{mglData} Resize (@code{int} mx, @code{int} my=@code{1}, @code{int} mz=@code{1}, @code{float} x1=@code{0}, @code{float} x2=@code{1}, @code{float} y1=@code{0}, @code{float} y2=@code{1}, @code{float} z1=@code{0}, @code{float} z2=@code{1}) @code{const}
@deftypefnx {C function} @code{HMDT} mgl_data_resize (@code{HCDT} dat, @code{int} mx, @code{int} my, @code{int} mz)
@deftypefnx {C function} @code{HMDT} mgl_data_resize_box (@code{HCDT} dat, @code{int} mx, @code{int} my, @code{int} mz, @code{float} x1, @code{float} x2, @code{float} y1, @code{float} y2, @code{float} z1, @code{float} z2)
Resizes the data to new size @var{mx}, @var{my}, @var{mz} from box (part) [@var{x1},@var{x2}] x [@var{y1},@var{y2}] x [@var{z1},@var{z2}] of original array. Initially x,y,z coordinates are supposed to be in [0,1].
@end deftypefn

@c ------------------------------------------------------------------
@node Change data, Interpolation, Make another data, Data processing
@section Change data

These functions change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondengly.

@cindex CumSum
@deftypefn {Method on @code{mglData}} @code{void} CumSum (@code{const char *}dir)
@deftypefnx {C function} @code{void} mgl_data_cumsum (@code{HMDT} dat, @code{const char *}dir)
Cumulative summation of the data in given direction or directions.
@end deftypefn

@cindex Integral
@deftypefn {Method on @code{mglData}} @code{void} Integral (@code{const char *}dir)
@deftypefnx {C function} @code{void} mgl_data_integral (@code{HMDT} dat, @code{const char *}dir)
Integrates (like cumulative summation) the data in given direction or directions.
@end deftypefn

@cindex Diff
@deftypefn {Метод класса @code{mglData}} @code{void} Diff (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_diff (@code{HMDT} dat, @code{const char *}dir)
Differentiates the data in given direction or directions.
@end deftypefn

@deftypefn {Метод класса @code{mglData}} @code{void} Diff (@code{const mglData &}x, @code{const mglData &}y)
@deftypefnx {Метод класса @code{mglData}} @code{void} Diff (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z)
@deftypefnx {Функция С} @code{void} mgl_data_diff_par (@code{HMDT} dat, @code{HCDT} x, @code{HCDT}y, @code{HCDT}z)
Differentiates the data specified parametrically in direction @var{x} with @var{y}, @var{z}=constant. Parametrical differentiation uses the formula (for 2D case): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)} where @math{a_i=da/di, a_j=da/dj} denotes usual differentiation along 1st and 2nd dimensions. The similar formula is used for 3D case. Note, that you may change the order of arguments -- for example, if you have 2D data a(i,j) which depend on coordinates @{x(i,j), y(i,j)@} then usual derivative along @samp{x} will be @code{Diff(x,y);} and usual derivative along @samp{y} will be @code{Diff(y,x);}.
@end deftypefn


@cindex Diff2
@deftypefn {Метод класса @code{mglData}} @code{void} Diff2 (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_diff2 (@code{const char *}dir)
Double-differentiates (like Laplace operator) the data in given direction.
@end deftypefn

@cindex SinFFT
@deftypefn {Метод класса @code{mglData}} @code{void} SinFFT (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_sinfft (@code{HMDT} dat, @code{const char *}dir)
Do Sine transform of the data in given direction or directions. The Sine transform is @math{\sum a_i \sin(k i)}.
@end deftypefn

@cindex CosFFT
@deftypefn {Метод класса @code{mglData}} @code{void} CosFFT (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_cosfft (@code{HMDT} dat, @code{const char *}dir)
Do Cosine transform of the data in given direction or directions. The Cosine transform is @math{\sum a_i \cos(k i)}.
@end deftypefn

@cindex Hankel
@deftypefn {Метод класса @code{mglData}} @code{void} Hankel (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_hankel (@code{HMDT} dat, @code{const char *}dir)
Do Hankel transform of the data in given direction or directions. The Hankel transform is @math{\sum a_i J_0(k i)}.
@end deftypefn


@cindex Swap
@deftypefn {Метод класса @code{mglData}} @code{void} Swap (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_swap (@code{HMDT} dat, @code{const char *}dir)
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deftypefn

@cindex Roll
@deftypefn {Метод класса @code{mglData}} @code{void} Roll (@code{char} dir, @code{num})
@deftypefnx {Функция С} @code{void} mgl_data_roll (@code{HMDT} dat, @code{char} dir, @code{num})
Rolls the data along direction @var{dir}. Resulting array will be out[i] = ini[(i+num)%nx] if @code{dir='x'}.
@end deftypefn

@cindex Mirror
@deftypefn {Метод класса @code{mglData}} @code{void} Mirror (@code{const char *}dir)
@deftypefnx {Функция С} @code{void} mgl_data_mirror (@code{HMDT} dat, @code{const char *}dir)
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deftypefn

@cindex Sew
@deftypefn {Метод класса @code{mglData}} @code{void} Sew (@code{const char *}dir, @code{float} da=@code{2*M_PI})
@deftypefnx {Функция С} @code{void} mgl_data_sew (@code{HMDT} dat, @code{const char *}dir, @code{float} da)
Remove value steps (like phase jumps after inverse trigonometric functions) with period @var{da} in given direction.
@end deftypefn

@cindex Smooth
@deftypefn {Метод класса @code{mglData}} @code{void} Smooth (@code{int} Type, @code{const char *}dir, @code{float} delta=@code{0})
@deftypefnx {Функция С} @code{void} mgl_data_smooth (@code{HMDT} dat, @code{int} Type, @code{float} delt, @code{const char *}dirs)
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @code{SMOOTH_NONE} does nothing for @var{delta}=0 or approaches data to zero with the step @var{delta}, @code{SMOOTH_LINE_3} linear averaging by 3 points, @code{SMOOTH_LINE_5} linear averaging by 5 points, @code{SMOOTH_QUAD_5} quadratic averaging by 5 points. Parameter @var{delta} forbids to change values of array more than @var{delta} from the original ones. String @var{dirs} specifies the dimensions which will be smoothed. It may contain characters: 'x' for 1st dimension, 'y' for 2nd dimension, 'z' for 3d dimension.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{void} Smooth (@code{const char *}dir)
Smooths the data on specified direction(s). This is the same as @code{Smooth()} but argument @var{Type} is specified in string as @samp{0} for @code{SMOOTH_NONE}, @samp{3} for @code{SMOOTH_LINE_3}, @samp{5} for @code{SMOOTH_LINE_5}. If string @var{dir} don't contain digits @samp{035} then @var{Type}=@code{SMOOTH_QUAD_5} is used.
@end deftypefn

@cindex Envelop
@deftypefn {Метод класса @code{mglData}} @code{void} Envelop (@code{char} dir=@code{'x'})
@deftypefnx {Функция С} @code{void} mgl_data_envelop (@code{HMDT} dat, @code{char} dir)
Find envelop for data values along direction @var{dir}.
@end deftypefn

@cindex Norm
@deftypefn {Метод класса @code{mglData}} @code{void} Norm (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{bool} sym=@code{false}, @code{int} dim=@code{0})
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deftypefn

@cindex NormSl
@deftypefn {Метод класса @code{mglData}} @code{void} NormSl (@code{float} v1=@code{0}, @code{float} v2=@code{1}, @code{char} dir=@code{'z'}, @code{bool} keep_en=@code{true}, @code{bool} sym=@code{false})
@deftypefnx {Функция С} @code{void} mgl_data_norm_slice (@code{HMDT} dat, @code{float} v1, @code{float} v2, @code{char} dir, @code{int} keep_en, @code{int} sym)
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{true} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep_en} is set then maximal value of k-th slice will be limited by
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deftypefn

@c ------------------------------------------------------------------
@node Interpolation, Informational functions, Change data, Data processing
@section Interpolation
@cindex Spline
@deftypefn {Method on @code{mglData}} @code{float} Spline (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
@deftypefnx {C function} @code{float} mgl_data_spline (@code{HCDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by cubic spline to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypefn
@cindex Spline1
@deftypefn {Method on @code{mglData}} @code{float} Spline1 (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
@deftypefnx {C function} @code{float} mgl_data_spline1 (@code{HCDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by cubic spline to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypefn
@cindex Linear
@deftypefn {Method on @code{mglData}} @code{float} Linear (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
@deftypefnx {C function} @code{float} mgl_data_linear (@code{HCDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by linear function to the given point @var{x} in [0...nx-1], @var{y} in [0...ny-1], @var{z} in [0...nz-1].
@end deftypefn
@cindex Linear1
@deftypefn {Method on @code{mglData}} @code{float} Linear1 (@code{float} x, @code{float} y=@code{0}, @code{float} z=@code{0}) @code{const}
@deftypefnx {C function} @code{float} mgl_data_linear1 (@code{HCDT} dat, @code{float} x, @code{float} y, @code{float} z)
Interpolates data by linear function to the given point @var{x}, @var{y}, @var{z} which assumed to be normalized in range [0, 1].
@end deftypefn
@cindex v
@deftypefn {Method on @code{mglData}} @code{float} v (@code{int} i, @code{int} j=@code{0}, @code{int} k=@code{0}) @code{const}
@deftypefnx {C function} @code{float} mgl_data_get_value (@code{HCDT} dat, @code{int} i, @code{int} j, @code{int} k)
Gets the value in specified cell of the data with border checking.
@end deftypefn
@cindex Spline5
@deftypefn {Method on @code{mglData}} @code{float} Spline5 (@code{float} x, @code{float} y, @code{float} z, @code{float} &dx, @code{float} &dy, @code{float} &dz) @code{const}
Interpolate by 5-th order splain the data to given point @var{x}, @var{y}, @var{z} which normalized in range [0, 1] and evaluate its derivatives.
@end deftypefn

@deftypefn {C function} @code{float *} mgl_data_value (@code{HMDT} dat, @code{int} i, @code{int} j, @code{int} k)
Gets the pointer to data element.
@end deftypefn
@deftypefn {C function} @code{const float *} mgl_data_data (@code{HCDT} dat)
Gets the pointer to internal data array.
@end deftypefn

@c ------------------------------------------------------------------
@node Informational functions, Operators, Interpolation, Data processing
@section Informational functions
@cindex PrintInfo
@deftypefn {Метод класса @code{mglData}} @code{void} PrintInfo (@code{char *}buf, @code{bool} all=@code{false}) @code{const}
Print information about the data (sizes and momentum) to string @var{buf}. Parameter @var{all} set to print most of information (if @code{true}) or just basic one like dimensions, maximal an minimal values.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{void} PrintInfo (@code{FILE *}fp) @code{const}
Print information about the data (sizes and momentum) to FILE (for example, stdout).
@end deftypefn

@cindex Maximal
@deftypefn {Метод класса @code{mglData}} @code{float} Maximal () @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_max (@code{HCDT} dat)
Gets maximal value of the data.
@end deftypefn
@cindex Minimal
@deftypefn {Метод класса @code{mglData}} @code{float} Minimal () @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_min (@code{HMDT} dat) @code{const}
Gets minimal value of the data.
@end deftypefn

@deftypefn {Метод класса @code{mglData}} @code{float} Maximal (@code{int} &i, @code{int} &j, @code{int} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_max_int (@code{HCDT} dat, @code{int} *i, @code{int} *j, @code{int} *k)
Gets maximal value of the data and its position in the array to variables @var{i}, @var{j}, @var{k}.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{float} Minimal (@code{int} &i, @code{int} &j, @code{int} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_min_int (@code{HCDT} dat, @code{int} *i, @code{int} *j, @code{int} *k)
Gets minimal value of the data and its position in the array to variables @var{i}, @var{j}, @var{k}.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{float} Maximal (@code{float} &i, @code{float} &j, @code{float} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_max_real (@code{HCDT} dat, @code{float} *x, @code{float} *y, @code{float} *z)
Gets maximal value of the data and its approximated (interpolated) position to variables @var{i}, @var{j}, @var{k}.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{float} Minimal (@code{float} &i, @code{float} &j, @code{float} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_min_real (@code{HCDT} dat, @code{float} *x, @code{float} *y, @code{float} *z)
Gets minimal value of the data and its approximated (interpolated) position to variables @var{i}, @var{j}, @var{k}.
@end deftypefn

@cindex Momentum
@deftypefn {Метод класса @code{mglData}} @code{float} Momentum (@code{char} dir, @code{float} &m, @code{float} &w) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_momentum_mw (@code{HCDT} dat, @code{char} dir, @code{float} *m, @code{float} *w)
Gets zero-momentum (energy, @math{I=\sum a_i}) and write first momentum (median, @math{m = \sum \xi_i a_i/I}) and second momentum (width, @math{w^2 = \sum (\xi_i-m)^2 a_i/I}) to variables. Here @math{\xi} is corresponding coordinate if @var{dir} is @samp{'x'}, @samp{'y'} or @samp{'z'}. Otherwise median is @math{m = \sum a_i/N}, width is @math{w^2 = \sum (a_i-m)^2/N}.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{float} Momentum (@code{char} dir, @code{float} &m, @code{float} &w, @code{float} &s, @code{float} &k) @code{const}
Gets zero-momentum (energy, @math{I=\sum a_i}) and write first momentum (median, @math{m = \sum \xi_i a_i/I}), second momentum (width, @math{w^2 = \sum (\xi_i-m)^2 a_i/I}), third momentum (skewness, @math{s = \sum (\xi_i-m)^3 a_i/ I w^3}) and fourth momentum (kurtosis, @math{k = \sum (\xi_i-m)^4 a_i / 3 I w^4}) to variables. Here @math{\xi} is corresponding coordinate if @var{dir} is @samp{'x'}, @samp{'y'} or @samp{'z'}. Otherwise median is @math{m = \sum a_i/N}, width is @math{w^2 = \sum (a_i-m)^2/N} and so on.
@end deftypefn

@cindex Find
@deftypefn {Метод класса @code{mglData}} @code{float} Find (@code{const char *}cond, @code{int} &i, @code{int} &j, @code{int} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_first (@code{HCDT} dat, @code{const char *}cond, @code{int} *i, @code{int} *j, @code{int} *k)
Find position (after specified in @var{i}, @var{j}, @var{k}) of first nonzero value of formula @var{cond}. Function return the data value at found position.
@end deftypefn
@cindex Last
@deftypefn {Метод класса @code{mglData}} @code{float} Last (@code{const char *}cond, @code{int} &i, @code{int} &j, @code{int} &k) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_last (@code{HCDT} dat, @code{const char *}cond, @code{int} *i, @code{int} *j, @code{int} *k)
Find position (before specified in @var{i}, @var{j}, @var{k}) of last nonzero value of formula @var{cond}. Function return the data value at found position.
@end deftypefn
@deftypefn {Метод класса @code{mglData}} @code{int} Find (@code{const char *}cond, @code{char} dir, @code{int} i=@code{0}, @code{int} j=@code{0}, @code{int} k=@code{0}) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_find (@code{HCDT} dat, @code{const char *}cond, @code{int} i, @code{int} j, @code{int} k)
Return position of first in direction @var{dir} nonzero value of formula @var{cond}. The search is started from point @{i,j,k@}.
@end deftypefn
@cindex FindAny
@deftypefn {Метод класса @code{mglData}} @code{bool} FindAny (@code{const char *}cond) @code{const}
@deftypefnx {Функция С} @code{float} mgl_data_find_any (@code{HCDT} dat, @code{const char *}cond)
Determines if any nonzero value of formula in the data array.
@end deftypefn

@c ------------------------------------------------------------------
@node Operators, Global functions, Informational functions, Data processing
@section Operators

@deftypefn {Method on @code{mglData}} @code{void} operator= (@code{const mglData &}d)
Copies data from other variable.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator*= (@code{const mglData &}d)
@deftypefnx {C function} @code{void} mgl_data_mul_dat (@code{HMDT} dat, @code{HCDT} d)
Multiplies the data by the other one for each element.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator/= (@code{const mglData &}d)
@deftypefnx {C function} @code{void} mgl_data_div_dat (@code{HMDT} dat, @code{HCDT} d)
Divides the data by the other one for each element.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator+= (@code{const mglData &}d)
@deftypefnx {C function} @code{void} mgl_data_add_dat (@code{HMDT} dat, @code{HCDT} d)
Adds the other data.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator-= (@code{const mglData &}d)
@deftypefnx {C function} @code{void} mgl_data_sub_dat (@code{HMDT} dat, @code{HCDT} d)
Subtracts the other data.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator*= (@code{float} d)
@deftypefnx {C function} @code{void} mgl_data_mul_num (@code{HMDT} dat, @code{float} d)
Multiplies each element by the number.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator/= (@code{float} d)
@deftypefnx {C function} @code{void} mgl_data_div_num (@code{HMDT} dat, @code{float} d)
Divides each element by the number.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator+= (@code{float} d)
@deftypefnx {C function} @code{void} mgl_data_add_num (@code{HMDT} dat, @code{float} d)
Adds the number to each element.
@end deftypefn
@deftypefn {Method on @code{mglData}} @code{void} operator-= (@code{float} d)
@deftypefnx {C function} @code{void} mgl_data_sub_num (@code{HMDT} dat, @code{float} d)
Subtracts the number to each element.
@end deftypefn


@deftypefn {Library Function} mglData operator+ (@code{const mglData &}a, @code{const mglData &}b)
Adds the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator+ (@code{float} a, @code{const mglData &}b)
Adds the number.
@end deftypefn
@deftypefn {Library Function} mglData operator+ (@code{const mglData &}a, @code{float} b)
Adds the number.
@end deftypefn

@deftypefn {Library Function} mglData operator- (@code{const mglData &}a, @code{const mglData &}b)
Subtracts the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator- (@code{float} a, @code{const mglData &}b)
Subtracts from the number.
@end deftypefn
@deftypefn {Library Function} mglData operator- (@code{const mglData &}a, @code{float} b)
Subtracts the number.
@end deftypefn

@deftypefn {Library Function} mglData operator* (@code{const mglData &}a, @code{const mglData &}b)
Multiplies by the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator* (@code{float} a, @code{const mglData &}b)
Multiplies by the number.
@end deftypefn
@deftypefn {Library Function} mglData operator* (@code{const mglData &}a, @code{float} b)
Multiplies by the number.
@end deftypefn

@deftypefn {Library Function} mglData operator/ (@code{const mglData &}a, @code{const mglData &}b)
Divides by the other data.
@end deftypefn
@deftypefn {Library Function} mglData operator/ (@code{const mglData &}a, @code{float} b)
Divides by the number.
@end deftypefn

@c ------------------------------------------------------------------
@node Global functions, , Operators, Data processing
@section Global functions

These functions are not methods of @code{mglData} class. However it have additional functionality to handle data. So I put it in this chapter.

@deftypefn {Global function} @code{mglData} mglTransform (@code{const mglData &}real, @code{const mglData &}imag, @code{const char *}type)
@deftypefnx {C function} @code{HMDT} mgl_transform (@code{HCDT} real, @code{HCDT} imag, @code{const char *}type)
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{s} is Sine transform, @samp{c} is Cosine transform, @samp{h} is Hankel transform, @samp{n} or @samp{ } is no transformation.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglTransformA @code{const mglData &}ampl, @code{const mglData &}phase, @code{const char *}type)
@deftypefnx {C function} @code{HMDT} mgl_transform_a @code{HCDT} ampl, @code{HCDT} phase, @code{const char *}type)
The same as previous but with specified amplitude @var{ampl} and phase @var{phase} of complex numbers.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglSTFA (@code{const mglData &}real, @code{const mglData &}imag, @code{int} dn, @code{char} dir=@code{'x'})
@deftypefnx {C function} @code{HMDT} mgl_data_stfa (@code{HCDT} real, @code{HCDT} imag, @code{int} dn,@code{char} dir)
Short time Fourier transformation for real and imaginary parts. Output  is amplitude of partial Fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deftypefn

@deftypefn {Global function} @code{mglData} mglPDE (@code{const char *}ham, @code{const mglData &}ini_re, @code{const mglData &}ini_im, @code{mglPoint} Min, @code{mglPoint} Max, @code{float} dz=@code{0.1}, @code{float} k0=@code{100})
@deftypefnx {C function} @code{HMDT} mgl_pde_solve (@code{HMGL} gr, @code{const char *}ham, @code{HCDT} ini_re, @code{HCDT} ini_im, @code{float} dz, @code{float} k0)
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{Min}, @var{Max} set the bounding box for the solution. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. You may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE sample}  @sref{PDE sample}
@end deftypefn

@deftypefn {Global function} @code{mglData} mglRay (@code{const char *}ham, @code{mglPoint} r0, @code{mglPoint} p0, @code{float} dt=@code{0.1}, @code{float} tmax=@code{10})
@deftypefnx {C function} @code{HMDT} mgl_ray_trace (@code{const char *}ham, @code{float} x0, @code{float} y0, @code{float} z0, @code{float} px, @code{float} py, @code{float} pz, @code{float} dt, @code{float} tmax)
Solves GO ray equation like dr/dt = d @var{ham}/dp, dp/dt = -d @var{ham}/dr. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordinates @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @var{r0}, @var{p0}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}. @sref{Beam tracing sample}
@end deftypefn

@deftypefn {Global function} @code{mglData} mglQO2d (@code{const char *}ham, @code{const mglData &}ini_re, @code{const mglData &}ini_im, @code{const mglData &}ray, @code{float} r=@code{1}, @code{float} k0=@code{100}, @code{mglData *}xx=@code{0}, @code{mglData *}yy=@code{0}, @code{bool} UseR=@code{true})
@deftypefnx {C function} @code{HMDT} mgl_qo2d_solve (@code{const char *}ham, @code{HCDT} ini_re, @code{HCDT} ini_im, @code{HCDT} ray, @code{float} r, @code{float} k0, @code{HMDT} xx, @code{HMDT} yy)
Solves equation du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators (see @code{mglPDE()} for details). Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{ray} set the reference ray, i.e. the ray around which the accompanied coordinate system will be maked. You may use, for example, the array created by @code{mglRay()} function. Note, that the reference ray @strong{must be} smooth enough to make accompanied coodrinates unambiguity. Otherwise errors in the solution may appear. If @var{xx} and @var{yy} are non-zero then Cartesian coordinates for each point will be written into them. See also @code{mglPDE()}. @sref{Beam tracing sample}
@end deftypefn

@deftypefn {Global function} @code{mglData} mglJacobian (@code{const mglData &}x, @code{const mglData &}y)
@deftypefnx {Global function} @code{mglData} mglJacobian (@code{const mglData &}x, @code{const mglData &}y, @code{const mglData &}z)
@deftypefnx {C function} @code{HMDT} mgl_jacobian_2d (@code{HCDT} x, @code{HCDT} y)
@deftypefnx {C function} @code{HMDT} mgl_jacobian_3d (@code{HCDT} x, @code{HCDT} y, @code{HCDT} z)
Computates the Jacobian for transformation @{i,j,k@} to @{@var{x},@var{y},@var{z}@} where initial coordinates  @{i,j,k@} are data indexes normalized in range [0,1]. The Jacobian is determined by formula det||@math{dr_\alpha/d\xi_\beta}|| where @math{r}=@{@var{x},@var{y},@var{z}@} and @math{\xi}=@{i,j,k@}. All dimensions must be the same for all data arrays. Data must be 3D if all 3 arrays @{@var{x},@var{y},@var{z}@} are specified or 2D if only 2 arrays @{@var{x},@var{y}@} are specified.
@end deftypefn

