@c ------------------------------------------------------------------
@chapter MGL language

MathGL library supports the simplest scripts for data handling and plotting. These scripts can be used independently (with the help of UDAV, mgl2png, mgl2eps, mgl2svg programs and others, @pxref{Utilities}) or in the frame of the library using.

@menu
* MGL basics::        
@ifset UDAV
* General concepts::             
@end ifset
* Graphics setup @MGL{}::        
* Axis settings @MGL{}::         
* Transformation matrix @MGL{}::  
* Export to file @MGL{}::        
* Primitives drawing @MGL{}::    
* Text printing @MGL{}::         
* Axis and Colorbar @MGL{}::     
* Legend @MGL{}::                
* 1D plotting @MGL{}::           
* 2D plotting @MGL{}::           
* 3D plotting @MGL{}::           
* Dual plotting @MGL{}::         
* Vector fields @MGL{}::         
* Other plotting @MGL{}::        
* Nonlinear fitting @MGL{}::     
* Data create @MGL{}::           
* Data filling @MGL{}::          
* Rearrange data @MGL{}::        
* File I/O @MGL{}::              
* Make another data @MGL{}::     
* Change data @MGL{}::  
* Operators @MGL{}::             
* Program flow @MGL{}::          
* Command options @MGL{}::       
* Suffixes::                    
* Utilities::                   
@end menu

@c ##################################################################
@ifset UDAV
@node  MGL basics, General concepts, , MGL interface
@end ifset
@ifclear UDAV
@node MGL basics, Graphics setup @MGL{}, , MGL interface
@end ifclear

@section MGL basics
MGL script language is rather simple. Each string is a command. First word of string is the name of command. Other words are command arguments. Command may have up to 1000 arguments (at least for now). Words are separated from each other by space or tabulation symbol. The upper or lower case of words is sufficient, i.e. variables @var{a} and @var{A} are different variables. Symbol @samp{#} starts the comment (all characters after # will be ignored). The exception is situation when @samp{#} is a part of some string. Also options can be specified after symbol @samp{;} (@pxref{Command options @MGL{}}). Symbol @samp{:} starts new command (like new line character) if it is not placed inside a string or inside brackets.

If string contain references to external parameters (substrings @samp{$0}, @samp{$1} ... @samp{$9}) or definitions (substrings @samp{$a}, @samp{$b} ... @samp{$z}) then before execution the values of parameter/definition will be substituted instead of reference. It allows to use the same MGL script for different parameters (filenames, paths, condition and so on).

Argument can be a string, a variable name or a number. 
@itemize @bullet
@item 
The string is any symbols between ordinary marks @samp{'}.

@item 
Usually variable have a name which is arbitrary combination of symbols (except spaces and @samp{'}) started from a letter and with length less than 64. A temporary array can be used as variable:
@itemize @bullet
@item 
sub-arrays (like in @ref{subdata} command) as command argument. For example, @code{a(1)} or @code{a(1,:)} or @code{a(1,:,:)} is second row, @code{a(:,2)} or @code{a(:,2,:)} is third column, @code{a(:,:,0)} is first slice and so on. Also you can extract a part of array from m-th to n-th element by code @code{a(m:n,:,:)} or just @code{a(m:n)}.

@item 
any column combinations defined by formulas, like @code{a('n*w^2/exp(t)')} if names for data columns was specified (by @ref{idset} command or in the file at string started with @code{##}).

@item 
any expression (without spaces) of existed variables produce temporary variable. For example, @samp{sqrt(dat(:,5)+1)} will produce temporary variable with data values equal to @code{tmp[i,j] = sqrt(dat[i,5,j]+1)}. 

@item 
temporary variable of higher dimensions by help of []. For example, @samp{[1,2,3]} will produce a temporary vector of 3 elements @{1, 2, 3@}; @samp{[[11,12],[21,22]]} will produce matrix 2*2 and so on. Here you can join even an arrays of the same dimensions by construction like @samp{[v1,v2,...,vn]}.

@item 
result of code for making new data (@pxref{Make another data @MGL{}}) inside @{@}. For example, @samp{@{sum dat 'x'@}} produce temporary variable which contain result of summation of @var{dat} along direction 'x'. This is the same array @var{tmp} as produced by command @samp{sum tmp dat 'x'}. You can use nested constructions, like @samp{@{sum @{max dat 'z'@} 'x'@}}.
@end itemize
Temporary variables can not be used as 1st argument for commands which create (return) the data (like @samp{new}, @samp{read}, @samp{hist} and so on).

@item 
Special names @code{nan=#QNAN, pi=3.1415926..., on=1, off=0, :=-1} are treated as number if they were not redefined by user. Variables with suffixes are treated as numbers (@pxref{Suffixes}). Names defined by @ref{define} command are treated as number. Also results of formulas with sizes 1x1x1 are treated as number (for example, @samp{pi/dat.nx}).
@end itemize
Before the first using all variables must be defined with the help of commands, like, @ref{new}, @ref{var}, @ref{list}, @ref{copy}, @ref{read}, @ref{hist}, @ref{sum} and so on (@pxref{Data create @MGL{}} and @ref{Make another data @MGL{}}). 

Command may have several set of possible arguments (for example, @code{plot ydat} and @code{plot xdat ydat}). All command arguments for a selected set must be specified. However, some arguments can have default values. These argument are printed in [], like @code{plot ydat ['stl'='' zval=nan]}. At this, the record @code{[arg1 arg2 arg3 ...]} means @code{[arg1 [arg2 [arg3 ...]]]}, i.e. you can omit only tailing arguments if you agree with its default values. For example, @code{plot ydat '' 1} or @code{plot ydat ''} is correct, but @code{plot ydat 1} is incorrect (argument @code{'stl'} is missed).

All MGL commands can be divided on several groups. I will use the following notation for a command description: command names are bold, strings are denoted by commas, variable names are italic, numbers are typewriter. Optional arguments are placed in square brackets and default values for them are shown. Detailed description of color, line styles (@pxref{Line styles}), color schemes (@pxref{Color scheme}), font types, TeX-like symbols (@pxref{Font styles}) and formulas (@pxref{Textual formulas}) can be found in corresponding section.


@c ##################################################################
@ifset UDAV
@node  General concepts, Graphics setup @MGL{}, MGL basics, MGL interface
@section General concepts

The set of MathGL features is rather rich -- just the number of basic graphics types is larger than 40. Also there are functions for data handling, plot setup and so on. In spite of it I tried to keep a similar style in command names and in the order of arguments. Mostly it is used for different drawing functions.

There are 4 most general (base) concepts:
@enumerate
@item
@strong{Every plot settings (style of lines, font, color scheme) are specified by a string.} It provides convenience for user/programmer -- short string with parameters is more comprehensible than a large set of parameters. Also it provides portability -- the strings are the same in any OS so that it is not necessary to think about argument types.
@item
@strong{All commands have ``simplified'' and ``advanced'' forms.} It is done for user</samp>&rsquo;s convenience. One needs to specify only one data array in the ``simplified'' form in order to see the result. But one may set parametric dependence of coordinates and produce rather complex curves and surfaces in the ``advanced'' form. In both cases the order of function arguments is the same: first data arrays, second the string with plot parameters, and later optional arguments for plot tuning.
@item
@strong{All plots are vector plots.} The MathGL library is intended for handling scientific data which have vector nature (lines, faces, matrices and so on). As a result, vector representation is used in all cases! In addition, the vector representation allows one to scale the plot easily -- change the canvas size by a factor of 2, and the picture will be proportionally scaled.
@item
@strong{New drawing never clears things drawn already.} This, in some sense, unexpected, idea allows to create a lot of ``combined'' graphics. For example, to make a surface with contour lines one needs to call the function for surface plotting and the function for contour lines plotting (in any order). Thus the special functions for making this ``combined'' plots (as it is done in Matlab and some other plotting systems) are superfluous. Many more examples of such plots can be found in section @ref{Hints} and in home site (@uref{http://mathgl.sf.net/index.html}).
@end enumerate

In addition to the general concepts I want to comment on some non-trivial or less commonly used general ideas -- plot positioning, axis specification and curvilinear coordinates, styles for lines, text and color scheme.

@menu
* Coordinate axes::             
* Line styles::                 
* Color scheme::                
* Font styles::                  
* Textual formulas::            
@end menu

@include concept_en.texi

@node Graphics setup @MGL{}, Axis settings @MGL{}, General concepts, MGL interface
@end ifset
@ifclear UDAV

@c ##################################################################
@node Graphics setup @MGL{}, Axis settings @MGL{}, MGL basics, MGL interface
@end ifclear
@section Graphics setup @MGL{}

Coomands in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting commands. 

@menu
* Transparency @MGL{}::          
* Lighting @MGL{}::              
* Fog @MGL{}::                   
* Default sizes @MGL{}::         
* Zooming @MGL{}::               
* Cutting @MGL{}::               
* Other settings @MGL{}::        
@end menu

@c ==================================================================
@node Transparency @MGL{}, Lighting @MGL{}, , Graphics setup @MGL{}
@subsection Transparency @MGL{}

There are several commands for setup transparency. The general command is @ref{alpha} which switch on/off the transparency for overall plot. It influence only for graphics which created after @ref{alpha} call. Command @ref{alphadef} specify the default value of alpha-channel. You may switch off transparency of selected plot by command @ref{transparent}. Finally, command @ref{transptype} set the kind of transparency. @sref{Transparent surface sample}

@cindex alpha
@anchor{alpha}
@deffn {MGL command} alpha @code{[val=on]}
Sets the transparency on/off. It is recommended to call this command before any plotting command. Default value is @code{off}. Use @code{transparent off} in particular plot to disable its transparency.
@end deffn
@cindex alphadef
@anchor{alphadef}
@deffn {MGL command} alphadef @code{val}
Default value of alpha channel (transparency) for all plotting commands. Initial value is 0.5.
@end deffn
@cindex transparent
@anchor{transparent}
@deffn {MGL command} transparent @code{val}
Temporary switches transparency on/off for the plot.
@end deffn
@cindex transptype
@anchor{transptype}
@deffn {MGL command} transptype @code{val}
This command set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{alphadef 0.3} or less for lamp-like transparency. @xref{Normal transparency}, @ref{Glass-like transparency}, @ref{Lamp-like transparency}.
@end deffn

@c ==================================================================
@node Lighting @MGL{}, Fog @MGL{}, Transparency @MGL{}, Graphics setup @MGL{}
@subsection Lighting @MGL{}

There are several commands for setup lighting. The general command is @ref{light} which switch on/off the lighting for overall plot. Generally MathGL support up to 10 independent light sources. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@cindex light
@anchor{light}
@deffn {MGL command} light @code{[val=on]}
Sets the using of light on/off for overall plot. It is recommended to call this command before any plotting command. Default value is lightning off.
@end deffn
@deffn {MGL command} light @code{num val}
Switch on/off @var{num}-th light source separately.
@end deffn

@deffn {MGL command} light @code{num xpos ypos zpos} ['col'='w' @code{br=0.5}]
The command adds a light source with identification @var{num} at position @{@var{xpos}, @var{ypos}, @var{zpos}@}. The color of light is @var{col} (white by default). The brightness of light is @var{br} which must be in range [0,1].
@end deffn

@cindex ambient
@anchor{ambient}
@deffn {MGL command} ambient @code{val}
Sets the brightness of ambient light. The value should be in range [0,1]. Initial value is 0.5. 
@end deffn

@c ==================================================================
@node Fog @MGL{}, Default sizes @MGL{}, Lighting @MGL{}, Graphics setup @MGL{}
@subsection Fog @MGL{}

@cindex fog
@anchor{fog}
@deffn {MGL command} fog @code{val [dz=0.25]}
Command imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~@math{1-exp(-d*z)}. Here @emph{z} is normalized to 1 depth of the plot. If value @var{val}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deffn

@c ==================================================================
@node Default sizes @MGL{}, Zooming @MGL{}, Fog @MGL{}, Graphics setup @MGL{}
@subsection Default sizes @MGL{}

These commands control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@cindex barwidth
@anchor{barwidth}
@deffn {MGL command} barwidth @code{val}
Sets relative width of rectangles in @code{bars, barh, boxplot}. Default value is @code{0.7}.
@end deffn

@cindex marksize
@anchor{marksize}
@deffn {MGL command} marksize @code{val}
The size of marks. Default value is @code{1}.
@end deffn

@cindex arrowsize
@anchor{arrowsize}
@deffn {MGL command} arrowsize @code{val}
The size of arrows for lines and curves. Default value is @code{1}.
@end deffn

@cindex linewidth
@anchor{linewidth}
@deffn {MGL command} linewidth @code{val}
The variable define the base width for all lines. The value <1 is ignored. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deffn

@cindex ticklen
@anchor{ticklen}
@deffn {MGL command} ticklen @code{val} [@code{stt=1}]
The relative length of axis ticks. Default value is @code{0.1}. Parameter @var{stt}>0 set relative length of subticks which is in @code{sqrt(1+stt)} times smaller.
@end deffn

@cindex tickstl
@anchor{tickstl}
@deffn {MGL command} tickstl 'stl' ['sub'='']
The line style of axis ticks (@var{stl}) and subticks (@var{sub}). If @var{stl}='' then default style is used (@samp{k} or @samp{w} depending on transparency type). If @var{sub}='' then ticks style is used (i.e. @var{stl}).
@end deffn

@c ==================================================================
@node Zooming @MGL{}, Cutting @MGL{}, Default sizes @MGL{}, Graphics setup @MGL{}
@subsection Zooming @MGL{}

These commands control the overall zooming of the picture or the sub-picture. Normally you can use these variables and commands for removing ``white'' spaces around a plot.

@cindex plotfactor
@anchor{plotfactor}
@deffn {MGL command} plotfactor @code{val}
The factor of plot size. It is not recommended to set it lower then 1.6. This is some analogue of command @ref{zoom} but applied not to overall image but for each @ref{inplot}. Use negative value to enable automatic @ref{plotfactor} selection.
@end deffn

@cindex zoom
@anchor{zoom}
@deffn {MGL command} zoom @code{x1 y1 x2 y2}
The command changes the scale of graphics that correspond to zoom in/out of the picture. After command call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Use @code{zoom 0 0 1 1} to return default view.
@end deffn

@c ==================================================================
@node Cutting @MGL{}, Other settings @MGL{}, Zooming @MGL{}, Graphics setup @MGL{}
@subsection Cutting @MGL{}

These commands set the condition when the points are excluded (cutted) from the drawing. Note, that a point with @code{nan} value(s) of coordinate or amplitude will be automatically excluded from the drawing.

@cindex cut
@anchor{cut}
@deffn {MGL command} cut @code{val}
Determines how points outside bounding box are drawn. If it is @code{on} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deffn

@deffn {MGL command} cut @code{x1 y1 z1 x2 y2 z2}
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deffn

@deffn {MGL command} cut 'cond'
Command set the cutting off condition by formula @var{cond}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{''} to disable cutting off condition. @sref{CutOff sample}
@end deffn

@c ==================================================================
@node Other settings @MGL{}, , Cutting @MGL{}, Graphics setup @MGL{}
@subsection Other settings @MGL{}

@cindex font
@anchor{font}
@deffn {MGL command} font 'fnt' [@code{val=6}]
Font style for text and labels (see text). Initial style is 'fnt'='rC' give Roman font with centering. Parameter @code{val} sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels. For more detail, @pxref{Font styles}.
@end deffn

@cindex rotatetext
@anchor{rotatetext}
@deffn {MGL command} rotatetext @code{val}
Set to use or not text rotation along axis. Initial value is @code{on}.
@end deffn

@cindex palette
@anchor{palette}
@deffn {MGL command} palette 'colors'
Set the palette as selected colors. Default value is @code{'Hbgrcmyhlnqeup'}. The palette is used mostly in 1D plots for curves which styles are not specified.
@end deffn

@cindex meshnum
@anchor{meshnum}
@deffn {MGL command} meshnum @code{num}
Sets approximate number of lines in @ref{mesh}, @ref{fall}, @ref{grid} and also the number of hachures in @ref{vect}, @ref{vectc}, @ref{dew} and the number of cells in @ref{cloud}. By default (=0) it draws all lines/hachures/cells.
@end deffn

@cindex axialdir
@anchor{axialdir}
@deffn {MGL command} axialdir 'dir'
Set direction around which curve rotated in @ref{axial}, @ref{torus}. Default value is 'z'.
@end deffn

@c ==================================================================
@node Axis settings @MGL{}, Transformation matrix @MGL{}, Graphics setup @MGL{}, MGL interface
@section Axis settings @MGL{}

These large set of commands control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected and cutting is applied (@pxref{Cutting @MGL{}}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@cindex axis
@anchor{axis}
@deffn {MGL command} axis @code{x1 y1 x2 y2}
@deffnx {MGL command} axis @code{x1 y1 z1 x2 y2 z2}
@cindex ranges
@anchor{ranges}
@deffnx {MGL command} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
Sets the ranges of coordinates changing. Also it sets the range for coloring (analogous to @code{caxis z1 z2}). Initial ranges are [-1, 1].
@end deffn

@deffn {MGL command} axis 'fx' 'fy' ['fz'='' 'fa'='']
Sets the transformation formulas for curvilinear coordinates. Each string should contain mathematical expression for real coordinate depending on internal coordinates @samp{x}, @samp{y}, @samp{z} and @samp{a} or @samp{c} for colorbar. For example, the cylindrical coordinates are introduced as @code{axis 'x*cos(y)' 'x*sin(y)' 'z'}. For removing of formulas the corresponding parameter should be @code{''}. The using of transformation formulas will slightly slowing the program, i.e. @code{axis '' '' ''} is faster than @code{axis '1*x' '1*y' '1*z'}. Initially all formulas are absent (Cartesian coordinates are used). For more details about functions and formulas, @pxref{Textual formulas}.
@end deffn

@deffn {MGL command} axis @code{how}
Sets one of the predefined transformation formulas for curvilinear coordinate. Paramater @var{how} define the coordinates: @samp{0} -- Cartesian coordinates (no transformation); @samp{1} -- Polar coordiantes @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @samp{2} -- Spherical coordinates @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @samp{3} -- Parabolic coordinates @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @samp{4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @samp{5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @samp{6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @samp{7} -- Elliptic coordinates @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @samp{8} -- Toroidal coordinates @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @samp{9} -- Bispherical coordinates @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @samp{10} -- Bipolar coordinates @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deffn

@cindex caxis
@anchor{caxis}
@deffn {MGL command} caxis @code{z1 z2}
Sets the range for surface coloring. Initial range is [-1, 1].
@end deffn

@cindex origin
@anchor{origin}
@deffn {MGL command} origin @code{x0 y0 [z0=nan]}
Center of axis cross section. If one of values is @code{nan} then MathGL library try to select optimal axis position.
@end deffn

@cindex ternary
@anchor{ternary}
@deffn {MGL command} ternary @code{val}
The command sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deffn

@cindex xrange
@anchor{xrange}
@deffn {MGL command} xrange dat [@code{add=off fact=0}]
@cindex yrange
@anchor{yrange}
@deffnx {MGL command} yrange dat [@code{add=off fact=0}]
@cindex zrange
@anchor{zrange}
@deffnx {MGL command} zrange dat [@code{add=off fact=0}]
@cindex crange
@anchor{crange}
@deffnx {MGL command} crange dat [@code{add=off fact=0}]
Sets the range for x-,y-,z- coordinate or coloring as minimal and maximal values of data @var{dat}. Parameter @code{add=on} shows that the new range will be joined to existed one (nut will not replace it). Parameter @var{fact} add additional range increase on value (@var{Max}-@var{Min})*@var{fact}.
@end deffn

@deffn {MGL command} xrange @code{x1 x2}
@deffnx {MGL command} yrange @code{x1 x2}
@deffnx {MGL command} zrange @code{x1 x2}
@deffnx {MGL command} crange @code{x1 x2}
Sets the range for x-,y-,z- coordinate or coloring. See also @ref{axis}.
@end deffn

@cindex xtick
@anchor{xtick}
@deffn {MGL command} xtick @code{val [sub=0 org=nan]}
@cindex ytick
@anchor{ytick}
@deffnx {MGL command} ytick @code{val [sub=0 org=nan]}
@cindex ztick
@anchor{ztick}
@deffnx {MGL command} ztick @code{val [sub=0 org=nan]}
@cindex ctick
@anchor{ctick}
@deffnx {MGL command} ctick @code{val}
Sets step for x-, y-, z-axis ticks or colorbar ticks (if @var{val}>0) or it's number (if @var{val}<0) in corresponding direction. Zero value @var{val}=0 sets logarithmic ticks. Parameter @var{sub} sets the number of sub-ticks. Parameter @var{org} set the starting points for ticks. If not @code{org=nan} then the value from @ref{origin} is used.
@end deffn

@deffn {MGL command} xtick 'templ'
@deffnx {MGL command} ytick 'templ'
@deffnx {MGL command} ztick 'templ'
@deffnx {MGL command} ctick 'templ'
Sets the template for x-, y-, z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{templ}=@code{''} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component.
@end deffn

@deffn {MGL command} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {MGL command} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {MGL command} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
Sets manual positions @var{val1},@var{val2},... and labels @var{lbl1},@var{lbl2},... for ticks along x-, y-, z-axis. Labels may contain TeX symbols also.
@end deffn

@cindex adjust
@anchor{adjust}
@deffn {MGL command} adjust ['dir'='xyzc']
Set the ticks step, number of sub-ticks and initial ticks position to be the most human readable for the axis along direction(s) @var{dir}.
@end deffn


@c ##################################################################
@node Transformation matrix @MGL{}, Export to file @MGL{}, Axis settings @MGL{}, MGL interface
@section Transformation matrix @MGL{}

These commands control how and where further plotting will be placed. There is a curtain order of calling of these commands for the better plot view. First one should be @ref{subplot} or @ref{inplot} for specifying the place. After it a @ref{rotate} and @ref{aspect}. And finally any other plotting commands may be called. Alternatevely you can use @ref{columnplot} for position plots in the column one by another without gap between plot axis (bounding boxes).

@cindex subplot
@anchor{subplot}
@deffn {MGL command} subplot @code{nx ny m [dx=0 dy=0]}
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This command set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this command with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deffn

@deffn {MGL command} subplot @code{nx ny m} 'style'
The same as previous but space reserved for axis/colorbar is saved only if @var{style} contain: @samp{L} or @samp{<} -- at left side, @samp{R} or @samp{>} -- at right side, @samp{A} or @samp{^} -- at top side, @samp{U} or @samp{_} -- at bottom side.
@end deffn

@cindex inplot
@anchor{inplot}
@deffn {MGL command} inplot @code{x1 x2 y1 y2 [rel=off]}
Puts further plotting in some region of the whole frame surface. This command allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. If parameter @var{rel}=@code{on} then the relative position to current @ref{subplot} is used. This command set off any aspects or rotations. So it should be used first for creating subplot.
@end deffn

@cindex columnplot
@anchor{columnplot}
@deffn {MGL command} columnplot @code{num ind [d=0]}
Puts further plotting in @var{ind}-th cell of column with @var{num} cells. The position is relative to previous @ref{subplot} call (or @ref{inplot} with @code{rel=off}). Parameter @var{d} set extra gap between cells.
@end deffn

@cindex stickplot
@anchor{stickplot}
@deffn {MGL command} stickplot @code{num ind tet phi}
Puts further plotting in @var{ind}-th cell of stick with @var{num} cells. At this, stick is rotated on angles @var{tet}, @var{phi}. The position is relative to previous @ref{subplot} call (or @ref{inplot} with @code{rel=off}).
@end deffn

@cindex rotate
@anchor{rotate}
@deffn {MGL command} rotate @code{tetz tetx [tety=0]}
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{tetx}, @var{tetz}, @var{tety}.
@end deffn

@deffn {MGL command} rotate @code{tet x y z}
Rotates a further plotting around vector @{x,y,z@} on angle @var{tet}.
@end deffn

@cindex aspect
@anchor{aspect}
@deffn {MGL command} aspect @code{ax ay [az=1]}
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{ax:ay:az}. For the best effect it should be used after @ref{rotate} command.
@end deffn

@cindex perspective
@anchor{perspective}
@deffn {MGL command} perspective @code{val}
Add (switch on) the perspective to plot. The parameter @math{val ~ 1/z_@{eff@} \in [0,1)}. By default (@code{val=0}) the perspective is off.
@end deffn

@c ##################################################################
@node Export to file @MGL{}, Primitives drawing @MGL{}, Transformation matrix @MGL{}, MGL interface
@section Export to file @MGL{}

@cindex write
@anchor{write}
@deffn {MGL command} write 'fname' [@code{solid=off}]
Exports current picture/frame to file 'fname' (file type is determined by extension). Solid (usually white) background will be used if @code{solid=on}. If 'fname'='' then the file @samp{frameNNNN.jpg} is used, where @samp{NNNN} is current frame id.
@end deffn

@cindex setsize
@anchor{setsize}
@deffn {MGL command} setsize @code{w h}
Sets size of picture in pixels. This function call @strong{must be} placed before any plotting command because it completely remove picture content. In some program the call of this function is forbidden.
@end deffn


@c ##################################################################
@node Primitives drawing @MGL{}, Text printing @MGL{}, Export to file @MGL{}, MGL interface
@section Primitives drawing

These commands draw some simple objects like line, point, sphere, drop, cone and so on.

@cindex clf
@anchor{clf}
@deffn {MGL command} clf
Clear the picture by removes all drawing from it. Does not change transformation matrix. 
@end deffn

@cindex ball
@anchor{ball}
@deffn {MGL command} ball @code{x y} ['col'='r']
@deffnx {MGL command} ball @code{x y z} ['col'='r']
Draws a point (ball) at position @{@var{x}, @var{y}, @var{z}@} with color defined by string @var{col}.
@end deffn

@cindex line
@anchor{line}
@deffn {MGL command} line @code{x1 y1 x2 y2} ['stl'='']
@deffnx {MGL command} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Draws a geodesic line (straight line in Cartesian coordinates) from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}.
@end deffn

@cindex curve
@anchor{curve}
@deffn {MGL command} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deffnx {MGL command} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
Draws Bezier-like curve from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. At this tangent is co-directed with @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@} and proportional to its amplitude.
@end deffn

@cindex facex
@anchor{facex}
@deffn {MGL command} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facey
@anchor{facey}
@deffnx {MGL command} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facez
@anchor{facez}
@deffnx {MGL command} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deffn

@cindex sphere
@anchor{sphere}
@deffn {MGL command} sphere @code{x0 y0 r} ['col'='r']
@deffnx {MGL command} sphere @code{x0 y0 z0 r} ['col'='r']
Draw the sphere with radius @var{r} and center at point @{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deffn

@cindex drop
@anchor{drop}
@deffn {MGL command} drop @code{x0 y0 dx dy r} ['col'='b' @code{sh=1 asp=1}]
@deffnx {MGL command} drop @code{x0 y0 z0 dx dy dz r} ['col'='b' @code{sh=1 asp=1}]
Draw the drop with radius @var{r} at point @{@var{x0},@var{y0},@var{z0}@} elongated in direction @{@var{dx},@var{dy},@var{dz}@} and with color @var{col}. Parameter @var{sh} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{asp} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deffn

@cindex cone
@anchor{cone}
@deffn {MGL command} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='' @code{edge=off}]
Draw tube (or truncated cone if @var{edge}=@code{off}) between points @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} with radiuses at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is supposed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deffn

@cindex rect
@anchor{rect}
@deffn {MGL command} rect @code{x1 y1 x2 y2} ['st'='']
@deffnx {MGL command} rect @code{x1 y1 z1 x2 y2 z2} ['st'='']
Draw rectangle from point @{@var{x1},@var{y1},@var{z1}@} to point @{@var{x2},@var{y2},@var{z2}@} using colors @var{stl}. If @var{stl} have 4 or more colors then it defines colors for each rectangle vertex (useful for making gradients, like @samp{wwrr}) else first color is used for whole rectangle.
@end deffn

@c ##################################################################
@node Text printing @MGL{}, Axis and Colorbar @MGL{}, Primitives drawing @MGL{}, MGL interface
@section Text printing @MGL{}

These commands draw the text. There are commands for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. It is possible to use arbitrary font-faces and parse many TeX commands. The Unicode text is supported. So sometimes you need to specify locale. The @code{size} argument control the size of text: if positive it give the value, if negative it give the value relative to defined by @code{font} command. @xref{Font styles}.

@cindex text
@anchor{text}
@deffn {MGL command} text @code{x y} 'text' ['fnt'='' @code{size=-1.4}]
@deffnx {MGL command} text @code{x y z} 'text' ['fnt'='' @code{size=-1.4}]
Draws unrotated text string @var{text} at position @{@var{x},@var{y},@var{z}@} with specified style @var{fnt} and @var{size}. By default parameters from @code{font} command are used.
@end deffn

@deffn {MGL command} text @code{x y dx dy} 'text' [@code{size=-1.4}]
@deffnx {MGL command} text @code{x y z dx dy dz} 'text' [@code{size=-1.4}]
The command plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} along direction @{@var{dx},@var{dy},@var{dz}@} with specified style @var{fnt} and @var{size}. By default parameters from @code{font} command are used.
@end deffn

@deffn {MGL command} text ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat zdat 'text' ['fnt'='' @code{size=-1}]
The command draws @var{text} along the curve between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} by font style @var{fnt} and with size @var{size}. The string @var{fnt} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{xdat.nx=ydat.nx=zdat.nx}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{z}[i] = @var{zval} is used. @sref{Text sample}
@end deffn

@cindex title
@anchor{title}
@deffn {MGL command} title 'text' ['fnt'='' @code{size=-2}]
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside @ref{subplot}).
@end deffn

@cindex fgets
@anchor{fgets}
@deffn {MGL command} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deffnx {MGL command} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Draws unrotated @var{n}-th line of file @var{fname} at position @{@var{x},@var{y},@var{z}@} with specified @var{size}. By default parameters from @ref{font} command are used.
@end deffn


@c ##################################################################
@node Axis and Colorbar @MGL{}, Legend @MGL{}, Text printing @MGL{}, MGL interface
@section Axis and Colorbar @MGL{}

These commands draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings @MGL{}}.

@cindex axis
@c @anchor{}
@deffn {MGL command} axis ['dir'='xyz' @code{adjust=off}]
Draws axes with ticks (@pxref{Axis settings @MGL{}}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by command @ref{font}. Ticks will be automatically adjusted if @var{adjust}=@code{on} (by call of @code{adjust 'dir'}).
@end deffn

@cindex colorbar
@anchor{colorbar}
@deffn {MGL command} colorbar ['sch'='' @code{pos=0}]
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=''}) at edge of plot. Parameter @var{pos} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. If string @var{sch} contains @samp{<>^_} then the parameter @var{pos} is defined as: @code{pos=0} for @samp{>} (right), @code{pos=1} for @samp{<} (left), @code{pos=2} for @samp{^} (top), @code{pos=3} for @samp{_} (bottom). If string have @samp{A} then absolute (relative to picture) coordinates is used. @sref{Dens sample}
@end deffn

@deffn {MGL command} colorbar vdat ['sch'='' @code{pos=0}]
The same as previous but with sharp colors @var{sch} (current palette if @code{sch=""}) for values @var{v}. @sref{ContD sample}
@end deffn

@deffn {MGL command} colorbar 'sch' @code{pos x y w h}
The same as first one but at arbitrary position of subplot @{@var{x}, @var{y}@} (supposed to be in range [0,1]). Parameters @var{w}, @var{h} set the relative width and height of the colorbar.
@end deffn

@cindex grid
@anchor{grid}
@deffn {MGL command} grid ['dir'='xyz' 'pen'='B']
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an @code{axis}. The style of lines is determined by @var{pen} parameter.
@end deffn

@cindex box
@anchor{box}
@deffn {MGL command} box ['stl'='k' @code{ticks=on}]
Draws bounding box outside the plotting volume with line style 'stl'. If @code{ticks=on} then ticks are drawn with current axis setting.
@end deffn

@cindex xlabel
@anchor{xlabel}
@deffn {MGL command} xlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex ylabel
@anchor{ylabel}
@deffnx {MGL command} ylabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex zlabel
@anchor{zlabel}
@deffnx {MGL command} zlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex tlabel
@anchor{tlabel}
@deffnx {MGL command} tlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
Prints the label @var{text} for x-,y-,z-,t-axis (here @samp{t} is ``ternary'' axis @math{t=1-x-y}). The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis (default). If @var{pos}<0 then label is printed at the minimum of axis. The font size is 1.4 times larger than the one for ticks @code{font}. Parameter @code{shift} specify additional shifting of the label. @xref{Text printing @MGL{}}.
@end deffn

@c ##################################################################
@node Legend @MGL{}, 1D plotting @MGL{}, Axis and Colorbar @MGL{}, MGL interface
@section Legend @MGL{}

These commands draw legend to the graph (useful for @ref{1D plotting @MGL{}}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string are accumulated first to the internal arrays (by command @ref{addlegend}) and are plotted later. The position of the legend can be selected automatic or manually. Parameters @var{fnt} and @var{size} specify the font style and size. Parameter @var{llen} set the relative width of the line sample and the text indent (default value is 0.1). If line style string for entry is empty then the corresponding text is printed without indent. If string contains @samp{A} then legend coordinates set position in the picture. @sref{Legend sample}

@cindex legend
@anchor{legend}
@deffn {MGL command} legend [@code{pos=3} 'fnt'='rL' @code{size=-1 llen=0.1}]
Draws legend of accumulated legend entries by font @var{fnt} with specified @var{size}. Parameter @var{pos} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deffn

@deffn {MGL command} legend @code{x y} ['fnt'='rL' @code{size=-1 llen=0.1}]
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Position of legend in the current subplot is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deffn

@cindex addlegend
@anchor{addlegend}
@deffn {MGL command} addlegend 'text' 'stl'
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{stl} (@pxref{Line styles}). Maximal number of entries is 100.
@end deffn

@cindex clearlegend
@anchor{clearlegend}
@deffn {MGL command} clearlegend
Clears saved legend strings.
@end deffn

@cindex legendbox
@anchor{legendbox}
@deffn {MGL command} legendbox @code{val}
Switches on/off the drawing of a box near legend. By default, the box is drawn.
@end deffn

@cindex legendmarks
@anchor{legendmarks}
@deffn {MGL command} legendmarks @code{val}
Set the number of marks in the legend. By default 1 mark is used.
@end deffn

@c ##################################################################
@node 1D plotting @MGL{}, 2D plotting @MGL{}, Legend @MGL{}, MGL interface
@section 1D plotting @MGL{}

These commands perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (@ref{plot}), line plot with filling under it (@ref{area}), stairs plot (@ref{step}), bar plot (@ref{bars}, @ref{barh}) and vertical lines (@ref{stem}). Each type of plotting has similar interface. Most of plotting type has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette is used (@pxref{Line styles}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (@ref{torus}), chart (@ref{chart}) and error boxes (@ref{error}), marks with variable size (@ref{mark}), tubes (@ref{tube}) and so on. @sref{1D plot sample}

The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{xdat.nx=ydat.nx=zdat.nx}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). String @var{stl} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{stl=''}) solid line with color from palette is used (@pxref{Line styles}).

@cindex plot
@anchor{plot}
@deffn {MGL command} plot ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat zdat ['stl'='']
Draws continuous lines between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. See also @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}. @sref{Plot sample}
@end deffn


@cindex radar
@anchor{radar}
@deffn {MGL command} radar adat ['stl'='' @code{r=-1}]
Draws radar chart which is continuous lines between points located on an radial lines (like plot in Polar coordinates). The plots are drawn for each row if one of the data is the matrix. Parameter @var{r} set the additional shift of data (i.e. the data @var{adat}+@var{r} is used instead of @var{adat}). If @code{r<0} then @code{r=max(0, -min(adat)}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{stl=""}) solid line with color from palette is used (@pxref{Line styles}). If @var{pen} containt @samp{#} symbol then "grid" (radial lines and circle for @var{r}) is drawn See also @ref{plot}. @sref{Radar sample}
@end deffn

@cindex tens
@anchor{tens}
@deffn {MGL command} tens ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tens xdat ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tens xdat ydat zdat cdat ['stl'='']
Draws continuous lines between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} with color defined by @var{cdat}[i] (look like tension plot). See also @ref{plot}, @ref{mesh}, @ref{fall}. @sref{Tens sample}
@end deffn

@cindex area
@anchor{area}
@deffn {MGL command} area ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat zdat ['stl'='']
Draws continuous lines between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} and fills it down to axis (to axis plane in 3D). You can use gradient filling if number of specified colors is equal to 2*number of curves. If string contain symbol @samp{a} then lines are drawn one above another (like summation). See also @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{Area sample}
@end deffn

@cindex region
@anchor{region}
@deffn {MGL command} region fdat gdat ['stl'='' @code{inside=off}]
@deffnx {MGL command} region xdat fdat gdat ['stl'='' @code{inside=off}]
Fills area between curves @{@var{xdat}[i], @var{fdat}[i]@} and @{@var{xdat}[i], @var{gdat}[i]@}. Parameter  @code{inside=off} set to fill are with y1<y<y2 else the area with y2<y<y1 will be also filled. You can use gradient filling if number of specified colors is equal to 2*number of curves. See also @ref{area}, @ref{bars}, @ref{stem}. @sref{Region sample}
@end deffn

@cindex stem
@anchor{stem}
@deffn {MGL command} stem ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat zdat ['stl'='']
Draws vertical lines from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to axis (to axis plane in 3D). See also @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{Stem sample}
@end deffn

@cindex bars
@anchor{bars}
@deffn {MGL command} bars ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} bars xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} bars xdat ydat zdat ['stl'='']
Draws vertical bars from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to axis (to axis plane in 3D). If style contain symbol @samp{a} then lines are drawn one above another. If string contain symbol @samp{f} then waterfall chart is drawn for determining the cumulative effect of sequentially introduced positive or negative values. You can different colors for positive and negative values if number of specified colors is equal to 2*number of curves. See also @ref{barh}, @ref{area}, @ref{stem}, @ref{chart}. @sref{Bars sample}
@end deffn

@cindex barh
@anchor{barh}
@deffn {MGL command} barh vdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} barh ydat vdat ['stl'='' @code{zval=nan}]
Draws horizontal bars from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to y-axis. If array @var{ydat} is not specified then its an automatic array is used with values equidistantly distributed along y. Marks at data points are not drawn. If style contain symbol @samp{a} then lines are drawn one above another. If string contain symbol @samp{f} then waterfall chart is drawn for determining the cumulative effect of sequentially introduced positive or negative values. You can different colors for positive and negative values if number of specified colors is equal to 2*number of curves.
See also @ref{bars}. @sref{Barh sample}
@end deffn

@cindex chart
@anchor{chart}
@deffn {MGL command} chart adat ['col'='']
The command draws colored stripes (boxes) for data in array @var{adat}. The number of stripes is equal to the number of rows in @var{adat} (equal to @var{a.ny}). The color of each next stripe is cyclically changed from colors specified in string @var{col} or in palette. Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordinates) or in cylindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deffn

@cindex step
@anchor{step}
@deffn {MGL command} step ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat zdat ['stl'='']
Draws continuous stairs for points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. See also @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}. @sref{Step sample}
@end deffn

@cindex torus
@anchor{torus}
@deffn {MGL command} torus zdat ['stl'='']
@deffnx {MGL command} torus rdat zdat ['stl'='']
Draws surface which is result of curve @{@var{rdat}[i], @var{zdat}[i], @var{zdat}[i]@} rotation around @ref{axialdir} axis. If array @var{rdat} is not specified then its an automatic array is used with values equidistantly distributed along x. See also @ref{plot}, @ref{axial}. @sref{Torus sample}
@end deffn

@cindex tube
@anchor{tube}
@deffn {MGL command} tube ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat zdat rdat ['stl'='']
@deffnx {MGL command} tube xdat ydat zdat @code{rval} ['stl'='']
Draws tube with variable radius @var{rdat}[i] (or @var{rval}) at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. See also @ref{plot}. @sref{Tube sample}
@end deffn

@cindex mark
@anchor{mark}
@deffn {MGL command} mark ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat zdat rdat ['stl'='']
Draws  marks with size @var{rdat}[i]*@code{marksize} at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. See also @ref{plot}, @ref{textmark}, @ref{stem}, @ref{error}. @sref{Mark sample}
@end deffn

@cindex textmark
@anchor{textmark}
@deffn {MGL command} textmark ydat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat zdat rdat 'txt' ['stl'='']
Draws string @var{txt} as marks with size @var{rdat}[i]*@code{marksize} at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{rdat} is not specified then @var{rdat}[i] = 1. See also @ref{plot}, @ref{mark}, @ref{stem}. @sref{Error sample}
@end deffn

@cindex error
@anchor{error}
@deffn {MGL command} error ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat xerr yerr ['stl'='' @code{zval=nan}]
Draws error boxes @{@var{xerr}[i], @var{yerr}[i]@} at points @{@var{xdat}[i], @var{ydat}[i], @var{zval}@}. See also @ref{plot}. @sref{TextMark sample}
@end deffn

@cindex boxplot
@anchor{boxplot}
@deffn {MGL command} boxplot adat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} boxplot xdat adat ['stl'='' @code{zval=nan}]
Draws boxplot (also known as a box-and-whisker diagram) at points @var{xdat} in plane z=@code{zval} (by default is at the bottom of the bounding box). This is five-number summaries of data <em>adat</em> (minimum, lower quartile (Q1), median (Q2), upper quartile (Q3) and maximum) along second (j-th) direction. See also @ref{plot}, @ref{error}, @ref{bars}. @sref{BoxPlot sample}
@end deffn

@c ##################################################################
@node 2D plotting @MGL{}, 3D plotting @MGL{}, 1D plotting @MGL{}, MGL interface
@section 2D plotting @MGL{}

These commands perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (@ref{mesh}), surface plot (@ref{surf}), surface plot by boxes (@ref{boxs}), surface plot by tiles (@ref{tile}), waterfall-like plot (@ref{fall}), belt plot (@ref{belt}), density plot (@ref{dens}), contour lines plot (@ref{cont}), solid contours plot (@ref{contf}) and its rotational figure (@ref{axial}). Commands @ref{cont}, @ref{contf} and @ref{axial} have variants for automatic and manual selection of level values for contours. Also there are commands for plotting data grid lines according to the data format (@ref{grid}) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. @sref{2D plot sample}

String parameter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{xdat}, @var{ydat}, @var{zdat} should be equal @code{xdat.nx=zdat.nx && ydat.nx=zdat.ny} or @code{xdat.nx=ydat.nx=zdat.nx && xdat.ny=ydat.ny=zdat.ny}. Arrays @var{xdat} and @var{ydat} can be vectors (not matrices as @var{zdat}). If array @var{xdat}, @var{ydat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y. Graphics are plotted for each z-slice of the data.

@cindex surf
@anchor{surf}
@deffn {MGL command} surf zdat ['sch'='']
@deffnx {MGL command} surf xdat ydat zdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{Surf sample}
@end deffn

@cindex mesh
@anchor{mesh}
@deffn {MGL command} mesh zdat ['sch'='']
@deffnx {MGL command} mesh xdat ydat zdat ['sch'='']
Draws mesh lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{Mesh sample}
@end deffn

@cindex fall
@anchor{fall}
@deffn {MGL command} fall zdat ['sch'='']
@deffnx {MGL command} fall xdat ydat zdat ['sch'='']
Draws fall lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. See also @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{Fall sample}
@end deffn

@cindex belt
@anchor{belt}
@deffn {MGL command} belt zdat ['sch'='']
@deffnx {MGL command} belt xdat ydat zdat ['sch'='']
Draws belts for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) lines are drawn along y-direction. See also @ref{fall}, @ref{surf}, @ref{plot}, @ref{meshnum}. @sref{Belt sample}
@end deffn

@cindex boxs
@anchor{boxs}
@deffn {MGL command} boxs zdat ['sch'='']
@deffnx {MGL command} boxs xdat ydat zdat ['sch'='']
Draws vertical boxes for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{Boxs sample}
@end deffn

@cindex tile
@anchor{tile}
@deffn {MGL command} tile zdat ['sch'='']
@deffnx {MGL command} tile xdat ydat zdat ['sch'='']
Draws horizontal tiles for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Such plot can be used as 3d generalization of @ref{step}. See also @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{Tile sample}
@end deffn

@cindex dens
@anchor{dens}
@deffn {MGL command} dens zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dens xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws density plot for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal}. See also @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{Dens sample}
@end deffn

@cindex cont
@anchor{cont}
@deffn {MGL command} cont vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} cont vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws contour lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k. If string @var{stl} contain 't' (or 'T') symbol then contour labels will be drawn below (or above) the contours. See also @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{Cont sample}
@end deffn

@deffn {MGL command} cont zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} cont xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@cindex contf
@anchor{contf}
@deffn {MGL command} contf vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} contf vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws solid (or filled) contours for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k (must be @code{vdat.nx>2}). See also @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{ContF sample}
@end deffn

@deffn {MGL command} contf zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} contf xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@cindex contd
@anchor{contd}
@deffn {MGL command} contd vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} contd vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws solid (or filled) contours for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}) with manual colors. Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k (must be @code{vdat.nx>2}). The color of k-th contour is @code{sch[k%strlen(sch)]}. See also @ref{dens}, @ref{cont}, @ref{contf}. @sref{ContD sample}
@end deffn

@deffn {MGL command} contd zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} contd xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@cindex axial
@anchor{axial}
@deffn {MGL command} axial vdat zdat ['sch'='']
@deffnx {MGL command} axial vdat xdat ydat zdat ['sch'='']
Draws surface which is result of contour plot rotation surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string @var{sch} contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @code{axialdir} will be set to specified direction. If string @var{sch} have symbol @samp{#} then wire plot is produced. See also @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{Axial sample}
@end deffn

@deffn {MGL command} axial zdat ['sch'='' @code{num=3}]
@deffnx {MGL command} axial xdat ydat zdat ['sch'='' @code{num=3}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@cindex grad
@anchor{grad}
@deffn {MGL command} grad pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} grad xdat ydat pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} grad xdat ydat zdat pdat ['sch'='' @code{num=5}]
Draws gradient lines for scalar field @var{pdat} specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j]@} or @{@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]@}. String @var{sch} sets the color scheme. Previous color scheme is used by default. Number of lines is proportional to @var{num}. If @var{num}<0 then lines start from borders only. See also @ref{dens}, @ref{cont}, @ref{dens3}, @ref{cont3}, @ref{flow}. @sref{Grad sample}
@end deffn


@cindex grid2
@anchor{grid2}
@deffn {MGL command} grid2 zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} grid2 xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws grid lines for density plot of surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal}. See also @ref{dens}, @ref{cont}, @ref{contf}.
@end deffn


@c ##################################################################
@node 3D plotting @MGL{}, Dual plotting @MGL{}, 2D plotting @MGL{}, MGL interface
@section 3D plotting @MGL{}

These commands perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (@ref{surf3}), density plot at slices (Dens3), contour lines plot at slices (@ref{cont3}), solid contours plot at slices (@ref{contf3}) and cloud-like plot (@ref{cloud}). Commands @ref{surf3}, @ref{cont3} and @ref{contf3} have variants for automatic and manual selection of level values for surfaces/contours. Also there are commands for plotting data grid lines according to the data format (@ref{grid3}) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. @sref{3D plot sample}

String paramter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). If array @var{xdat}, @var{ydat}, @var{zdat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y, z.


@cindex surf3
@anchor{surf3}
@deffn {MGL command} surf3 adat @code{val} ['sch'='']
@deffnx {MGL command} surf3 xdat ydat zdat adat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. If string contain @samp{#} then wire plot is produced. See also @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{Surf3 sample}
@end deffn

@deffn {MGL command} surf3 adat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3 xdat ydat zdat adat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @ref{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@cindex dens3
@anchor{dens3}
@deffn {MGL command} dens3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} dens3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws density plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Density is plotted at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{Dens3 sample}
@end deffn

@cindex densa
@anchor{densa}
@deffn {MGL command} densa adat ['sch'='']
@deffnx {MGL command} densa xdat ydat zdat adat ['sch'='']
Draws density plots at all central slices of the 3d data specified parametrically.
@end deffn

@cindex cont3
@anchor{cont3}
@deffn {MGL command} cont3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} cont3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws contour plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Contours are plotted for values specified in array @var{vdat} at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. If string @var{stl} contain 't' (or 'T') symbol then contour labels will be drawn below (or above) the contours. See also @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{Cont3 sample}
@end deffn

@deffn {MGL command} cont3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} cont3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see @code{caxis}).
@end deffn

@cindex conta
@anchor{conta}
@deffn {MGL command} conta adat ['sch'='' @code{num=7}]
@deffnx {MGL command} conta xdat ydat zdat adat ['sch'='' @code{num=7}]
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deffn

@cindex contf3
@anchor{contf3}
@deffn {MGL command} contf3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} contf3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws solid contour plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Contours are plotted for values specified in array @var{vdat} at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{ContF3 sample}
@end deffn

@deffn {MGL command} contf3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} contf3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see @ref{caxis}).
@end deffn

@cindex contfa
@anchor{contfa}
@deffn {MGL command} contfa adat ['sch'='' @code{num=7}]
@deffnx {MGL command} contfa xdat ydat zdat adat ['sch'='' @code{num=7}]
Draws solid contour plots at all central slices of the 3d data specified parametrically.
@end deffn

@cindex grid3
@anchor{grid3}
@deffn {MGL command} grid3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} grid3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws grid for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Grid is plotted at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. See also @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}. @sref{Dens3 sample}
@end deffn

@cindex grida
@anchor{grida}
@deffn {MGL command} grida adat ['sch'='']
@deffnx {MGL command} grida xdat ydat zdat adat ['sch'='']
Draws grids at all central slices of the 3d data specified parametrically.
@end deffn

@cindex cloud
@anchor{cloud}
@deffn {MGL command} cloud adat ['sch'='']
@deffnx {MGL command} cloud xdat ydat zdat adat ['sch'='']
Draws cloud for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{adat}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on @ref{meshnum}. Paramater @var{alpha} changes the overall transparency of plot. See also @ref{surf3}. @sref{Cloud sample}
@end deffn

@cindex beam
@anchor{beam}
@deffn {MGL command} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
Draws  @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d array @var{adat}. This is special kind of plot for @var{adat} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{rval}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. See also @ref{surf3}.
@end deffn


@c ##################################################################
@node Dual plotting @MGL{}, Vector fields @MGL{}, 3D plotting @MGL{}, MGL interface
@section Dual plotting @MGL{}

These plotting commands draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (@ref{surfc}, @ref{surf3c}), surface or isosurface transpared by other data (@ref{surfa}, @ref{surf3a}), tiles with variable size (@ref{tiles}), mapping diagram (@ref{map}), STFA diagram (@ref{stfa}). Commands @ref{surf3a} and @ref{surf3c} have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array.

String paramter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). If array @var{xdat}, @var{ydat}, @var{zdat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y, z.

@cindex surfc
@anchor{surfc}
@deffn {MGL command} surfc zdat cdat ['sch'='']
@deffnx {MGL command} surfc xdat ydat zdat cdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} and color it by matrix @var{cdat}[i,j]. See also @ref{surf}, @ref{surfa}, @ref{surf3c}. @sref{SurfC sample}
@end deffn

@cindex surf3c
@anchor{surf3c}
@deffn {MGL command} surf3c adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} command but the color of isosurface depends on values of array @var{cdat}. If string contain @samp{#} then wire plot is produced. See also @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{Surf3C sample}
@end deffn

@deffn {MGL command} surf3c adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@cindex surfa
@anchor{surfa}
@deffn {MGL command} surfa zdat cdat ['sch'='']
@deffnx {MGL command} surfa xdat ydat zdat cdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} and transparent it by matrix @var{cdat}[i,j]. See also @ref{surf}, @ref{surfc}, @ref{surf3a}, @ref{tiles}. @sref{SurfA sample}
@end deffn

@cindex surf3a
@anchor{surf3a}
@deffn {MGL command} surf3a adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @ref{surf3} command but the transparency of isosurface depends on values of array @var{cdat}. If string contain @samp{#} then wire plot is produced. See also @ref{surf3}, @ref{surfa}, @ref{surf3c}. @sref{Surf3A sample}
@end deffn

@deffn {MGL command} surf3a adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@cindex tiles
@anchor{tiles}
@deffn {MGL command} tiles zdat rdat ['sch'='']
@deffnx {MGL command} tiles xdat ydat zdat rdat ['sch'='']
Draws horizontal tiles for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. It is mostly the same as @ref{tile} but the size of tiles is determined by @var{rdat} array. See also @ref{surfa}, @ref{tile}. @sref{TileS sample}
@end deffn

@cindex map
@anchor{map}
@deffn {MGL command} map udat vdat ['sch'='' @code{pnts=on}]
@deffnx {MGL command} map xdat ydat udat vdat ['sch'='' @code{pnts=on}]
Draws mapping plot for matrixes @{@var{udat}, @var{vdat} @} which parametrically depend on coordinates @var{xdat}, @var{ydat}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(udat,vdat). This plot is like Arnold diagram ???. If @code{pnts=off} then face is drawn otherwise the color ball at matrix knots are drawn. The size of @var{udat} and @var{vdat} must be the same. @sref{Map sample}
@end deffn

@cindex stfa
@anchor{stfa}
@deffn {MGL command} stfa re im @code{dn} ['sch'='' @code{pnts=on}]
@deffnx {MGL command} stfa xdat ydat re im @code{dn} ['sch'='' @code{pnts=on}]
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}. @sref{STFA sample}
@end deffn




@c ##################################################################
@node Vector fields @MGL{}, Other plotting @MGL{}, Dual plotting @MGL{}, MGL interface
@section Vector fields @MGL{}

These commands perform plotting of 2D and 3D vector fields. There are 6 generally different types of vector fields representations: simple vector field (@ref{vect}), vector field by dew-drops (@ref{dew}), flow threads (@ref{flow}), flow pipes (@ref{pipe}), vectors along a curve (@ref{traj}). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

The color is specified by the string argument @var{sch}. Previous color scheme is used by default. Parameter @var{flag} setup the hachures (arrows). It is combination of values: @code{1} for drawing bi-color arrow, @code{2} for drawing fixed length arrows, @code{4} for drawing arrows to the cell point, @code{8} for drawing arrows with center at cell point, @code{16} for drawing hachures with dots instead of arrows. 

The size of @var{udat}, @var{vdat} and @var{wdat} must be equal. The minor dimensions of arrays @var{xdat}, @var{ydat}, @var{zdat} and @var{udat} must be equal too. Arrays @var{xdat}, @var{ydat} and @var{zdat} can be vectors (not matrices as @var{udat}). The graphics is plotted for each z slice of @var{udat}, @var{vdat} for 2D case.

@cindex traj
@anchor{traj}
@deffn {MGL command} traj xdat ydat udat vdat ['sch'='' @code{zval=nan len=0}]
@deffnx {MGL command} traj xdat ydat zdat udat vdat wdat ['sch'='' @code{len=0}]
Draws vectors @{@var{udat}, @var{vdat}, @var{wdat}@} along a curve @var{xdat}, @var{ydat}, @var{zdat}. The length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. See also @code{vect}. @sref{Traj sample}
@end deffn

@cindex vect
@anchor{vect}
@deffn {MGL command} vect udat vdat ['sch'='' @code{zval=nan flag=0}]
@deffnx {MGL command} vect xdat ydat udat vdat ['sch'='' @code{zval=nan flag=0}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zval}. The length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of arrows depend on @ref{meshnum}. See also @ref{flow}, @ref{dew}, @ref{vectc}. @sref{Vect sample}
@end deffn

@deffn {MGL command} vect udat vdat wdat ['sch'='' @code{flag=0}]
@deffnx {MGL command} vect xdat ydat zdat udat vdat wdat ['sch'='' @code{flag=0}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the length and color of arrows are proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Vect 3D sample}
@end deffn

@cindex vectc
@anchor{vectc}
@deffn {MGL command} vectc udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vectc xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vect, flow, pipe, dew}. @sref{VectC sample}
@end deffn

@deffn {MGL command} vectc udat vdat wdat ['sch'='']
@deffnx {MGL command} vectc xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectC 3D sample}
@end deffn

@cindex vectl
@anchor{vectl}
@deffn {MGL command} vectl udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vectl xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vectc, flow, pipe, dew}. @sref{Vect sample}
@end deffn

@deffn {MGL command} vectl udat vdat wdat ['sch'='']
@deffnx {MGL command} vectl xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectL 3D sample}
@end deffn

@cindex dew
@anchor{dew}
@deffn {MGL command} dew udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dew xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws dew-drops for plane vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zval}. The color of drops is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of drops depend on @ref{meshnum}. Note that this is very expensive plot in memory usage and creation time! See also @ref{vect}. @sref{Dew sample}
@end deffn

@cindex flow
@anchor{flow}
@deffn {MGL command} flow udat vdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} flow xdat ydat udat vdat ['sch'='' @code{num=5 zval=nan}]
Draws plane flow threads for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of threads is proportional to @var{num}. The color of lines is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} flow udat vdat wdat ['sch'='' @code{num=3}]
@deffnx {MGL command} flow xdat ydat zdat udat vdat wdat ['sch'='' @code{num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn

@deffn {MGL command} flow @code{x0 y0} udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} flow @code{x0 y0} xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane flow threads for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} from point @{@var{x0}, @var{y0}@} at level @var{z=zVal}. The color of lines is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deffnx {MGL command} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
Draws flow thread from point @{@var{x0}, @var{y0}, @var{z0}@}. Arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn


@cindex pipe
@anchor{pipe}
@deffn {MGL command} pipe udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
@deffnx {MGL command} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
Draws plane flow pipes for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of pipes is proportional to @var{num}. The color of pipes is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. See also @code{vect, vectc, pipe}. @sref{Pipe sample}
@end deffn

@deffn {MGL command} pipe udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
@deffnx {MGL command} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Pipe 3D sample}
@end deffn


@c ##################################################################
@node Other plotting @MGL{}, Nonlinear fitting @MGL{}, Vector fields @MGL{}, MGL interface
@section Other plotting @MGL{}

These commands perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot) or quadrangular mesh (QuadPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@cindex densx
@cindex densy
@cindex densz
@anchor{densz} @anchor{densy} @anchor{densx}
@deffn {MGL command} densx dat ['sch'='' @code{val=nan}]
@deffnx {MGL command} densy dat ['sch'='' @code{val=nan}]
@deffnx {MGL command} densz dat ['sch'='' @code{val=nan}]
These plotting commands draw density plot in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{cont[xyz], contf[xyz]}, @ref{dens}. @sref{Dens projection sample}
@end deffn

@cindex contx
@cindex conty
@cindex contz
@anchor{contz} @anchor{conty} @anchor{contx}
@deffn {MGL command} contx dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} conty dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw contour lines in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], contf[xyz]}, @ref{cont}. @sref{Cont projection sample}
@end deffn

@cindex contfx
@cindex contfy
@cindex contfz
@anchor{contfz} @anchor{contfy} @anchor{contfx}
@deffn {MGL command} contfx dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contfy dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contfz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw solid contours in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], cont[xyz]}, @ref{contf}.
@end deffn

@cindex dots
@anchor{dots}
@deffn {MGL command} dots xdat ydat zdat ['sch'='']
@deffnx {MGL command} dots xdat ydat zdat adat ['sch'='']
Draws the arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Variable @var{adat}[i] set transparency for dots. See also @ref{crust}, @ref{mark}, @ref{plot}. @sref{Dots sample}
@end deffn

@cindex crust
@anchor{crust}
@deffn {MGL command} crust xdat ydat zdat ['sch'='']
Reconstructs and draws the surface for arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. See also @ref{dots}, @ref{triplot}. @sref{Crust sample}
@end deffn

@cindex triplot
@anchor{triplot}
@deffn {MGL command} triplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} triplot idat xdat ydat zdat ['sch'='']
@deffnx {MGL command} triplot idat xdat ydat zdat cdat ['sch'='']
Draws the surface of triangles. Triangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. First dimensions of @var{idat} must be 3 or greater. See also @code{dots, crust, quadplot}. Parameter @var{cdat} set the colors of triangles (if @var{idat}.ny=@var{cdat}.nx) or colors of vertexes (if @var{xdat}.nx=@var{cdat}.nx). See also @ref{dots}, @ref{crust}, @ref{quadplot}, @ref{tricont}.
@end deffn

@cindex tricont
@anchor{tricont}
@deffn {MGL command} tricont vdat idat xdat ydat zdat cdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} tricont vdat idat xdat ydat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} tricont idat xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Draws contour lines for surface of triangles at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Triangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k (or @var{num} contours equidistantly distributed in range [@var{Cmin}, @var{Cmax}].). See also @ref{triplot}, @ref{cont}.
@end deffn

@cindex quadplot
@anchor{quadplot}
@deffn {MGL command} quadplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} quadplot idat xdat ydat zdat ['sch'='']
@deffnx {MGL command} quadplot idat xdat ydat zdat cdat ['sch'='']
Draws the surface of quadrangles. Quadrangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. First dimensions of @var{idat} must be 4 or greater. See also @code{triplot, dots, crust}. Parameter @var{cdat} set the colors of triangles (if @var{idat}.ny=@var{cdat}.nx) or colors of vertexes (if @var{xdat}.nx=@var{cdat}.nx). See also @ref{triplot}.
@end deffn

@cindex fplot
@anchor{fplot}
@deffn {MGL command} fplot 'y(x)' ['pen'='' @code{zval=nan num=100}]
Draws command function @samp{y(x)} at plane z=@var{zval} where @samp{x} variable is changed in @code{xrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @ref{plot}.
@end deffn

@deffn {MGL command} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='' @code{num=100}]
Draws command parametrical curve @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@} where @samp{t} variable is changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @ref{plot}.
@end deffn

@cindex fsurf
@anchor{fsurf}
@deffn {MGL command} fsurf 'z(x,y)' ['sch'='' @code{num=100}]
Draws command surface for function @samp{z(x,y)} where @samp{x}, @samp{y} variable are changed in @code{xrange, yrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @ref{surf}.
@end deffn

@deffn {MGL command} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='' @code{num=100}]
Draws command parametrical surface @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@} where @samp{u}, @samp{v} variable are changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @ref{surf}.
@end deffn


@c ##################################################################
@node Nonlinear fitting @MGL{}, Data create @MGL{}, Other plotting @MGL{}, MGL interface
@section Nonlinear fitting @MGL{}

These commands fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation function @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The command @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used.

Commands @ref{fit} and @ref{fits} do not draw the obtained data themselves. They fill the data @var{out} by formula @samp{f} with found coefficients. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the bounding box. Number of points in @var{out} is selected as maximal value of @var{out} size or 100. Also you may print the last formula with found coefficients by @code{putsfit} command. @sref{Fitting sample}

The dimensions of arrays must be at least the same as the number of specified arrays @var{xdat}, @var{ydat}, @var{zdat}. Also the fitting only along specified directions will be performed (for example, along x and y if only @var{xdat} and @var{ydat} are specified). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x.


@cindex fits
@anchor{fits}
@deffn {MGL command} fits adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat zdat adat sdat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor @var{sdat}[i,j,k].
@end deffn

@cindex fit
@anchor{fit}
@deffn {MGL command} fit adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat zdat adat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor =1.
@end deffn

@cindex putsfit
@anchor{putsfit}
@deffn {MGL command} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
Print last fitted formula with found coefficients (as numbers) at position @{@var{x}, @var{y}@}. The string @var{pre} will be printed before formula. All other parameters are the same as in @ref{Text printing @MGL{}}.
@end deffn


@c ##################################################################
@node Data create @MGL{}, Data filling @MGL{}, Nonlinear fitting @MGL{}, MGL interface
@section Data create @MGL{}

@cindex new
@anchor{new}
@deffn {MGL command} new dat [@code{nx=1 ny=1 nz=1}]
Creates or recreates the array @var{dat} with specified size and fills it by zero. This command does nothing if one of parameters @var{nx}, @var{ny}, @var{nz} is zero or negative.
@end deffn

@cindex var
@anchor{var}
@deffn {MGL command} var dat @code{num v1 [v2=nan]}
Creates new variable with name @var{dat} for one-dimensional array of size @var{num}. Array elements are equidistantly distributed in range [@var{v1}, @var{v2}]. If @var{v2}=@code{nan} then @var{v2=v1} is used. 
@end deffn

@cindex list
@anchor{list}
@deffn {MGL command} list dat @code{v1 ...}
Creates new variable with name @var{dat} and fills it by numeric values of command arguments @code{v1 ...}. Command can create one-dimensional and two-dimensional arrays with arbitrary values. For creating 2d array the user should use delimiter @samp{|} which means that the following values lie in next row. Array sizes are [maximal of row sizes * number of rows]. For example, command @code{list 1 | 2 3} creates the array [1 0; 2 3]. Note, that the maximal number of arguments is 1000. 
@end deffn

@deffn {MGL command} list dat d1 ...
Creates new variable with name @var{dat} and fills it by data values of arrays of command arguments @var{d1 ...}. Command can create two-dimensional or three-dimensional (if arrays in arguments are 2d arrays) arrays with arbitrary values. Minor dimensions of all arrays in arguments should be equal to dimensions of first array d1. In the opposite case the argument will be ignored. Note, that the maximal number of arguments is 1000. 
@end deffn

@cindex copy
@anchor{copy}
@deffn {MGL command} copy dat1 dat2 ['eq'='' @code{on_axis=on}]
@deffnx {MGL command} copy dat1 @code{val}
Creates new variable with name @var{dat1} and fills it by data values of array @var{dat2}. At this, if parameter @var{eq} is specified then the data will be modified by corresponding formula by the same way as in @ref{fill} command (for @code{on_axis=on}) or in @ref{modify} command (for @code{on_axis=off}).
@end deffn

@cindex idset
@anchor{idset}
@deffn {MGL command} idset dat 'ids'
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deffn

@cindex info
@anchor{info}
@deffn {MGL command} info dat [@code{detail=off}]
Display information (sizes, maximum/minimum, momentums and so on) about the data dat. Show brief information by default (if @code{detail=off}).
@end deffn

@deffn {MGL command} info 'text'
Display @var{text} as information (warning).
@end deffn

@c ------------------------------------------------------------------
@node Data filling @MGL{}, Rearrange data @MGL{}, Data create @MGL{}, MGL interface
@section Data filling @MGL{}
@cindex fill
@cindex modify

@cindex fill
@anchor{fill}
@deffn {MGL command} fill dat v1 v2 ['dir'='x']
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deffn

@deffn {MGL command} fill dat 'eq'
@deffnx {MGL command} fill dat 'eq' vdat
@deffnx {MGL command} fill dat 'eq' vdat wdat
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in @emph{bounding box} (in difference from @code{modify} commands). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}.
@end deffn

@cindex modify
@anchor{modify}
@deffn {MGL command} modify dat 'eq' [@code{dim=0}]
@deffnx {MGL command} modify dat 'eq' vdat
@deffnx {MGL command} modify dat 'eq' vdat wdat
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1]. Variable @samp{u} is the original value of the array. If @var{dim}>0 is specified then modification will be fulfilled only for slices >=@var{dim}.
@end deffn


@cindex put
@anchor{put}
@deffn {MGL command} put dat @code{val [i=: j=: k=:]}
Function sets value(s) of array @var{dat}[@var{i}, @var{j}, @var{k}] = @var{val}. Negative indexes @var{i}, @var{j}, @var{k}=@samp{:} set the value @var{val} to whole range in corresponding direction(s). For example, @code{put dat val : 0 :} sets @var{dat}[i,0,j]=@var{val} for i=0...(@var{dat}.nx-1), j=0...(@var{dat}.nz-1).
@end deffn

@deffn {MGL command} put dat vdat [@code{i=: j=: k=:}]
Function copies value(s) from array @var{vdat} to the range of array @var{dat}. Negative indexes @var{i}, @var{j}, @var{k}=@samp{:} set the range in corresponding direction(s). At this minor dimensions of array @var{vdat} should be large than corresponding dimensions of array @var{dat}. For example, @code{put dat v : 0 :} sets @var{dat}[i,0,j]=@var{vdat}.ny>@var{dat}.nz ? @var{vdat}[i,j] : @var{vdat}[i], where i=0...(@var{dat}.nx-1), j=0...(@var{dat}.nz-1) and condition vdat.nx>=dat.nx is true.
@end deffn



@c ------------------------------------------------------------------
@node Rearrange data @MGL{}, File I/O @MGL{}, Data filling @MGL{}, MGL interface
@section Rearrange data @MGL{}

@cindex rearrange
@anchor{rearrange}
@deffn {MGL command} rearrange dat @code{mx [my=0 mz=0]}
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deffn

@cindex extend
@anchor{extend}
@deffn {MGL command} extend dat @code{n1 [n2=0]}
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deffn

@cindex transpose
@anchor{transpose}
@deffn {MGL command} transpose dat ['dim'='yxz']
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This command may be useful also for the reading of one-dimensional data.
@end deffn

@cindex squeeze
@anchor{squeeze}
@deffn {MGL command} squeeze dat @code{rx [ry=1 rz=1 sm=off]}
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly. Parameter @var{sm} set to use smoothing
@iftex
(i.e. @math{a_{out}[i]=\sum_{j=i}^{i+r}a[j]/r}) or not (i.e. @math{a_{out}[i]=a[j*r]}).
@end iftex
@ifnottex
(i.e. out[i]=\sum_@{j=i@}^@{i+r@} a[j]/r) or not (i.e. out[i]=a[j*r]).
@end ifnottex
@end deffn

@cindex crop
@anchor{crop}
@deffn {MGL command} crop dat @code{n1 n2} 'dir'
Cuts off edges of the data @var{i}<@var{n1} and @var{i}>@var{n2} if @var{n2}>0 or @var{i}>@code{n[xyz]}-@var{n2} if @var{n2}<=0 along direction @var{dir}.
@end deffn

@cindex delete
@anchor{delete}
@deffn {MGL command} delete dat
Deletes variable @var{dat} and makes its memory free. Can be useful for huge data arrays.
@end deffn

@deffn {MGL command} delete dat 'dir' @code{[pos=off num=0]}
Delete @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deffn

@cindex insert
@anchor{insert}
@deffn {MGL command} insert dat 'dir' @code{[pos=off num=0]}
Insert @var{num} slices along @var{dir}-direction at position @var{pos}.
@end deffn

@c ------------------------------------------------------------------
@node File I/O @MGL{}, Make another data @MGL{}, Rearrange data @MGL{}, MGL interface
@section File I/O @MGL{}

@cindex read
@anchor{read}
@deffn {MGL command} read dat 'fname'
Reads data from tab-separated text file with auto determining sizes of the data.
@end deffn

@deffn {MGL command} read dat 'fname' @code{mx [my=1 mz=1]}
Reads data from text file with specified data sizes. This command does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deffn

@cindex readmat
@anchor{readmat}
@deffn {MGL command} readmat dat 'fname' [@code{dim=2}]
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deffn

@cindex readall
@anchor{readall}
@deffn {MGL command} readall dat 'templ' @code{v1 v2 [dv=1 slice=off]}
Join data arrays from several text files. The file names are determined by function call @code{sprintf(fname,templ,val);}, where @var{val} changes from @var{v1} to @var{v2} with step @var{dv}. The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@deffn {MGL command} readall dat 'templ' @code{[slice=off]}
Join data arrays from several text files which filenames satisfied the template @var{templ} (for example, @var{templ}=@code{"t_*.dat"}). The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@cindex save
@anchor{save}
@deffn {MGL command} save dat 'fname'
Saves the whole data array to tab-separated text file.
@end deffn

@cindex readhdf
@anchor{readhdf}
@deffn {MGL command} readhdf dat 'fname' 'dname'
Reads data array named @var{dname} from HDF5 or HDF4 file @var{fname}.
@end deffn

@cindex savehdf
@anchor{savehdf}
@deffn {MGL command} savehdf dat 'fname' 'dname'
Saves data array named @var{dname} from HDF5 or HDF4 file @var{fname}.
@end deffn

@cindex import
@anchor{import}
@deffn {MGL command} import dat 'fname' 'sch' [@code{v1=0 v2=1}]
Reads data from bitmap file. The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{sch} (@pxref{Color scheme}).
@end deffn

@cindex export
@anchor{export}
@deffn {MGL command} export dat 'fname' 'sch' [@code{v1=0 v2=0}]
Saves data matrix to bitmap file. The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{sch} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deffn

@c ------------------------------------------------------------------
@node Make another data @MGL{}, Change data @MGL{}, File I/O @MGL{}, MGL interface
@section Make another data @MGL{}

@cindex combine
@anchor{combine}
@deffn {MGL command} combine res adat bdat
Returns direct multiplication of arrays (like, res[i,j] = adat[i]*bdat[j] and so on).
@end deffn

@cindex evaluate
@anchor{evaluate}
@deffn {MGL command} evaluate res dat idat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat kdat [@code{norm=on}]
Get array which values is result of interpolation of original array for coordinates from other arrays (for example, res[i,j]=dat[idat[i,j],jdat[i,j]]). All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in ranges [0,nx], [0,ny], [0,nz] correspondingly.
@end deffn

@cindex hist
@anchor{hist}
@deffn {MGL command} hist res dat @code{num v1 v2 [nsub=0]}
@deffnx {MGL command} hist res dat wdat @code{num v1 v2 [nsub=0]}
Creates @var{num}-th points distribution @var{res} of the data values of @var{dat} in range [@var{v1}, @var{v2}]. Array @var{wdat} specifies weights of the data elements (all weight is 1 if @var{wdat} is not specified). Parameter @var{nsub} define the number of additional interpolated points (for smoothness of histogram).
@end deffn

@deffn {MGL command} hist res xdat adat
@deffnx {MGL command} hist res xdat ydat adat
@deffnx {MGL command} hist res xdat ydat zdat adat
Creates distribution @var{res} of the data values of @var{adat} in axis range [Min, Max]. Array @var{adat} look like weights of the data points.
@end deffn


@cindex momentum
@anchor{momentum}
@deffn {MGL command} momentum res dat 'how' ['dir'='z']
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum. The momentum is defined like as
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) a_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) a_ij/ \sum_ij a_ij
@end ifnottex
if @var{var}=@samp{z} and so on. Coordinates @samp{x}, @samp{y}, @samp{z} are data indexes normalized in range [0,1].
@end deffn

@cindex sum
@anchor{sum}
@deffn {MGL command} sum res dat 'dir'
Gets array which is the result of summation in given direction or direction(s).
@end deffn
@cindex max
@anchor{max}
@deffn {MGL command} max res dat 'dir'
Gets array which is the maximal data values in given direction or direction(s).
@end deffn
@cindex min
@anchor{min}
@deffn {MGL command} min res dat 'dir'
Gets array which is the minimal data values in given direction or direction(s).
@end deffn

@cindex resize
@anchor{resize}
@deffn {MGL command} resize res dat @code{mx [my=1 mz=1]}
Makes array @var{res} of sizes @var{mx}, @var{my}, @var{mz} with interpolated data of array @var{dat}. 
@end deffn

@cindex subdata
@anchor{subdata}
@deffn {MGL command} subdata res dat @code{xx [yy=: zz=:]}
Extracts sub-array data @var{res} from the original data @var{dat} array keeping fixed positive index. For example @code{subdata a b : 2} extracts 3d row (indexes are zero based), @code{subdata a b 4 :} extracts 5th column, @code{subdata a b : : 3} extracts 4th slice and so on. Note that symbol @samp{:} is defined @samp{:}=@code{-1} in MGL.
@end deffn

@cindex trace
@anchor{trace}
@deffn {MGL command} trace res dat
Gets array of diagonal elements @var{dat}[i,i] (for 2D case) or @var{dat}[i,i,i] (for 3D case) where i=0...nx-1. Function return copy of @var{dat} for 1D case. Data array must have dimensions @var{dat}.ny, @var{dat}.nz >= @var{dat}.nx or @var{dat}.ny, @var{dat}.nz = 1.
@end deffn

@cindex transform
@anchor{transform}
@deffn {MGL command} transform dat 'type' real imag
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{s} is Sine transform, @samp{c} is Cosine transform, @samp{h} is Hankel transform, @samp{n} or @samp{ } is no transformation.
@end deffn

@cindex transforma
@anchor{transforma}
@deffn {MGL command} transforma dat 'type' ampl phase
The same as previous but with specified amplitude @var{ampl} and phase @var{phase} of complex numbers.
@end deffn

@cindex stfad
@anchor{stfad}
@deffn {MGL command} stfad res real imag @code{dn} ['dir'='x']
Short time Fourier transformation for real and imaginary parts. Output  is amplitude of partial Fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deffn

@cindex pde
@anchor{pde}
@deffn {MGL command} pde res 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Coordinates of the equation (and the solution) are supposed to be in the bounding box. Note, that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for field amplitude |u|. This allow one solve nonlinear problems -- for example, for non-linear Shrodinger equation you may set @code{ham='p^2+q^2-u^2'}. You may specify imaginary part for wave absorption, like @code{ham = 'p^2+i*x*(x>0)'}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}). @sref{PDE sample}
@end deffn

@cindex ray
@anchor{ray}
@deffn {MGL command} ray res 'ham' @code{x0 y0 z0 p0 q0 v0 [dt=0.1 tmax=10]}
Solves GO ray equation like d@emph{r}/dt = d @var{ham}/d@emph{p}, d@emph{p}/dt = -d @var{ham}/d@emph{r}. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordiantes @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @{@var{x0}, @var{y0}, @var{z0}, @var{p0}, @var{q0}, @var{v0}@}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}. See also @ref{pde}. @sref{Beam tracing sample}
@end deffn

@cindex qo2d
@anchor{qo2d}
@deffn {MGL command} qo2d res 'ham' ini_re ini_im ray [@code{r=1 k0=100} xx=0 yy=0]
Solves equation du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudo-differential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Parameters @var{ray} set the reference ray, i.e. the ray around which the accompanied coordinate system will be maked. You may use, for example, the array created by @ref{ray} function. Note, that the reference ray @strong{must be} smooth enough to make accompanied coodrinates unambiguity. Otherwise errors in the solution may appear. If @var{xx} and @var{yy} are non-zero then Cartesian coordinates for each point will be written into them. @sref{Beam tracing sample} 
@end deffn

@cindex jacobian
@anchor{jacobian}
@deffn {MGL command} jacobian res xdat ydat [zdat=0]
Computates the Jacobian for transformation @{i,j,k@} to @{@var{xdat},@var{ydat},@var{zdat}@} where initial coordinates  @{i,j,k@} are data indexes normalized in range [0,1]. The Jacobian is determined by formula det||@math{dr_\alpha/d\xi_\beta}|| where @math{r}=@{@var{xdat},@var{ydat},@var{zdat}@} and @math{\  xi}=@{i,j,k@}. All dimensions must be the same for all data arrays. Data must be 3D if all 3 arrays @{@var{xdat},@var{ydat},@var{zdat}@} are specified or 2D if only 2 arrays @{@var{xdat},@var{ydat}@} are specified.
@end deffn



@c ------------------------------------------------------------------
@node Change data @MGL{}, Operators @MGL{}, Make another data @MGL{}, MGL interface
@section Change data @MGL{}

These commands change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondingly.

@cindex cumsum
@anchor{cumsum}
@deffn {MGL command} cumsum dat 'dir'
Cumulative summation of the data in given direction or directions.
@end deffn
@cindex integrate
@anchor{integrate}
@deffn {MGL command} integrate dat 'dir'
Integrates (like cumulative summation) the data in given direction or directions.
@end deffn
@cindex diff
@anchor{diff}
@deffn {MGL command} diff dat 'dir'
Differentiates the data in given direction or directions.
@end deffn
@deffn {MGL command} diff dat xdat ydat [zdat=0]
Differentiates the data @var{dat} specified parametrically in direction @var{xdat} with @var{ydat}, @var{zdat}=constant. Parameter @var{zdat} can be omitted that correspond to 2D case. Parametrical differentiation uses the formula (for 2D case): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)} where @math{a_i=da/di, a_j=da/dj} denotes usual differentiation along 1st and 2nd dimensions. The similar formula is used for 3D case. Note, that you may change the order of arguments -- for example, if you have 2D data a(i,j) which depend on coordinates @{x(i,j), y(i,j)@} then usual derivative along @samp{x} will be @code{diff a x y} and usual derivative along @samp{y} will be @code{diff a y x}.
@end deffn

@cindex diff2
@anchor{diff2}
@deffn {MGL command} diff2 dat 'dir'
Double-differentiates (like Laplace operator) the data in given direction.
@end deffn

@cindex sinfft
@anchor{sinfft}
@deffn {MGL command} sinfft dat 'dir'
Do Sine transform of the data in given direction or directions. The Sine transform is @math{\sum a_i \sin(k i)}.
@end deffn
@cindex cosfft
@anchor{cosfft}
@deffn {MGL command} cosfft dat 'dir'
Do Cosine transform of the data in given direction or directions. The Cosine transform is @math{\sum a_i \cos(k i)}.
@end deffn
@cindex hankel
@anchor{hankel}
@deffn {MGL command} hankel dat 'dir'
Do Hankel transform of the data in given direction or directions. The Hankel transform is @math{\sum a_i J_0(k i)}.
@end deffn


@cindex swap
@anchor{swap}
@deffn {MGL command} swap dat 'dir'
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deffn
@cindex roll
@anchor{roll}
@deffn {MGL command} roll dat 'dir' num
Rolls the data along direction 'dir'. Resulting array will be out[i] = ini[(i+num)%nx] if @code{dir='x'}.
@end deffn

@cindex mirror
@anchor{mirror}
@deffn {MGL command} mirror dat 'dir'
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deffn

@cindex sew
@anchor{sew}
@deffn {MGL command} sew dat ['dir'='xyz' @code{da=2*pi}]
Remove value steps (like phase jumps after inverse trigonometric commands) with period @var{da} in given direction.
@end deffn
@cindex smooth
@anchor{smooth}
@deffn {MGL command} smooth data @code{type} ['dir'='xyz']
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @samp{0} does nothing, @samp{1} linear averaging by 3 points, @samp{2} linear averaging by 5 points, @samp{3} quadratic averaging by 5 points.
@end deffn

@cindex envelop
@anchor{envelop}
@deffn {MGL command} envelop dat ['dir'='x']
Find envelop for data values along direction @var{dir}. Only one direction can be specified at once.
@end deffn

@cindex normsl
@anchor{normsl}
@deffn {MGL command} normsl dat @code{v1 v2} ['dir'='z' @code{keep=on sym=off}]
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deffn

@cindex norm
@anchor{norm}
@deffn {MGL command} norm dat @code{v1 v2 [sym=off dim=0]}
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deffn

@c ------------------------------------------------------------------
@node Operators @MGL{}, Program flow @MGL{}, Change data @MGL{}, MGL interface
@section Operators @MGL{}

@cindex multo
@anchor{multo}
@deffn {MGL command} multo dat dat2
Multiplies the data by the other one for each element.
@end deffn
@deffn {MGL command} multo dat @code{val}
Multiplies each element by the number.
@end deffn

@cindex divto
@anchor{divto}
@deffn {MGL command} divto dat dat2
Divides the data by the other one for each element.
@end deffn
@deffn {MGL command} divto dat @code{val}
Divides each element by the number.
@end deffn

@cindex addto
@anchor{addto}
@deffn {MGL command} addto dat dat2
Adds the other data.
@end deffn
@deffn {MGL command} addto dat @code{val}
Adds the number to each element.
@end deffn

@cindex subto
@anchor{subto}
@deffn {MGL command} subto dat dat2
Subtracts the other data.
@end deffn
@deffn {MGL command} subto dat @code{val}
Subtracts the number to each element.
@end deffn

@c ------------------------------------------------------------------
@node Program flow @MGL{}, Command options @MGL{}, Operators @MGL{}, MGL interface
@section Program flow @MGL{}

These commands control program flow, like, conditions, cycles, define script arguments and so on.

@cindex chdir
@anchor{chdir}
@deffn {MGL command} chdir 'path'
Changes the current directory to @var{path}.
@end deffn

@cindex define
@anchor{define}
@deffn {MGL command} define $N smth
Sets @var{N}-th script argument to @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present). Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@deffn {MGL command} define name smth
Create scalar variable @code{name} which have the numeric value of @code{smth}. Later you can use this variable as usual number. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@cindex defchr
@anchor{defchr}
@deffn {MGL command} defchr $N smth
Sets @var{N}-th script argument to character with value evaluated from @var{smth}. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@cindex defnum
@anchor{defnum}
@deffn {MGL command} defnum $N smth
Sets @var{N}-th script argument to number with value evaluated from @var{smth}. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@cindex defpal
@anchor{defpal}
@deffn {MGL command} defpal $N smth
Sets @var{N}-th script argument to palette character at position evaluated from @var{smth}. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn

@cindex call
@anchor{call}
@deffn {MGL command} call 'fname' [ARG1 ARG2 ... ARG9]
Executes function @var{fname} (or script if function is not found). Optional arguments will be passed to functions. See also @ref{func}.
@end deffn
@cindex func
@anchor{func}
@deffn {MGL command} func 'fname' [narg=0]
Define the function @var{fname} and number of required arguments. The arguments will be placed in script parameters $1, $2, ... $9. Note, you should stop script execution before function definition(s) by command @ref{stop}. See also @ref{return}.
@end deffn
@cindex return
@anchor{return}
@deffn {MGL command} return
Return from the function. See also @ref{func}.
@end deffn


@cindex if
@anchor{if}
@deffn {MGL command} if dat 'cond'
Starts block which will be executed if @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} if @code{val}
Starts block which will be executed if @code{val} is nonzero.
@end deffn
@cindex elseif
@anchor{elseif}
@deffn {MGL command} elseif dat 'cond'
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} elseif @code{val}
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @code{val} is nonzero.
@end deffn
@cindex else
@anchor{else}
@deffn {MGL command} else
Starts block which will be executed if previous @code{if} or @code{elseif} is false.
@end deffn
@cindex endif
@anchor{endif}
@deffn {MGL command} endif
Finishes @code{if/elseif/else} block.
@end deffn

@cindex for
@anchor{for}
@deffn {MGL command} for $N @code{v1 v2 [dv=1]}
Starts cycle with $@var{N}-th argument changing from @var{v1} to @var{v2} with the step @var{dv}. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@deffn {MGL command} for $N dat
Starts cycle with $@var{N}-th argument changing for @var{dat} values. Here @var{N} is digit (0...9) or alpha (a...z).
@end deffn
@cindex next
@anchor{next}
@deffn {MGL command} next
Finishes @code{for} cycle.
@end deffn

@cindex once
@anchor{once}
@deffn {MGL command} once @code{val}
The code between @code{once on} and @code{once off} will be executed only once. Useful for large data manipulation in programs like UDAV.
@end deffn
@cindex stop
@anchor{stop}
@deffn {MGL command} stop
Terminate execution.
@end deffn

@c ------------------------------------------------------------------
@node  Command options @MGL{}, Suffixes, Program flow @MGL{}, MGL interface
@section Command options @MGL{}

Command options allow the easy setup of the plot by changing of global settings only for this plot. Options are specified at the end of string. Each option is separated from the previous text by symbol @samp{;}. Options work so that them remember the current settings, change settings as it being set in the option, execute command and return the original settings back. So, the options usage for data handling commands or for graphics setup commands is useless.

The most useful options are @code{xrange, yrange, zrange}. They sets the boundaries for data change. This boundaries are used for automatically filled variables. So, these options allow one to change the position of some plots. For example, in command @code{plot y; xrange 0.1 0.9} the x coordinate will be equidistantly distributed in range 0.1 ... 0.9.

The full list of options are:
@cindex alpha
@cindex alphadef
@deffn {MGL option} alpha @code{val}
@deffnx {MGL option} alphadef @code{val}
Sets alpha value (transparency) of the plot. The value should be in range [0, 1]. See also @ref{alphadef}.
@end deffn
@cindex ambient
@deffn {MGL option} ambient @code{val}
Sets brightness of ambient light for the plot. The value should be in range [0, 1]. See also @ref{ambient}.
@end deffn
@cindex crange
@deffn {MGL option} crange @code{val1 val2}
Sets boundaries of color change for the plot. See also @ref{crange}.
@end deffn
@cindex xrange
@deffn {MGL option} xrange @code{val1 val2}
Sets boundaries of x coordinate change for the plot. See also @ref{xrange}.
@end deffn
@cindex yrange
@deffn {MGL option} yrange @code{val1 val2}
Sets boundaries of y coordinate change for the plot. See also @ref{yrange}.
@end deffn
@cindex zrange
@deffn {MGL option} zrange @code{val1 val2}
Sets boundaries of z coordinate change for the plot. See also @ref{zrange}.
@end deffn
@cindex cut
@deffn {MGL option} cut @code{val}
Sets whether to cut or to project the plot points lying outside the bounding box. See also @ref{cut}.
@end deffn
@cindex fontsize
@deffn {MGL option} fontsize @code{val}
Sets the size of text. See also @ref{font}.
@end deffn
@cindex marksize
@deffn {MGL option} marksize @code{val}
Sets the size of marks. See also @ref{marksize}.
@end deffn
@cindex meshnum
@deffn {MGL option} meshnum @code{val}
Work like @ref{meshnum} command.
@end deffn
@cindex legend
@deffn {MGL option} legend 'txt'
Adds string 'txt' to internal legend accumulator. The style of described line and mark is taken from arguments of the last @ref{1D plotting @MGL{}} command. See also @ref{legend}.
@end deffn

@c ------------------------------------------------------------------
@node  Suffixes, Utilities, Command options @MGL{}, MGL interface
@section Suffixes for variable

Suffixes can get some numerical value (like its size, maximal or minimal value, the sum of elements and so on) of the data array in variable and use it later as usual number in command arguments. The suffixes start from point @samp{.} right after (without spaces) variable name or its sub-array. For example, @code{a.nx} give the x-size of data @var{a}, @code{b(1).max} give maximal value of second row of variable @var{b}, @code{(c(:,0)^2).sum} give the sum of squares of elements in the first column of @var{c} and so on.

The full list of suffixes are:
@table @strong
@item nx, ny, nz
Give the data size in x-, y-, z-direction correspondingly.
@item max
Give maximal value of the data.
@item min
Give minimal value of the data.
@item sum
Give sum of data values.
@item a
Give first value of data array.
@item fst
Give first nonzero value of data array.
@item lst
Give last nonzero value of data array.
@item mx, my, mz
Give x-, y-, z-position of data maximum.
@item ax, ay, az, aa
Give x-, y-, z-position of data mass center or average data value.
@item wx, wy, wz, wa
Give width in x-, y-, z-direction or data dispersion value.
@item sx, sy, sz, sa
Give skewness in x-, y-, z-direction or data skewness value.
@item kx, ky, kz, ka
Give kurtosis in x-, y-, z-direction or data kurtosis value.
@end table

@c ------------------------------------------------------------------
@node  Utilities, , Suffixes, MGL interface
@section Utilities for parsing MGL

MathGL library provides several tools for parsing MGL scripts. There is tools saving it to bitmap (@code{mgl2png}, @code{mgl2gif}) or vectorial (@code{mgl2eps}, @code{mgl2svg}) images. Tool @code{mglview} show MGL script and allow to rotate and setup the image. Also you can translate MGL script to C++ file by help of @code{mgl2cpp} tool.

All of this tools have similar set of arguments. First argument is name of script file, next argument is optional output file name, last arguments are options. There are options for setting script parameters (it is @code{$0, $1, ... $9}) and locale settings. The script parameters have format @samp{-Nval}. Here N=0,1...9 is parameter ID and val is its value. For example, option @samp{-1test} set to substitute @samp{test} instead of @code{$1} in the script. Option -Lval set locale to val. For example, @samp{-Lutf8} will set UTF-8 locale for script.

Additionally you can create animated GIF file or a set of JPEG files with names @samp{frameNNNN.jpg} (here @samp{NNNN} is frame index). You should use @code{mgl2gif} tool and specify the values of @code{$0} parameter for making animation. Values of the parameter @code{$0} can be specified inside the script by comment @code{##a val} for each value @code{val} (one comment for one value) or by option(s) @samp{-Aval}. Also you can specify a cycle for animation by comment @code{##c v1 v2 dv} or by option @code{-Cn1:n2}. Tool @code{mgl2gif} will execute script several times (once for each specified value of @code{$0}) and save result in animated GIF file. For saving each frame in JPEG just add command @code{write ''} at the end of the script.

