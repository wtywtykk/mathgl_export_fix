@c ------------------------------------------------------------------
@chapter MathGL examples

This chapter contain information about basic and advanced MathGL, hints and samples for all types of graphics. I recommend you read first 2 sections one after another and at least look on @ref{Hints} section. Also I recommend you to look at @ref{General concepts} and @ref{FAQ}.

@menu
* Basic usage::
* Advanced usage::
* Data handling::
* Data plotting::
* 1D samples::
* 2D samples::
* 3D samples::
* Vector field samples::
* Hints::
* FAQ::
@end menu

@c ------------------------------------------------------------------
@node Basic usage, Advanced usage, , Examples
@section Basic usage

MathGL library can be used by several manners. Each has positive and negative sides:
@itemize @bullet
@item
@emph{Using of MathGL library features for creating graphical window (requires FLTK, Qt or GLUT libraries).}

Positive side is the possibility to view the plot at once and to modify it (rotate, zoom or switch on transparency or lighting) by hand or by mouse. Negative sides are: the need  of X-terminal and limitation consisting in working with the only one set of data at a time.

@item
@emph{Direct writing to file in bitmap or vector format without creation of graphical window.}

Positive aspects are: batch processing of similar data set (for example, a set of resulting data files for different calculation parameters), running from the console program (including the cluster calculation), fast and automated drawing, saving pictures for further analysis (or demonstration). Negative sides are: the usage of the external program for picture viewing. Also, the data plotting is non-visual. So, you have to imagine the picture (view angles, lighting and so on) before the plotting. I recommend to use graphical window for determining the optimal parameters of plotting on the base of some typical data set. And later use these parameters for batch processing in console program.

@item
@emph{Drawing in memory with the following displaying by other graphical program.}

In this case the programmer has more freedom in selecting the window libraries (not only FLTK, Qt or GLUT), in positioning and surroundings control and so on. I recommend to use such way for ``settled'' programs.

@item
@emph{Using FLTK or Qt widgets provided by MathGL}

Here one can use a set of standard widgets which support export to many file formats, copying to clipboard, handle mouse and so on. 
@end itemize

MathGL drawing can be created not only by object oriented languages (like, C++ or Python), but also by pure C or Fortran-like languages. The usage of last one is mostly identical to usage of classes (except the different function names). But there are some differences. C functions must have argument HMGL (for graphics) and/or HMDT (for data arrays) which specifies the object for drawing or manipulating (changing). Fortran users may regard these variables as integer. So, firstly the user has to create this object by function mgl_create_*() and has to delete it after the using by function mgl_delete_*().
@c Also, all arguments of C function have to be defined. So there are several functions with practically identical names doing practically the same. But some of them have simplified interface for the quick plotting and some of them have access to all plotting parameters for manual tunning.

Let me consider the aforesaid in more detail.

@menu
* Using MathGL window::
* Drawing to file::
* Animation::
* Drawing in memory::
* Using QMathGL::
* MathGL and PyQt::
@end menu


@c ------------------------------------------------------------------
@node Using MathGL window, Drawing to file, , Basic usage
@subsection Using MathGL window
@cindex window
@cindex widgets

The ``interactive'' way of drawing in MathGL consists in window creation  with help of class @code{mglWindow} or @code{mglGLUT} (see @ref{Widget classes}) and the following drawing in this window. There is a corresponding code:
@verbatim
#include <mgl/window.h>
int sample(mglGraph *gr)
{
  gr->Rotate(60,40);
  gr->Box();
  return 0;
}
//-----------------------------------------------------
int main(int argc,char **argv)
{
  mglWindow gr(sample,"MathGL examples");
  return gr.Run();
}
@end verbatim
Here function @code{sample} is defined. This function does all drawing. Other function @code{main} is entry point function for console program. For compilation, just execute the command
@verbatim
gcc test.cpp -lmgl-wnd -lmgl
@end verbatim

Alternatively you can create yours own class inherited from class @code{mglDraw} and re-implement the function @code{Draw()} in it:
@verbatim
#include <mgl/window.h>
class Foo : public mglDraw
{
public:
  int Draw(mglGraph *gr);
};
//-----------------------------------------------------
int Foo::Draw(mglGraph *gr)
{
  gr->Rotate(60,40);
  gr->Box();
  return 0;
}
//-----------------------------------------------------
int main(int argc,char **argv)
{
  Foo foo;
  mglWindow gr(&foo,"MathGL examples");
  return gr.Run();
}
@end verbatim
Or use pure C-functions:
@verbatim
#include <mgl/mgl_cf.h>
int sample(HMGL gr)
{
  mgl_rotate(gr,60,40,0);
  mgl_box(gr);
}
int main(int argc,char **argv)
{
  HMGL gr;
  gr = mgl_create_graph_qt(sample,"MathGL examples",0);
  return mgl_qt_run();
/* generally I should call mgl_delete_graph() here,
 * but I omit it in main() function. */
}
@end verbatim

The similar code can be written for @code{mglGLUT} window (function @code{sample()} is the same):
@verbatim
#include <mgl/glut.h>
int main(int argc,char **argv)
{
  mglGLUT gr(sample,"MathGL examples");
  return 0;
}
@end verbatim

The rotation, shift, zooming, switching on/off transparency and lighting can be done with help of tool-buttons (for @code{mglWindow}) or by hot-keys: @samp{a}, @samp{d}, @samp{w}, @samp{s} for plot rotation, @samp{r} and @samp{f} switching on/off transparency and lighting. Press @samp{x} for exit (or closing the window).

In this example function @code{sample} rotates axes (@code{Rotate()}, @pxref{Transformation matrix}) and draws the bounding box (@code{Box()}). Drawing is placed in separate function since it will be used on demand when window canvas needs to be redrawn.

@c ------------------------------------------------------------------
@node Drawing to file, Animation, Using MathGL window, Basic usage
@subsection Drawing to file

Another way of using MathGL library is the direct writing of the picture to the file. It is most usable for plot creation during long calculation or for using of small programs (like Matlab or Scilab scripts) for visualizing repetitive sets of data. But the speed of drawing is much higher in comparison with a script language.

The following code produces a bitmap PNG picture:
@verbatim
#include <mgl/mgl.h>
int main(int ,char **)
{
  mglGraph gr;
  gr.Alpha(true);   gr.Light(true);
  sample(&gr);              // The same drawing function.
  gr.WritePNG("test.png");  // Don't forget to save the result!
  return 0;
}
@end verbatim
 For compilation, you need only libmgl library not the one with widgets
@verbatim
gcc test.cpp -lmgl
@end verbatim
This can be important if you create a console program in computer/cluster where X-server (and widgets) is inaccessible.

The only difference from the previous variant (using windows) is manual switching on the transparency  @code{Alpha} and lightning @code{Light}, if you need it. The usage of frames (see @ref{Animation}) is not advisable since the whole image is prepared each time. If function @code{sample} contains frames then only last one will be saved to the file. In principle, one does not need to separate drawing functions in case of direct file writing in consequence of the single calling of this function for each picture. However, one may use the same drawing procedure to create a plot with changeable parameters, to export in different file types, to emphasize the drawing code and so on. So, in future I will put the drawing in the separate function.

The code for export in vector EPS file looks the same:
@verbatim
#include <mgl/mgl.h>
int main(int ,char **)
{
  mglGraph gr;
  gr.Light(true);
  sample(&gr);              // The same drawing function.
  gr.WriteEPS("test.eps");  // Don't forget to save the result!
  return 0;
}
@end verbatim
The difference from the previous one is using other function @code{WriteEPS()} for EPS format instead of function @code{WritePNG()}. Also, there is no switching on of the plot transparency @code{Alpha} since EPS format does not support it.

@c ------------------------------------------------------------------
@node Animation, Drawing in memory, Drawing to file, Basic usage
@subsection Animation

Widget classes (@code{mglWindow}, @code{mglGLUT}) support a delayed drawing, when all plotting functions are called once at the beginning of writing to memory lists. Further program displays the saved lists faster. Resulting redrawing will be faster but it requires sufficient memory. Several lists (frames) can be displayed one after another (by pressing @samp{,}, @samp{.}) or run as cinema. To switch these feature on one needs to modify function @code{sample}:
@verbatim
int sample(mglGraph *gr)
{
  gr->NewFrame();             // the first frame
  gr->Rotate(60,40);
  gr->Box();
  gr->EndFrame();             // end of the first frame
  gr->NewFrame();             // the second frame
  gr->Box();
  gr->Axis("xy");
  gr->EndFrame();             // end of the second frame
  return gr->GetNumFrame();   // returns the frame number
}
@end verbatim
First, the function creates a frame @code{NewFrame()} for rotated axes and draws the bounding box. After the frame drawing the function @code{EndFrame()} @strong{must be} called! The second frame contains the bounding box and axes @code{Axis("xy")} in the initial (unrotated) coordinates. Function @code{sample} returns the number of created frames @code{GetNumFrame()}.

Note, that such kind of animation is rather slow and not well suitable for visualization of running calculations. For the last case one can use @code{Update()} function. The most simple case for doing this is to use @code{mglDraw} class and reimplement its @code{Calc()} method.
@verbatim
#include <mgl/window.h>
class Foo : public mglDraw
{
  mglPoint pnt;  // some result of calculation
public:
  mglGraph *Gr;  // graphics to be updated
  int Draw(mglGraph *gr);
  void Calc();
} foo;
//-----------------------------------------------------
int Foo::Calc()
{
  for(int i=0;i<30;i++)   // do calculation
  {
    sleep(2);           // which can be very long
    pnt = mglPoint(2*mgl_rnd()-1,2*mgl_rnd()-1);
    Gr->Update();        // update window
  }
}
//-----------------------------------------------------
int Foo::Draw(mglGraph *gr)
{
  gr->Line(mglPoint(),pnt,"Ar2");
  gr->Box();
  return 0;
}
//-----------------------------------------------------
int main(int argc,char **argv)
{
  mglWindow gr(&foo,"MathGL examples");
  foo.Gr = &gr;   foo.Run();
  return gr.Run();
}
@end verbatim


Pictures with animation can be saved in file(s) as well. You can: export in animated GIF, or save each frame in separate file (usually JPEG) and convert these files into the movie (for example, by help of ImageMagic). Let me show both methods.

The simplest methods is making animated GIF. There are 3 steps: (1) open GIF file by @code{StartGIF()} function; (2) create the frames by calling @code{NewFrame()} before and @code{EndFrame()} after plotting; (3) close GIF by @code{CloseGIF()} function. So the simplest code for ``running'' sinusoid will look like this:
@verbatim
#include <mgl/mgl.h>
int main(int ,char **)
{
  mglGraph gr;
  mglData dat(100);
  char str[32];
  gr.StartGIF("sample.gif");
  for(int i=0;i<40;i++)
  {
    gr.NewFrame();     // start frame
    gr.Box();          // some plotting
    for(int j=0;j<dat.nx;j++)
      dat.a[j]=sin(M_PI*j/dat.nx+M_PI*0.05*i);
    gr.Plot(dat,"b");
    gr.EndFrame();     // end frame
  }
  gr.CloseGIF();
  return 0;
}
@end verbatim

The second way is saving each frame in separate file (usually JPEG) and later make the movie from them. MathGL have special function for saving frames -- it is @code{WriteFrame()}. This function save each frame with automatic name @samp{frame0001.jpg, frame0002.jpg} and so on. Here prefix @samp{frame} is defined by @var{PlotId} variable of @code{mglGraph} class. So the similar code will look like this:
@verbatim
#include <mgl/mgl.h>
int main(int ,char **)
{
  mglGraph gr;
  mglData dat(100);
  char str[32];
  for(int i=0;i<40;i++)
  {
    gr.NewFrame();     // start frame
    gr.Box();          // some plotting
    for(int j=0;j<dat.nx;j++)
      dat.a[j]=sin(M_PI*j/dat.nx+M_PI*0.05*i);
    gr.Plot(dat,"b");
    gr.EndFrame();     // end frame
    gr.WriteFrame();   // save frame
  }
  return 0;
}
@end verbatim

Created files can be converted to movie by help of a lot of programs. For example, you can use ImageMagic (command @samp{convert frame*.jpg movie.mpg}), MPEG library, GIMP and so on.

Finally, you can use @code{mglconv} tool for doing the same with MGL scripts (@pxref{Utilities}).

@c ------------------------------------------------------------------
@node Drawing in memory, Using QMathGL, Animation, Basic usage
@subsection Drawing in memory

The last way of MathGL using is the drawing in memory. Class @code{mglGraph} allows one  to create a bitmap picture in memory. Further this picture can be displayed in window by some window libraries (like wxWidgets, FLTK, Windows GDI and so on). For example, the code for drawing in wxWidget library looks like:
@verbatim
void MyForm::OnPaint(wxPaintEvent& event)
{
  int w,h,x,y;
  GetClientSize(&w,&h);   // size of the picture
  mglGraph gr(w,h);

  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);
  sample(&gr,NULL);

  wxImage img(w,h,gr.GetBits(),true);
  ToolBar->GetSize(&x,&y);    // gets a height of the toolbar if any
  wxPaintDC dc(this);         // and draws it
  dc.DrawBitmap(wxBitmap(img),0,y);
}
@end verbatim
The drawing in other libraries is most the same.

For example, FLTK code will look like
@verbatim
void Fl_MyWidget::draw()
{
  mglGraph gr(w(),h());
  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);
  sample(&gr,NULL);
  fl_draw_image(gr.GetBits(), x(), y(), gr.GetWidth(), gr.GetHeight(), 3);
}
@end verbatim
Qt code will look like
@verbatim
void MyWidget::paintEvent(QPaintEvent *)
{
  mglGraph gr(w(),h());

  gr.Alpha(true);         // draws something using MathGL
  gr.Light(true);         gr.Light(0,mglPoint(1,0,-1));
  sample(&gr,NULL);

  // Qt don't support RGB format as is. So, let convert it to BGRN.
  long w=gr.GetWidth(), h=gr.GetHeight();
  unsigned char *buf = new uchar[4*w*h];
  gr.GetBGRN(buf, 4*w*h)
  QPixmap pic = QPixmap::fromImage(QImage(*buf, w, h, QImage::Format_RGB32));

  QPainter paint;
  paint.begin(this);  paint.drawPixmap(0,0,pic);  paint.end();
  delete []buf;
}
@end verbatim

@c ------------------------------------------------------------------
@node Using QMathGL, MathGL and PyQt, Drawing in memory, Basic usage
@subsection Using QMathGL

MathGL have several interface widgets for different widget libraries. There are QMathGL for Qt, Fl_MathGL for FLTK. These classes provide control which display MathGL graphics. Unfortunately there is no uniform interface for widget classes because all libraries have slightly different set of functions, features and so on. However the usage of MathGL widgets is rather simple. Let me show it on the example of QMathGL.

First of all you have to define the drawing function or inherit a class from @code{mglDraw} class. After it just create a window and setup QMathGL instance as any other Qt widget:
@verbatim
#include <QApplication>
#include <QMainWindow>
#include <QScrollArea>
#include <mgl/qt.h>
int main(int argc,char **argv)
{
  QApplication a(argc,argv);
  QMainWindow *Wnd = new QMainWindow;
  Wnd->resize(810,610);  // for fill up the QMGL, menu and toolbars
  Wnd->setWindowTitle("QMathGL sample");
  // here I allow to scroll QMathGL -- the case
  // then user want to prepare huge picture
  QScrollArea *scroll = new QScrollArea(Wnd);

  // Create and setup QMathGL
  QMathGL *QMGL = new QMathGL(Wnd);
//QMGL->setPopup(popup); // if you want to setup popup menu for QMGL
  QMGL->setDraw(sample);
  // or use QMGL->setDraw(foo); for instance of class Foo:public mglDraw
  QMGL->update();

  // continue other setup (menu, toolbar and so on)
  scroll->setWidget(QMGL);
  Wnd->setCentralWidget(scroll);
  Wnd->show();
  return a.exec();
}
@end verbatim

@c ------------------------------------------------------------------
@node MathGL and PyQt, , Using QMathGL, Basic usage
@subsection MathGL and PyQt

Generally SWIG based classes (including the Python one) are the same as C++ classes. However, there are few tips for using MathGL with PyQt. Below I place a very simple python code which demonstrate how MathGL can be used with PyQt. This code is mostly written by Prof. Dr. Heino Falcke. You can just copy it to a file @code{mgl-pyqt-test.py} and execute it from python shell by command @code{execfile("mgl-pyqt-test.py")}

@verbatim
from PyQt4 import QtGui,QtCore
from mathgl import *
import sys
app = QtGui.QApplication(sys.argv)
qpointf=QtCore.QPointF()

class hfQtPlot(QtGui.QWidget):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        self.img=(QtGui.QImage())
    def setgraph(self,gr):
        self.buffer='\t'
        self.buffer=self.buffer.expandtabs(4*gr.GetWidth()*gr.GetHeight())
        gr.GetBGRN(self.buffer,len(self.buffer))
        self.img=QtGui.QImage(self.buffer, gr.GetWidth(),gr.GetHeight(),QtGui.QImage.Format_ARGB32)
        self.update()
    def paintEvent(self, event):
        paint = QtGui.QPainter()
        paint.begin(self)
        paint.drawImage(qpointf,self.img)
        paint.end()

BackgroundColor=[1.0,1.0,1.0]
size=100
gr=mglGraph()
y=mglData(size)
#y.Modify("((0.7*cos(2*pi*(x+.2)*500)+0.3)*(rnd*0.5+0.5)+362.135+10000.)")
y.Modify("(cos(2*pi*x*10)+1.1)*1000.*rnd-501")
x=mglData(size)
x.Modify("x^2");

def plotpanel(gr,x,y,n):
    gr.SubPlot(2,2,n)
    gr.SetXRange(x)
    gr.SetYRange(y)
    gr.AdjustTicks()
    gr.Axis()
    gr.Box()
    gr.Label("x","x-Axis",1)
    gr.Label("y","y-Axis",1)
    gr.ClearLegend()
    gr.AddLegend("Legend: "+str(n),"k")
    gr.Legend()
    gr.Plot(x,y)


gr.Clf(BackgroundColor[0],BackgroundColor[1],BackgroundColor[2])
gr.SetPlotFactor(1.5)
plotpanel(gr,x,y,0)
y.Modify("(cos(2*pi*x*10)+1.1)*1000.*rnd-501")
plotpanel(gr,x,y,1)
y.Modify("(cos(2*pi*x*10)+1.1)*1000.*rnd-501")
plotpanel(gr,x,y,2)
y.Modify("(cos(2*pi*x*10)+1.1)*1000.*rnd-501")
plotpanel(gr,x,y,3)

gr.WritePNG("test.png","Test Plot")

qw = hfQtPlot()
qw.show()
qw.setgraph(gr)
qw.raise_()
@end verbatim


@c ------------------------------------------------------------------
@node Advanced usage, Data handling, Basic usage, Examples
@section Advanced usage

Now I show several non-obvious features of MathGL: several subplots in a single picture, curvilinear coordinates, text printing and so on. Generally you may miss this section at first reading.

@menu
* Subplots::
* Axis and ticks::
* Curvilinear coordinates::
* Colorbars::
* Ternary axis::
* Text features::
* Legend sample::
* Cutting sample::
@end menu

@c ------------------------------------------------------------------
@node Subplots, Axis and ticks, , Advanced usage
@subsection Subplots

Let me demonstrate possibilities of plot positioning and rotation. MathGL has a set of functions: @code{SubPlot}, @code{InPlot}, @code{Title}, @code{Aspect} and @code{Rotate} and so on (see @ref{Transformation matrix}). The order of their calling is strictly determined. First, one changes the position of plot in image area (functions @code{SubPlot}, @code{InPlot} and @code{MultiPlot}). Secondly, you can add the title of plot by @code{Title} function. After that one may rotate the plot (function @code{Rotate}). Finally, one may change aspects of axes (function @code{Aspect}). The following code illustrates the aforesaid it:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0); gr->Box();
  gr->Puts(mglPoint(-1,1.1),"Just box",":L");
  gr->InPlot(0.2,0.5,0.7,1,false);  gr->Box();
  gr->Puts(mglPoint(0,1.2),"InPlot example");
  gr->SubPlot(2,2,1); gr->Title("Rotate only");
  gr->Rotate(50,60);  gr->Box();
  gr->SubPlot(2,2,2); gr->Title("Rotate and Aspect");
  gr->Rotate(50,60);  gr->Aspect(1,1,2);  gr->Box();
  gr->SubPlot(2,2,3); gr->Title("Aspect in other direction");
  gr->Rotate(50,60);  gr->Aspect(1,2,2);  gr->Box();
  return 0;
}
@end verbatim
Here I used function @code{Puts} for printing the text in arbitrary position of picture (see @ref{Text printing}). Text coordinates and size are connected with axes. However, text coordinates may be everywhere, including the outside the bounding box. I'll show its features later in @ref{Text features}.

@float
@image{../png/aspect, 11cm}
@caption{Example of several subplots on the single picture.}
@end float

More complicated sample show how to use most of positioning functions:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(3,2,0); gr->Title("StickPlot");
  gr->StickPlot(3, 0, 20, 30);  gr->Box("r"); gr->Puts(mglPoint(0),"0","r");
  gr->StickPlot(3, 1, 20, 30);  gr->Box("g"); gr->Puts(mglPoint(0),"1","g");
  gr->StickPlot(3, 2, 20, 30);  gr->Box("b"); gr->Puts(mglPoint(0),"2","b");
  gr->SubPlot(3,2,3,"");  gr->Title("ColumnPlot");
  gr->ColumnPlot(3, 0); gr->Box("r"); gr->Puts(mglPoint(0),"0","r");
  gr->ColumnPlot(3, 1); gr->Box("g"); gr->Puts(mglPoint(0),"1","g");
  gr->ColumnPlot(3, 2); gr->Box("b"); gr->Puts(mglPoint(0),"2","b");
  gr->SubPlot(3,2,4,"");  gr->Title("GridPlot");
  gr->GridPlot(2, 2, 0);  gr->Box("r"); gr->Puts(mglPoint(0),"0","r");
  gr->GridPlot(2, 2, 1);  gr->Box("g"); gr->Puts(mglPoint(0),"1","g");
  gr->GridPlot(2, 2, 2);  gr->Box("b"); gr->Puts(mglPoint(0),"2","b");
  gr->GridPlot(2, 2, 3);  gr->Box("m"); gr->Puts(mglPoint(0),"3","m");
  gr->SubPlot(3,2,5,"");  gr->Title("InPlot");  gr->Box();
  gr->InPlot(0.4, 1, 0.6, 1, true); gr->Box("r");
  gr->MultiPlot(3,2,1, 2, 1,"");  gr->Title("MultiPlot"); gr->Box();
  return 0;
}
@end verbatim

@float
@image{../png/inplot, 11cm}
@caption{Example for most of positioning functions.}
@end float


@c ------------------------------------------------------------------
@node Axis and ticks, Curvilinear coordinates, Subplots, Advanced usage
@subsection Axis and ticks

MathGL library can draw not only the bounding box but also the axes, grids, labels and so on. The ranges of axes and their origin (the point of intersection) are determined by functions @code{SetRange()}, @code{SetRanges()}, @code{SetOrigin()} (see @ref{Ranges (bounding box)}). Ticks on axis are specified by function @code{SetTicks}, @code{SetTicksVal}, @code{SetTicksTime} (see @ref{Ticks}). But usually

Function @code{Axis} draws axes. Its textual string shows in which directions the axis or axes will be drawn (by default @code{"xyz"}, function draws axes in all directions). Function @code{Grid} draws grid perpendicularly to specified directions. Example of axes and grid drawing is:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0); gr->Title("Axis origin, Grid"); gr->SetOrigin(0,0);
  gr->Axis(); gr->Grid(); gr->FPlot("x^3");

  gr->SubPlot(2,2,1); gr->Title("2 axis");
  gr->SetRanges(-1,1,-1,1); gr->SetOrigin(-1,-1,-1);  // first axis
  gr->Axis(); gr->Label('y',"axis 1",0);  gr->FPlot("sin(pi*x)");
  gr->SetRanges(0,1,0,1);   gr->SetOrigin(1,1,1);   // second axis
  gr->Axis(); gr->Label('y',"axis 2",0);  gr->FPlot("cos(pi*x)");

  gr->SubPlot(2,2,3); gr->Title("More axis");
  gr->SetOrigin(NAN,NAN); gr->SetRange('x',-1,1);
  gr->Axis(); gr->Label('x',"x",0); gr->Label('y',"y_1",0); gr->FPlot("x^2","k");
  gr->SetRanges(-1,1,-1,1); gr->SetOrigin(-1.3,-1); // second axis
  gr->Axis("y","r");  gr->Label('y',"#r{y_2}",0.2); gr->FPlot("x^3","r");

  gr->SubPlot(2,2,2); gr->Title("4 segments, inverted axis");   gr->SetOrigin(0,0);
  gr->InPlot(0.5,1,0.5,1);  gr->SetRanges(0,10,0,2);  gr->Axis();
  gr->FPlot("sqrt(x/2)");   gr->Label('x',"W",1); gr->Label('y',"U",1);
  gr->InPlot(0,0.5,0.5,1);  gr->SetRanges(1,0,0,2); gr->Axis("x");
  gr->FPlot("sqrt(x)+x^3"); gr->Label('x',"\\tau",-1);
  gr->InPlot(0.5,1,0,0.5);  gr->SetRanges(0,10,4,0);  gr->Axis("y");
  gr->FPlot("x/4"); gr->Label('y',"L",-1);
  gr->InPlot(0,0.5,0,0.5);  gr->SetRanges(1,0,4,0); gr->FPlot("4*x^2");
  return 0;
}
@end verbatim

Note, that MathGL can draw not only single axis (which is default). But also several axis on the plot (see right plots). The idea is that the change of settings does not influence on the already drawn graphics. So, for 2-axes I setup the first axis and draw everything concerning it. Then I setup the second axis and draw things for the second axis. Generally, the similar idea allows one to draw rather complicated plot of 4 axis with different ranges (see bottom left plot).

@float
@image{../png/axis, 11cm}
@caption{Example of axis.}
@end float

Another MathGL feature is fine ticks tunning. By default (if it is not changed by @code{SetTicks} function), MathGL try to adjust ticks positioning, so that they looks most human readable. At this, MathGL try to extract common factor for too large or too small axis ranges, as well as for too narrow ranges. Last one is non-common notation and can be disabled by @code{SetTuneTicks} function.

Also, one can specify its own ticks with arbitrary labels by help of @code{SetTicksVal} function. Or one can set ticks in time format. In last case MathGL will try to select optimal format for labels with automatic switching between years, months/days, hours/minutes/seconds or microseconds. However, you can specify its own time representation using formats described in @url{http://www.manpagez.com/man/3/strftime/}. Most common variants are @samp{%X} for national representation of time, @samp{%x} for national representation of date, @samp{%Y} for year with century.

The sample code, demonstrated ticks feature is
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(3,2,0); gr->Title("Usual axis");  gr->Axis();
  gr->SubPlot(3,2,1); gr->Title("Too big/small range");
  gr->SetRanges(-1000,1000,0,0.001);  gr->Axis();
  gr->SubPlot(3,2,3); gr->Title("Too narrow range");
  gr->SetRanges(100,100.1,10,10.01);  gr->Axis();
  gr->SubPlot(3,2,4); gr->Title("Disable ticks tuning");
  gr->SetTuneTicks(0);  gr->Axis();

  gr->SubPlot(3,2,2); gr->Title("Manual ticks");  gr->SetRanges(-M_PI,M_PI, 0, 2);
  float val[]={-M_PI, -M_PI/2, 0, 0.886, M_PI/2, M_PI};
  gr->SetTicksVal('x', mglData(6,val), "-\\pi\n-\\pi/2\n0\nx^*\n\\pi/2\n\\pi");
  gr->Axis(); gr->Grid(); gr->FPlot("2*cos(x^2)^2", "r2");

  gr->SubPlot(3,2,5); gr->Title("Time ticks");  gr->SetRange('x',0,3e5);
  gr->SetTicksTime('x',0);  gr->Axis();
  return 0;
}
@end verbatim

@float
@image{../png/ticks, 11cm}
@caption{Features of axis ticks.}
@end float

The last sample I want to show in this subsection is Log-axis. From MathGL's point of vew, the log-axis is particular case of general curvilinear coordinates. So, we need first define new coordinates (see also @ref{Curvilinear coordinates}) by help of @code{SetFunc} or @code{SetCoor} functions. At this one should wary about proper axis range. So the code looks as following:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0,"<_");  gr->Title("Semi-log axis");
  gr->SetRanges(0.01,100,-1,1); gr->SetFunc("lg(x)","");
  gr->Axis(); gr->Grid("xy","g"); gr->FPlot("sin(1/x)");
  gr->Label('x',"x",0); gr->Label('y', "y = sin 1/x",0);

  gr->SubPlot(2,2,1,"<_");  gr->Title("Log-log axis");
  gr->SetRanges(0.01,100,0.1,100);  gr->SetFunc("lg(x)","lg(y)");
  gr->Axis(); gr->FPlot("sqrt(1+x^2)"); gr->Label('x',"x",0);
  gr->Label('y', "y = \\sqrt{1+x^2}",0);

  gr->SubPlot(2,2,2,"<_");  gr->Title("Minus-log axis");
  gr->SetRanges(-100,-0.01,-100,-0.1);  gr->SetFunc("-lg(-x)","-lg(-y)");
  gr->Axis(); gr->FPlot("-sqrt(1+x^2)");
  gr->Label('x',"x",0); gr->Label('y', "y = -\\sqrt{1+x^2}",0);

  gr->SubPlot(2,2,3,"<_");  gr->Title("Log-ticks");
  gr->SetRanges(0.1,100,0,100); gr->SetFunc("sqrt(x)","");
  gr->Axis(); gr->FPlot("x");
  gr->Label('x',"x",1); gr->Label('y', "y = x",0);
  return 0;
}
@end verbatim

@float
@image{../png/loglog, 11cm}
@caption{Features of axis ticks.}
@end float

You can see that MathGL automatically switch to log-ticks as we define log-axis formula (in difference from v.1.*). Moreover, it switch to log-ticks for any formula if axis range will be large enough (see right bottom plot). Another interesting feature is that you not necessary define usual log-axis (i.e. when coordinates are positive), but you can define ``minus-log'' axis when coordinate is negative (see left bottom plot).

@c ------------------------------------------------------------------
@node Curvilinear coordinates, Colorbars, Axis and ticks, Advanced usage
@subsection Curvilinear coordinates

As I noted in previous subsection, MathGL support curvilinear coordinates. In difference from other plotting programs and libraries, MathGL uses textual formulas for connection of the old (data) and new (output) coordinates. This allows one to plot in arbitrary coordinates. The following code plots the line @var{y}=0, @var{z}=0 in Cartesian, polar, parabolic and spiral coordinates:
@verbatim
int sample(mglGraph *gr)
{
  gr->SetOrigin(-1,1,-1);

  gr->SubPlot(2,2,0); gr->Title("Cartesian"); gr->Rotate(50,60);
  gr->FPlot("2*t-1","0.5","0","r2");
  gr->Axis(); gr->Grid();

  gr->SetFunc("y*sin(pi*x)","y*cos(pi*x)",0);
  gr->SubPlot(2,2,1); gr->Title("Cylindrical"); gr->Rotate(50,60);
  gr->FPlot("2*t-1","0.5","0","r2");
  gr->Axis(); gr->Grid();

  gr->SetFunc("2*y*x","y*y - x*x",0);
  gr->SubPlot(2,2,2); gr->Title("Parabolic"); gr->Rotate(50,60);
  gr->FPlot("2*t-1","0.5","0","r2");
  gr->Axis(); gr->Grid();

  gr->SetFunc("y*sin(pi*x)","y*cos(pi*x)","x+z");
  gr->SubPlot(2,2,3); gr->Title("Spiral");  gr->Rotate(50,60);
  gr->FPlot("2*t-1","0.5","0","r2");
  gr->Axis(); gr->Grid();
  gr->SetFunc(0,0,0); // set to default Cartesian
  return 0;
}
@end verbatim

@float
@image{../png/curvcoor, 11cm}
@caption{Example of curvilinear coordinates}
@end float


@c ------------------------------------------------------------------
@node Colorbars, Ternary axis, Curvilinear coordinates, Advanced usage
@subsection Colorbars

MathGL handle colorbar as special kind of axis. So, most of functions for axis and ticks setup will work for colorbar too. Colorbars can be in log-scale, and generally as arbitrary function scale; common factor of colorbar labels can be separated; and so on.

But of course, there are differences -- colorbars usually located out of bounding box. At this, colorbars can be at subplot boundaries (by default), or at bounding box (if symbol @samp{I} is specified). Colorbars can handle sharp colors. And they can be located at arbitrary position too. The sample code, which demonstrate colorbar features is:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0); gr->Title("Colorbar out of box"); gr->Box();
  gr->Colorbar("<");  gr->Colorbar(">");
  gr->Colorbar("_");  gr->Colorbar("^");

  gr->SubPlot(2,2,1); gr->Title("Colorbar near box");   gr->Box();
  gr->Colorbar("<I"); gr->Colorbar(">I");
  gr->Colorbar("_I"); gr->Colorbar("^I");

  gr->SubPlot(2,2,2); gr->Title("manual colors");
  mglData a,v;  mgls_prepare2d(&a,0,&v);
  gr->Box();  gr->ContD(v,a);
  gr->Colorbar(v,"<");  gr->Colorbar(v,">");
  gr->Colorbar(v,"_");  gr->Colorbar(v,"^");

  gr->SubPlot(2,2,3); gr->Title("log-scale");
  gr->SetRange('c',0.01,1e3);
  gr->Colorbar(">",0.5,0);  gr->Puts(mglPoint(0,1.2),"Normal scale");
  gr->SetFunc("","","","lg(c)");
  gr->Colorbar(">");    gr->Puts(mglPoint(1.3,1.2),"Log scale");
  return 0;
}
@end verbatim

@float
@image{../png/colorbar, 11cm}
@caption{Example of colorbars}
@end float


@c ------------------------------------------------------------------
@node Ternary axis, Text features, Colorbars, Advanced usage
@subsection Ternary axis

There are another unusual axis types which are supported by MathGL. These are ternary and quaternary axis. Ternary axis is special axis of 3 coordinates @var{a}, @var{b}, @var{c} which satisfy relation @var{a}+@var{b}+@var{c}=1. Correspondingly, quaternary axis is special axis of 4 coordinates @var{a}, @var{b}, @var{c}, @var{d} which satisfy relation @var{a}+@var{b}+@var{c}+@var{d}=1.

Generally speaking, only 2 of coordinates (3 for quaternary) are independent. So, MathGL just introduce some special transformation formulas which treat @var{a} as @samp{x}, @var{b} as @samp{y} (and @var{c} as @samp{z} for quaternary). As result, all plotting functions (curves, surfaces, contours and so on) work as usual, but in new axis. You should use @code{Ternary} function for switching to ternary/quaternary coordinates. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  gr->SetRanges(0,1,0,1,0,1);
  mglData x(50),y(50),z(50),rx(10),ry(10), a(20,30);
  a.Modify("30*x*y*(1-x-y)^2*(x+y<1)");
  x.Modify("0.25*(1+cos(2*pi*x))");
  y.Modify("0.25*(1+sin(2*pi*x))");
  rx.Modify("rnd"); ry.Modify("(1-v)*rnd",rx);
  z.Modify("x");

  gr->SubPlot(2,2,0); gr->Title("Ordinary axis 3D");
  gr->Rotate(50,60);    gr->Light(true);
  gr->Plot(x,y,z,"r2"); gr->Surf(a,"BbcyrR#");
  gr->Axis(); gr->Grid(); gr->Box();
  gr->Label('x',"B",1); gr->Label('y',"C",1); gr->Label('z',"Z",1);

  gr->SubPlot(2,2,1); gr->Title("Ternary axis (x+y+t=1)");
  gr->Ternary(1);
  gr->Plot(x,y,"r2"); gr->Plot(rx,ry,"q^ ");  gr->Cont(a,"BbcyrR");
  gr->Line(mglPoint(0.5,0), mglPoint(0,0.75), "g2");
  gr->Axis(); gr->Grid("xyz","B;");
  gr->Label('x',"B"); gr->Label('y',"C"); gr->Label('t',"A");

  gr->SubPlot(2,2,2); gr->Title("Quaternary axis 3D");
  gr->Rotate(50,60);    gr->Light(true);
  gr->Ternary(2);
  gr->Plot(x,y,z,"r2"); gr->Surf(a,"BbcyrR#");
  gr->Axis(); gr->Grid(); gr->Box();
  gr->Label('t',"A",1); gr->Label('x',"B",1);
  gr->Label('y',"C",1); gr->Label('z',"D",1);

  gr->SubPlot(2,2,3); gr->Title("Ternary axis 3D");
  gr->Rotate(50,60);    gr->Light(true);
  gr->Ternary(1);
  gr->Plot(x,y,z,"r2"); gr->Surf(a,"BbcyrR#");
  gr->Axis(); gr->Grid(); gr->Box();
  gr->Label('t',"A",1); gr->Label('x',"B",1);
  gr->Label('y',"C",1); gr->Label('z',"Z",1);
  return 0;
}
@end verbatim

@float
@image{../png/ternary, 11cm}
@caption{Example of colorbars}
@end float

@c ------------------------------------------------------------------
@node Text features, Legend sample, Ternary axis, Advanced usage
@subsection Text features

MathGL prints text by vector font. There are functions for manual specifying of text position (like @code{Puts}) and for its automatic selection (like @code{Label}, @code{Legend} and so on). MathGL prints text always in specified position even if it lies outside the bounding box. The default size of font is specified by functions @var{SetFontSize*} (see @ref{Font settings}). However, the actual size of output string depends on subplot size (depends on functions @code{SubPlot}, @code{InPlot}). The switching of the font style (italic, bold, wire and so on) can be done for the whole string (by function parameter) or inside the string. By default MathGL parses TeX-like commands for symbols and indexes (see @ref{Font styles}).

Text can be printed as usual one (from left to right), along some direction (rotated text), or along a curve. Text can be printed on several lines, divided by new line symbol @samp{\n}.

Example of MathGL font drawing is:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0,"");
  gr->Putsw(mglPoint(0,1),L"Text can be in ASCII and in Unicode");
  gr->Puts(mglPoint(0,0.6),"It can be \\wire{wire}, \\big{big} or #r{colored}");
  gr->Puts(mglPoint(0,0.2),"One can change style in string: "
  "\\b{bold}, \\i{italic, \\b{both}}");
  gr->Puts(mglPoint(0,-0.2),"Easy to \\a{overline} or "
  "\\u{underline}");
  gr->Puts(mglPoint(0,-0.6),"Easy to change indexes ^{up} _{down} @{center}");
  gr->Puts(mglPoint(0,-1),"It parse TeX: \\int \\alpha \\cdot "
  "\\sqrt3{sin(\\pi x)^2 + \\gamma_{i_k}} dx");

  gr->SubPlot(2,2,1,"");
  gr->Puts(mglPoint(0,0.5), "\\sqrt{\\frac{\\alpha^{\\gamma^2}+\\overset 1{\\big\\infty}}{\\sqrt3{2+b}}}", "@", -4);
  gr->Puts(mglPoint(0,-0.5),"Text can be printed\non several lines");

  gr->SubPlot(2,2,2,"");
  mglData y;  mgls_prepare1d(&y);
  gr->Box();  gr->Plot(y.SubData(-1,0));
  gr->Text(y,"This is very very long string drawn along a curve",":k");
  gr->Text(y,"Another string drawn above a curve","T:r");

  gr->SubPlot(2,2,3,"");
  gr->Line(mglPoint(-1,-1),mglPoint(1,-1),"rA");
  gr->Puts(mglPoint(0,-1),mglPoint(1,-1),"Horizontal");
  gr->Line(mglPoint(-1,-1),mglPoint(1,1),"rA");
  gr->Puts(mglPoint(0,0),mglPoint(1,1),"At angle","@");
  gr->Line(mglPoint(-1,-1),mglPoint(-1,1),"rA");
  gr->Puts(mglPoint(-1,0),mglPoint(-1,1),"Vertical");
  return 0;
}
@end verbatim

@float
@image{../png/text, 11cm}
@caption{Example of text printing}
@end float

@c ------------------------------------------------------------------
@node Legend sample, Cutting sample, Text features, Advanced usage
@subsection Legend sample

Legend is one of standard ways to show plot annotations. Basically you need to connect the plot style (line style, marker and color) with some text. In MathGL, you can do it by 2 methods: manually using @code{AddLegend} function (see @ref{Legend}); or use @samp{legend} option (see @ref{Command options}), which will use last plot style. In both cases, legend entries will be added into internal accumulator, which later used for legend drawing itself. @code{ClearLegend} function allow you to remove all saved legend entries.

There are 2 features. If plot style is empty then text will be printed without indent. If you want to plot the text with indent but without plot sample then you need to use space @samp{ } as plot style. Such style @samp{ } will draw a plot sample (line with marker(s)) which is invisible line (i.e. nothing) and print the text with indent as usual one.

Function @code{Legend} draw legend on the plot. The position of the legend can be selected automatic or manually. You can change the size and style of text labels, as well as setup the plot sample. The sample code demonstrating legend features is:
@verbatim
int sample(mglGraph *gr)
{
  gr->AddLegend("sin(\\pi {x^2})","b");
  gr->AddLegend("sin(\\pi x)","g*");
  gr->AddLegend("sin(\\pi \\sqrt{x})","rd");
  gr->AddLegend("just text"," ");
  gr->AddLegend("no indent for this","");

  gr->SubPlot(2,2,0,""); gr->Title("Legend (default)");
  gr->Box();  gr->Legend();

  gr->Legend(3,"A#");
  gr->Puts(mglPoint(0.75,0.65),"Absolute position","A");

  gr->SubPlot(2,2,2,"");  gr->Title("coloring");  gr->Box();
  gr->Legend(0,"r#"); gr->Legend(1,"Wb#");  gr->Legend(2,"ygr#");

  gr->SubPlot(2,2,3,"");  gr->Title("manual position");
  gr->Box();  gr->Legend(0.5,0.5);
  return 0;
}
@end verbatim

@float
@image{../png/legend, 11cm}
@caption{Example of legend}
@end float

@c ------------------------------------------------------------------
@node Cutting sample, , Legend sample, Advanced usage
@subsection Cutting sample

The last common thing which I want to show in this section is how one can cut off points from plot. There are 4 mechanism for that.
@itemize @bullet
@item
You can set one of coordinate to NAN value. All points with NAN values will be omitted.

@item
You can enable cutting at edges by @code{SetCut} function. As result all points out of bounding box will be omitted.

@item
You can set cutting box by @code{SetCutBox} function. All points inside this box will be omitted.

@item
You can define cutting formula by @code{SetCutOff} function. All points for which the value of formula is nonzero will be omitted. Note, that this is the slowest variant.
@end itemize

Below I place the code which demonstrate last 3 possibilities:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,c,v(1); mgls_prepare2d(&a); mgls_prepare3d(&c); v.a[0]=0.5;
  gr->SubPlot(2,2,0); gr->Title("Cut on (default)");
  gr->Rotate(50,60);  gr->Light(true);
  gr->Box();  gr->Surf(a,"","zrange -1 0.5");

  gr->SubPlot(2,2,1); gr->Title("Cut off");   gr->Rotate(50,60);
  gr->Box();  gr->Surf(a,"","zrange -1 0.5; cut off");

  gr->SubPlot(2,2,2); gr->Title("Cut in box");  gr->Rotate(50,60);
  gr->SetCutBox(mglPoint(0,-1,-1), mglPoint(1,0,1.1));
  gr->Alpha(true);  gr->Box();  gr->Surf3(c);
  gr->SetCutBox(mglPoint(0), mglPoint(0));  // switch it off

  gr->SubPlot(2,2,3); gr->Title("Cut by formula");  gr->Rotate(50,60);
  gr->CutOff("(z>(x+0.5*y-1)^2-1) & (z>(x-0.5*y-1)^2-1)");
  gr->Box();  gr->Surf3(c); gr->CutOff(""); // switch it off
  return 0;
}
@end verbatim

@float
@image{../png/cut, 11cm}
@caption{Example of point cutting}
@end float



@c ------------------------------------------------------------------
@node Data handling, Data plotting, Advanced usage, Examples
@section Data handling

Class @code{mglData} contains all functions for the data handling in MathGL (@pxref{Data processing}). There are several matters why I use class @code{mglData} but not a single array: it does not depend on type of data (float or double), sizes of data arrays are kept with data, memory working is simpler and safer.

@menu
* Array creation::
* Linking array::
* Change data::
* User defined types::
@end menu

@c ------------------------------------------------------------------
@node Array creation, Change data, , Data handling
@subsection Array creation

There are many ways in MathGL how data arrays can be created and filled.

One can put the data in @code{mglData} instance by several ways. Let us do it for sinus function:
@itemize @bullet
@item
one can create external array, fill it and put to @code{mglData} variable
@verbatim
  double *a = new double[50];
  for(int i=0;i<50;i++)   a[i] = sin(M_PI*i/49.);

  mglData y;
  y.Set(a,50);
@end verbatim

@item
another way is to create @code{mglData} instance of the desired size and then to work directly with data in this variable
@verbatim
  mglData y(50);
  for(int i=0;i<50;i++)   y.a[i] = sin(M_PI*i/49.);
@end verbatim

@item
next way is to fill the data in @code{mglData} instance by textual formula with the help of @code{Modify()} function
@verbatim
  mglData y(50);
  y.Modify("sin(pi*x)");
@end verbatim

@item
or one may fill the array in some interval and modify it later
@verbatim
  mglData y(50);
  y.Fill(0,M_PI);
  y.Modify("sin(u)");
@end verbatim

@item
finally it can be loaded from file
@verbatim
  FILE *fp=fopen("sin.dat","wt");   // create file first
  for(int i=0;i<50;i++)   fprintf(fp,"%g\n",sin(M_PI*i/49.));
  fclose(fp);

  mglData y("sin.dat");             // load it
@end verbatim
At this you can use textual or HDF files, as well as import values from bitmap image (PNG is supported right now).

@item
at this one can read only part of data
@verbatim
  FILE *fp-fopen("sin.dat","wt");   // create large file first
  for(int i=0;i<70;i++)   fprintf(fp,"%g\n",sin(M_PI*i/49.));
  fclose(fp);

  mglData y;
  y.Read("sin.dat",50);             // load it
@end verbatim
@end itemize

Creation of 2d- and 3d-arrays is mostly the same. But one should keep in mind that class @code{mglData} uses flat data representation. For example, matrix 30*40 is presented as flat (1d-) array with length 30*40=1200 (nx=30, ny=40). The element with indexes @{i,j@} is a[i+nx*j]. So for 2d array we have:
@verbatim
  mglData z(30,40);
  for(int i=0;i<30;i++)   for(int j=0;j<40;j++)
    z.a[i+30*j] = sin(M_PI*i/29.)*sin(M_PI*j/39.);
@end verbatim
or by using @code{Modify()} function
@verbatim
  mglData z(30,40);
  z.Modify("sin(pi*x)*cos(pi*y)");
@end verbatim

The only non-obvious thing here is using multidimensional arrays in C/C++, i.e. arrays defined like @code{float dat[40][30];}. Since, formally these elements @code{dat[i]} can address the memory in arbitrary place you should use the proper function to convert such arrays to @code{mglData} object. For C++ this is functions like @code{mglData::Set(float **dat, int N1, int N2);}. For C this is functions like @code{mgl_data_set_float2(HMDT d, const float **dat, int N1, int N2);}. At this, you should keep in mind that @code{nx=N2} and @code{ny=N1} after conversion.

@c ------------------------------------------------------------------
@node Linking array, Change data, Array creation, Data handling
@subsection Linking array

Sometimes the data arrays are so large, that one couldn't' copy its values to another array (i.e. into mglData). In this case, he can define its own class derived from @code{mglDataA} (see @ref{User defined types}) or can use @code{Link} function.

In last case, MathGL just save the link to an external data array, but not copy it. You should provide the existence of this data array for whole time during which MathGL can use it. Another point is that MathGL will automatically create new array if you'll try to modify data values by any of @code{mglData} functions. So, you should use only function with @code{const} modifier if you want still using link to the original data array.

Creating the link is rather simple -- just the same as using @code{Set} function
@verbatim
  double *a = new double[50];
  for(int i=0;i<50;i++)   a[i] = sin(M_PI*i/49.);

  mglData y;
  y.Link(a,50);
@end verbatim

@c ------------------------------------------------------------------
@node Change data, User defined types, Linking array, Data handling
@subsection Change data

MathGL has functions for data processing: differentiating, integrating, smoothing and so on (for more detail, see @ref{Data processing}). Let us consider some examples. The simplest ones are integration and differentiation. The direction in which operation will be performed is specified by textual string, which may contain symbols @samp{x}, @samp{y} or @samp{z}. For example, the call of @code{Diff("x")} will differentiate data along @samp{x} direction; the call of @code{Integral("xy")} perform the double integration of data along @samp{x} and @samp{y} directions; the call of @code{Diff2("xyz")} will apply 3d Laplace operator to data and so on. Example of this operations on 2d array a=x*y is presented in code:
@verbatim
int sample(mglGraph *gr)
{
  gr->SetRanges(0,1,0,1,0,1);
  mglData a(30,40); a.Modify("x*y");
  gr->SubPlot(2,2,0); gr->Rotate(60,40);
  gr->Surf(a);    gr->Box();
  gr->Puts(mglPoint(0.7,1,1.2),"a(x,y)");
  gr->SubPlot(2,2,1); gr->Rotate(60,40);
  a.Diff("x");    gr->Surf(a);  gr->Box();
  gr->Puts(mglPoint(0.7,1,1.2),"da/dx");
  gr->SubPlot(2,2,2); gr->Rotate(60,40);
  a.Integral("xy"); gr->Surf(a);  gr->Box();
  gr->Puts(mglPoint(0.7,1,1.2),"\\int da/dx dxdy");
  gr->SubPlot(2,2,3); gr->Rotate(60,40);
  a.Diff2("y"); gr->Surf(a);  gr->Box();
  gr->Puts(mglPoint(0.7,1,1.2),"\\int {d^2}a/dxdy dx");
  return 0;
}
@end verbatim

@float
@image{../png/dat_diff, 11cm}
@caption{Example of data differentiation and integration}
@end float

Data smoothing (function @code{Smooth()}) is more interesting and important. This function has single argument which define type of smoothing and its direction. Now 3 methods are supported: @samp{3} -- linear averaging by 3 points, @samp{5} -- linear averaging by 5 points, and default one -- quadratic averaging by 5 points.

MathGL also have some amazing functions which is not so important for data processing as useful for data plotting. There are functions for finding envelope (useful for plotting rapidly oscillating data), for data sewing (useful to removing jumps on the phase), for data resizing (interpolation). Let me demonstrate it:
@verbatim
int sample(mglGraph *gr)
{
  gr->SubPlot(2,2,0,"");  gr->Title("Envelop sample");
  mglData d1(1000); gr->Fill(d1,"exp(-8*x^2)*sin(10*pi*x)");
  gr->Axis();     gr->Plot(d1, "b");
  d1.Envelop('x');  gr->Plot(d1, "r");

  gr->SubPlot(2,2,1,"");  gr->Title("Smooth sample");
  mglData y0(30),y1,y2,y3;
  gr->SetRanges(0,1,0,1);
  gr->Fill(y0, "0.4*sin(pi*x) + 0.3*cos(1.5*pi*x) - 0.4*sin(2*pi*x)+0.5*rnd");

  y1=y0;  y1.Smooth("x3");
  y2=y0;  y2.Smooth("x5");
  y3=y0;  y3.Smooth("x");

  gr->Plot(y0,"{m7}:s", "legend 'none'"); //gr->AddLegend("none","k");
  gr->Plot(y1,"r", "legend ''3' style'");
  gr->Plot(y2,"g", "legend ''5' style'");
  gr->Plot(y3,"b", "legend 'default'");
  gr->Legend();   gr->Box();

  gr->SubPlot(2,2,2);   gr->Title("Sew sample");
  mglData d2(100, 100); gr->Fill(d2, "mod((y^2-(1-x)^2)/2,0.1)");
  gr->Rotate(50, 60);   gr->Light(true);  gr->Alpha(true);
  gr->Box();            gr->Surf(d2, "b");
  d2.Sew("xy", 0.1);  gr->Surf(d2, "r");

  gr->SubPlot(2,2,3);   gr->Title("Resize sample (interpolation)");
  mglData x0(10), v0(10), x1, v1;
  gr->Fill(x0,"rnd");     gr->Fill(v0,"rnd");
  x1 = x0.Resize(100);    v1 = v0.Resize(100);
  gr->Plot(x0,v0,"b+ ");  gr->Plot(x1,v1,"r-");
  gr->Label(x0,v0,"%n");
  return 0;
}
@end verbatim

@float
@image{../png/dat_extra, 11cm}
@caption{Example of data smoothing}
@end float

Finally one can create new data arrays on base of the existing one: extract slice, row or column of data (@code{SubData()}), summarize along a direction(s) (@code{Sum()}), find distribution of data elements (@code{Hist()}) and so on.

@c ------------------------------------------------------------------
@node User defined types, , Change data, Data handling
@subsection User defined types

@code{mglData} class have abstract predecessor class @code{mglDataA}. Exactly the pointers to @code{mglDataA} instances are used in all plotting functions and some of data processing functions. This was done for taking possibility to define yours own class, which will handle yours own data (for example, complex numbers, or differently organized data). And this new class will be almost the same as @code{mglData} for plotting purposes.

However, the most of data processing functions will be slower as if you used @code{mglData} instance. This is more or less understandable -- I don't know how data in yours particular class will be organized, and couldn't optimize the these functions generally.

There are few virtual functions which must be provided in derived classes. This functions give:
@itemize @bullet
@item
the sizes of the data (@code{GetNx}, @code{GetNy}, @code{GetNz}),
@item
give data value and numerical derivatives for selected cell (@code{v}, @code{dvx}, @code{dvy}, @code{dvz}),
@item
give maximal and minimal values (@code{Maximal}, @code{Minimal}) -- you can use provided functions (like @code{mgl_data_max} and @code{mgl_data_min}), but yours own realization can be more efficient,
@item
give access to all element as in single array (@code{vthr}) -- you need this only if you want using MathGL's data processing functions.
@end itemize

Let me, for example define class @code{mglComplex} which will handle complex number and draw its amplitude or phase, depending on flag @var{use_abs}:
@verbatim
#include <complex>
#include <mgl/mgl.h>
#define dual std::complex<double>
class mglComplex : public mglDataA
{
public:
  long nx;      ///< number of points in 1st dimensions ('x' dimension)
  long ny;      ///< number of points in 2nd dimensions ('y' dimension)
  long nz;      ///< number of points in 3d dimensions ('z' dimension)
  dual *a;   ///< data array
  bool use_abs; ///< flag to use abs() or arg()

  inline mglComplex(long xx=1,long yy=1,long zz=1)
  { a=0;  use_abs=true; Create(xx,yy,zz); }
  virtual ~mglComplex()  { if(a)  delete []a; }

  /// Get sizes
  inline long GetNx() const { return nx;  }
  inline long GetNy() const { return ny;  }
  inline long GetNz() const { return nz;  }
  /// Create or recreate the array with specified size and fill it by zero
  inline void Create(long mx,long my=1,long mz=1)
  { nx=mx;  ny=my;  nz=mz;  if(a) delete []a;
  a = new dual[nx*ny*nz]; }
  /// Get maximal value of the data
  inline float Maximal() const  { return mgl_data_max(this);  }
  /// Get minimal value of the data
  inline float Minimal() const  { return mgl_data_min(this);  }

protected:
  inline mreal v(long i,long j=0,long k=0) const
  { return use_abs ? abs(a[i+nx*(j+ny*k)]) : arg(a[i+nx*(j+ny*k)]);  }
  inline mreal vthr(long i) const
  { return use_abs ? abs(a[i]) : arg(a[i]);  }
  inline mreal dvx(long i,long j=0,long k=0) const
  { register long i0=i+nx*(j+ny*k);
    std::complex<double> res=i>0? (i<nx-1? (a[i0+1]-a[i0-1])/2.:a[i0]-a[i0-1]) : a[i0+1]-a[i0];
    return use_abs? abs(res) : arg(res);  }
  inline mreal dvy(long i,long j=0,long k=0) const
  { register long i0=i+nx*(j+ny*k);
    std::complex<double> res=j>0? (j<ny-1? (a[i0+nx]-a[i0-nx])/2.:a[i0]-a[i0-nx]) : a[i0+nx]-a[i0];
    return use_abs? abs(res) : arg(res);  }
  inline mreal dvz(long i,long j=0,long k=0) const
  { register long i0=i+nx*(j+ny*k), n=nx*ny;
    std::complex<double> res=k>0? (k<nz-1? (a[i0+n]-a[i0-n])/2.:a[i0]-a[i0-n]) : a[i0+n]-a[i0];
    return use_abs? abs(res) : arg(res);  }
};
int main()
{
  mglComplex dat(20);
  for(long i=0;i<20;i++)
    dat.a[i] = 3*exp(-0.05*(i-10)*(i-10))*dual(cos(M_PI*i*0.3), sin(M_PI*i*0.3));
  mglGraph gr;
  gr.SetRange('y', -M_PI, M_PI);  gr.Box();

  gr.Plot(dat,"r","legend 'abs'");
  dat.use_abs=false;
  gr.Plot(dat,"b","legend 'arg'");
  gr.Legend();
  gr.WritePNG("complex.png");
  return 0;
}
@end verbatim


@c ------------------------------------------------------------------
@node Data plotting, 1D samples, Data handling, Examples
@section Data plotting

Let me now show how to plot the data. Next section will give much more examples for all plotting functions. Here I just show some basics. MathGL generally has 2 types of plotting functions. Simple variant requires a single data array for plotting, other data (coordinates) are considered uniformly distributed in axis range. Second variant requires data arrays for all coordinates. It allows one to plot rather complex multivalent curves and surfaces (in case of parametric dependencies). Usually each function have one textual argument for plot style and another textual argument for options (see @ref{Command options}).

Note, that the call of drawing function adds something to picture but does not clear the previous plots (as it does in Matlab). Another difference from Matlab is that all setup (like transparency, lightning, axis borders and so on) must be specified @strong{before} plotting functions.

Let start for plots for 1D data. Term ``1D data'' means that data depend on single index (parameter) like curve in parametric form @{x(i),y(i),z(i)@}, i=1...n. The textual argument allow you specify styles of line and marks (see @ref{Line styles}). If this parameter is @code{NULL} or empty then solid line with color from palette is used (see @ref{Palette and colors}).

Below I shall show the features of 1D plotting on base of @code{Plot()} function (see @ref{plot}). Let us start from sinus plot:
@verbatim
int sample(mglGraph *gr)
{
  mglData y0(50); 	y0.Modify("sin(pi*(2*x-1))");
  gr->SubPlot(2,2,0);
  gr->Plot(y0);   	gr->Box();
@end verbatim
Style of line is not specified in @code{Plot()} function. So MathGL uses the solid line with first color of palette (this is blue). Next subplot shows array @var{y1} with 2 rows:
@verbatim
  gr->SubPlot(2,2,1);
  mglData y1(50,2);
  y1.Modify("sin(pi*2*x-pi)");
  y1.Modify("cos(pi*2*x-pi)/2",1);
  gr->Plot(y1);   	gr->Box();
@end verbatim
As previously I did not specify the style of lines. As a result, MathGL again uses solid line with next colors in palette (there are green and red). Now let us plot a circle on the same subplot. The circle is parametric curve @math{x=cos(\pi t), y=sin(\pi t)}. I will set the color of the circle (dark yellow, @samp{Y}) and put marks @samp{+} at point position:
@verbatim
  mglData x(50);  	x.Modify("cos(pi*2*x-pi)");
  gr->Plot(x,y0,"Y+");
@end verbatim
Note that solid line is used because I did not specify the type of line. The same picture can be achieved by @code{Plot()} and @code{SubData())} functions. Let us draw ellipse by orange dash line:
@verbatim
  gr->Plot(y1.SubData(-1,0),y1.SubData(-1,1),"q|");
@end verbatim

Drawing in 3D space is mostly the same. Let us draw spiral with default line style. Now its color is 4-th color from palette (this is cyan):
@verbatim
  gr->SubPlot(2,2,2);	gr->Rotate(60,40);
  mglData z(50);  	z.Modify("2*x-1");
  gr->Plot(x,y0,z);	gr->Box();
@end verbatim
Functions @code{Plot()} and @code{SubData())} make 3D curve plot but for single array. Use it to put circle marks on the previous plot:
@verbatim
  mglData y2(10,3);	y2.Modify("cos(pi*(2*x-1+y))");
  y2.Modify("2*x-1",2);
  gr->Plot(y2.SubData(-1,0),y2.SubData(-1,1),y2.SubData(-1,2),"bo ");
@end verbatim
Note that line style is empty @samp{ } here. Usage of other 1D plotting functions looks similar:
@verbatim
  gr->SubPlot(2,2,3);	gr->Rotate(60,40);
  gr->Bars(x,y0,z,"r");	gr->Box();
  return 0;
}
@end verbatim

Surfaces @code{Surf()} and other 2D plots (@pxref{2D plotting}) are drown the same simpler as 1D one. The difference is that the string parameter specifies not the line style but the color scheme of the plot (see @ref{Color scheme}). Here I draw attention on 4 most interesting color schemes. There is gray scheme where color is changed from black to white (string @samp{kw}) or from white to black (string @samp{wk}). Another scheme is useful for accentuation of negative (by blue color) and positive (by red color) regions on plot (string @samp{"BbwrR"}). Last one is the popular ``jet'' scheme (string @samp{"BbcyrR"}).

Now I shall show the example of a surface drawing. At first let us switch lightning on
@verbatim
int sample(mglGraph *gr)
{
  gr->Light(true);	gr->Light(0,mglPoint(0,0,1));
@end verbatim
and draw the surface, considering coordinates x,y to be uniformly distributed in interval @var{Min}*@var{Max}
@verbatim
  mglData a0(50,40);
  a0.Modify("0.6*sin(2*pi*x)*sin(3*pi*y)+0.4*cos(3*pi*(x*y))");
  gr->SubPlot(2,2,0);	gr->Rotate(60,40);
  gr->Surf(a0);		gr->Box();
@end verbatim
Color scheme was not specified. So previous color scheme is used. In this case it is default color scheme (``jet'') for the first plot. Next example is a sphere. The sphere is parametrically specified surface:
@verbatim
  mglData x(50,40),y(50,40),z(50,40);
  x.Modify("0.8*sin(2*pi*x)*sin(pi*y)");
  y.Modify("0.8*cos(2*pi*x)*sin(pi*y)");
  z.Modify("0.8*cos(pi*y)");
  gr->SubPlot(2,2,1);	gr->Rotate(60,40);
  gr->Surf(x,y,z,"BbwrR");gr->Box();
@end verbatim
I set color scheme to @code{"BbwrR"} that corresponds to red top and blue bottom of the sphere.

Surfaces will be plotted for each of slice of the data if @var{nz}>1. Next example draws surfaces for data arrays with @var{nz}=3:
@verbatim
  mglData a1(50,40,3);
  a1.Modify("0.6*sin(2*pi*x)*sin(3*pi*y)+0.4*cos(3*pi*(x*y))");
  a1.Modify("0.6*cos(2*pi*x)*cos(3*pi*y)+0.4*sin(3*pi*(x*y))",1);
  a1.Modify("0.6*cos(2*pi*x)*cos(3*pi*y)+0.4*cos(3*pi*(x*y))",2);
  gr->SubPlot(2,2,2);	gr->Rotate(60,40);
  gr->Alpha(true);
  gr->Surf(a1);		gr->Box();
@end verbatim
Note, that it may entail a confusion. However, if one will use density plot then the picture will look better:
@verbatim
  gr->SubPlot(2,2,3);	gr->Rotate(60,40);
  gr->Dens(a1);		gr->Box();
  return 0;
}
@end verbatim

Drawing of other 2D plots is analogous. The only peculiarity is the usage of flag @samp{#}. By default this flag switches on the drawing of a grid on plot (@code{Grid()} or @code{Mesh()} for plots in plain or in volume). However, for isosurfaces (including surfaces of rotation @code{Axial()}) this flag switches the  face drawing off. Figure becomes wired. The following code gives example of flag @samp{#} using (compare with normal function drawing as in its description):
@verbatim
int sample(mglGraph *gr)
{
  gr->Alpha(true);	gr->Light(true);	gr->Light(0,mglPoint(0,0,1));
  mglData a(30,20);
  a.Modify("0.6*sin(2*pi*x)*sin(3*pi*y) + 0.4*cos(3*pi*(x*y))");

  gr->SubPlot(2,2,0);	gr->Rotate(40,60);
  gr->Surf(a,"BbcyrR#");		gr->Box();
  gr->SubPlot(2,2,1);	gr->Rotate(40,60);
  gr->Dens(a,"BbcyrR#");		gr->Box();
  gr->SubPlot(2,2,2);	gr->Rotate(40,60);
  gr->Cont(a,"BbcyrR#");		gr->Box();
  gr->SubPlot(2,2,3);	gr->Rotate(40,60);
  gr->Axial(a,"BbcyrR#");		gr->Box();
  return 0;
}
@end verbatim

@c ------------------------------------------------------------------
@node 1D samples, 2D samples, Data plotting, Examples
@section 1D samples

This section is devoted to visualization of 1D data arrays. 1D means the data which depend on single index (parameter) like curve in parametric form @{x(i),y(i),z(i)@}, i=1...n. Most of samples will use the same data for plotting. So, I put its initialization in separate function
@verbatim
void mgls_prepare1d(mglData *y, mglData *y1=0, mglData *y2=0, mglData *x1=0, mglData *x2=0)
{
  register long i,n=50;
  if(y) y->Create(n,3);
  if(x1)  x1->Create(n);    if(x2)  x2->Create(n);
  if(y1)  y1->Create(n);    if(y2)  y2->Create(n);
  float xx;
  for(i=0;i<n;i++)
  {
    xx = i/(n-1.);
    if(y)
    {
      y->a[i] = 0.7*sin(2*M_PI*xx) + 0.5*cos(3*M_PI*xx) + 0.2*sin(M_PI*xx);
      y->a[i+n] = sin(2*M_PI*xx);
      y->a[i+2*n] = cos(2*M_PI*xx);
    }
    if(y1)  y1->a[i] = 0.5+0.3*cos(2*M_PI*xx);
    if(y2)  y2->a[i] = 0.3*sin(2*M_PI*xx);
    if(x1)  x1->a[i] = xx*2-1;
    if(x2)  x2->a[i] = 0.05+0.03*cos(2*M_PI*xx);
  }
}
@end verbatim
or using C functions
@verbatim
void mgls_prepare1d(HMDT y, HMDT y1=0, HMDT y2=0, HMDT x1=0, HMDT x2=0)
{
  register long i,n=50;
  if(y)   mgl_data_create(y,n,3,1);
  if(x1)  mgl_data_create(x1,n,1,1);
  if(x2)  mgl_data_create(x2,n,1,1);
  if(y1)  mgl_data_create(y1,n,1,1);
  if(y2)  mgl_data_create(y2,n,1,1);
  float xx;
  for(i=0;i<n;i++)
  {
    xx = i/(n-1.);
    if(y)
    {
      mgl_data_set_value(y, 0.7*sin(2*M_PI*xx) + 0.5*cos(3*M_PI*xx) + 0.2*sin(M_PI*xx), i,0,0);
      mgl_data_set_value(y, sin(2*M_PI*xx), i,1,0);
      mgl_data_set_value(y, cos(2*M_PI*xx), i,2,0);
    }
    if(y1)  mgl_data_set_value(y1, 0.5+0.3*cos(2*M_PI*xx), i,0,0);
    if(y2)  mgl_data_set_value(y2, 0.3*sin(2*M_PI*xx), i,0,0);
    if(x1)  mgl_data_set_value(x1, xx*2-1, i,0,0);
    if(x2)  mgl_data_set_value(x2, 0.05+0.03*cos(2*M_PI*xx), i,0,0);
  }
}
@end verbatim

@menu
* Plot sample::
* Radar sample::
* Step sample::
* Tens sample::
* Area sample::
* Region sample::
* Stem sample::
* Bars sample::
* Barh sample::
* Chart sample::
* BoxPlot sample::
* Candle sample::
* Error sample::
* Mark sample::
* TextMark sample::
* Label sample::
* Tube sample::
* Tape sample::
* Torus sample::
@end menu


@c ------------------------------------------------------------------
@node Plot sample, Radar sample, , 1D samples
@subsection Plot sample

@code{Plot} is most standard way to visualize 1D data array. By default, @code{Plot} use colors from palette. However, you can specify manual color/palette, and even set to use new color for each points by using @samp{!} style. Another feature is @samp{ } style which draw only markers without line between points. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y); gr->SetOrigin(0,0,0);
  gr->SubPlot(2,2,0,"");  gr->Title("Plot plot (default)");
  gr->Box();  gr->Plot(y);

  gr->SubPlot(2,2,2,"");  gr->Title("'!' style; 'rgb' palette");
  gr->Box();  gr->Plot(y,"o!rgb");

  gr->SubPlot(2,2,3,"");  gr->Title("just markers");
  gr->Box();  gr->Plot(y," +");

  gr->SubPlot(2,2,1); gr->Title("3d variant");
  gr->Rotate(50,60);  gr->Box();
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");
  gr->Plot(xc,yc,z,"rs");
  return 0;
}
@end verbatim

@float
@image{../png/plot, 11cm}
@caption{Example of Plot()}
@end float


@c ------------------------------------------------------------------
@node Radar sample, Step sample, Plot sample, 1D samples
@subsection Radar sample

@code{Radar} plot is variant of @code{Plot} one, which make plot in polar coordinates and draw radial rays in point directions. If you just need a plot in polar coordinates then I recommend to use @ref{Curvilinear coordinates} or @code{Plot} in parabolic form with @code{x=r*cos(fi); y=r*sin(fi);}. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData yr(10,3); yr.Modify("0.4*sin(pi*(2*x+y))+0.1*rnd");
  gr->SubPlot(1,1,0,"");  gr->Title("Radar plot (with grid, '\\#')");
  gr->Radar(yr,"#");
  return 0;
}
@end verbatim

@float
@image{../png/radar, 11cm}
@caption{Example of Radar()}
@end float

@c ------------------------------------------------------------------
@node Step sample, Tens sample, Radar sample, 1D samples
@subsection Step sample

@code{Step} plot data as stairs. It have the same options as @code{Plot}. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y); gr->SetOrigin(0,0,0);
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");

  gr->SubPlot(2,2,0,"");  gr->Title("Step plot (default)");
  gr->Box();  gr->Step(y);

  gr->SubPlot(2,2,1); gr->Title("3d variant");  gr->Rotate(50,60);
  gr->Box();  gr->Step(xc,yc,z,"r");

  gr->SubPlot(2,2,2,"");  gr->Title("'!' style");
  gr->Box();  gr->Step(y,"s!rgb");
  return 0;
}
@end verbatim

@float
@image{../png/step, 11cm}
@caption{Example of Step()}
@end float

@c ------------------------------------------------------------------
@node Tens sample, Area sample, Step sample, 1D samples
@subsection Tens sample

@code{Tens} is variant of @code{Plot} with smooth coloring along the curves. At this, color is determined as for surfaces (see @ref{Color scheme}). The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y); gr->SetOrigin(0,0,0);
  gr->SubPlot(2,2,0,"");  gr->Title("Tens plot (default)");
  gr->Box();  gr->Tens(y.SubData(-1,0), y.SubData(-1,1));

  gr->SubPlot(2,2,2,"");  gr->Title("' ' style");
  gr->Box();  gr->Tens(y.SubData(-1,0), y.SubData(-1,1),"o ");

  gr->SubPlot(2,2,1); gr->Title("3d variant");  gr->Rotate(50,60);  gr->Box();
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");
  gr->Tens(xc,yc,z,z,"s");
  return 0;
}
@end verbatim

@float
@image{../png/tens, 11cm}
@caption{Example of Tens()}
@end float

@c ------------------------------------------------------------------
@node Area sample, Region sample, Tens sample, 1D samples
@subsection Area sample

@code{Area} fill the area between curve and axis plane. It support gradient filling if 2 colors per curve is specified. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y); gr->SetOrigin(0,0,0);
  gr->SubPlot(2,2,0,"");  gr->Title("Area plot (default)");
  gr->Box();  gr->Area(y);

  gr->SubPlot(2,2,1,"");  gr->Title("2 colors");
  gr->Box();  gr->Area(y,"cbgGyr");

  gr->SubPlot(2,2,2,"");  gr->Title("'!' style");
  gr->Box();  gr->Area(y,"!");

  gr->SubPlot(2,2,3); gr->Title("3d variant");
  gr->Rotate(50,60);  gr->Box();
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");
  gr->Area(xc,yc,z,"r");
  return 0;
}
@end verbatim

@float
@image{../png/area, 11cm}
@caption{Example of Area()}
@end float

@c ------------------------------------------------------------------
@node Region sample, Stem sample, Area sample, 1D samples
@subsection Region sample

@code{Region} fill the area between 2 curves. It support gradient filling if 2 colors per curve is specified. Also it can fill only the region y1<y<y2 if style @samp{i} is used. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y);
  mglData y1 = y.SubData(-1,1), y2 = y.SubData(-1,2); gr->SetOrigin(0,0,0);
  gr->SubPlot(2,2,0,"");  gr->Title("Region plot (default)");
  gr->Box();  gr->Region(y1,y2);  gr->Plot(y1,"k2");  gr->Plot(y2,"k2");

  gr->SubPlot(2,2,1,"");  gr->Title("2 colors");
  gr->Box();  gr->Region(y1,y2,"yr"); gr->Plot(y1,"k2");  gr->Plot(y2,"k2");

  gr->SubPlot(2,2,2,"");  gr->Title("'!' style");
  gr->Box();  gr->Region(y1,y2,"!");  gr->Plot(y1,"k2");  gr->Plot(y2,"k2");

  gr->SubPlot(2,2,3,"");  gr->Title("'i' style");
  gr->Box();  gr->Region(y1,y2,"ir"); gr->Plot(y1,"k2");  gr->Plot(y2,"k2");
  return 0;
}
@end verbatim

@float
@image{../png/region, 11cm}
@caption{Example of Region()}
@end float

@c ------------------------------------------------------------------
@node Stem sample, Bars sample, Region sample, 1D samples
@subsection Stem sample

@code{Stem} draw vertical bars. It is most attractive if markers are drawn too. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y); gr->SetOrigin(0,0,0);
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");
  gr->SubPlot(2,2,0,"");  gr->Title("Stem plot (default)");
  gr->Box();  gr->Stem(y);

  gr->SubPlot(2,2,1); gr->Title("3d variant");  gr->Rotate(50,60);
  gr->Box();  gr->Stem(xc,yc,z,"rx");

  gr->SubPlot(2,2,2,"");  gr->Title("'!' style");
  gr->Box();  gr->Stem(y,"o!rgb");
  return 0;
}
@end verbatim

@float
@image{../png/stem, 11cm}
@caption{Example of Stem()}
@end float

@c ------------------------------------------------------------------
@node Bars sample, Barh sample, Stem sample, 1D samples
@subsection Bars sample

@code{Bars} draw vertical bars. It have a lot of options: bar-above-bar (@samp{a} style), fall like (@samp{f} style), 2 colors for positive and negative values, wired bars (@samp{#} style), 3D variant. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData ys(10,3); ys.Modify("0.8*sin(pi*(2*x+y/2))+0.2*rnd");
  gr->SetOrigin(0,0,0);
  gr->SubPlot(3,2,0,"");  gr->Title("Bars plot (default)");
  gr->Box();  gr->Bars(ys);

  gr->SubPlot(3,2,1,"");  gr->Title("2 colors");
  gr->Box();  gr->Bars(ys,"cbgGyr");

  gr->SubPlot(3,2,4,"");  gr->Title("'\\#' style");
  gr->Box();  gr->Bars(ys,"#");

  gr->SubPlot(3,2,5); gr->Title("3d variant");
  gr->Rotate(50,60);  gr->Box();
  mglData yc(30), xc(30), z(30);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");
  gr->Bars(xc,yc,z,"r");

  gr->SetRanges(-1,1,-3,3);
  gr->SubPlot(3,2,2,"");  gr->Title("'a' style");
  gr->Box();  gr->Bars(ys,"a");

  gr->SubPlot(3,2,3,"");  gr->Title("'f' style");
  gr->Box();  gr->Bars(ys,"f");
  return 0;
}
@end verbatim

@float
@image{../png/bars, 11cm}
@caption{Example of Bars()}
@end float

@c ------------------------------------------------------------------
@node Barh sample, Chart sample, Bars sample, 1D samples
@subsection Barh sample

@code{Barh} is the similar to @code{Bars} but draw horizontal bars. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData ys(10,3); ys.Modify("0.8*sin(pi*(2*x+y/2))+0.2*rnd");
  gr->SetOrigin(0,0,0);
  gr->SubPlot(2,2,0,"");  gr->Title("Barh plot (default)");
  gr->Box();  gr->Barh(ys);

  gr->SubPlot(2,2,1,"");  gr->Title("2 colors");
  gr->Box();  gr->Barh(ys,"cbgGyr");

  gr->SetRanges(-3,3,-1,1);
  gr->SubPlot(2,2,2,"");  gr->Title("'a' style");
  gr->Box();  gr->Barh(ys,"a");

  gr->SubPlot(2,2,3,"");  gr->Title("'f' style");
  gr->Box();  gr->Barh(ys,"f");
  return 0;
}
@end verbatim

@float
@image{../png/barh, 11cm}
@caption{Example of Barh()}
@end float

@c ------------------------------------------------------------------
@node Chart sample, BoxPlot sample, Barh sample, 1D samples
@subsection Chart sample

@code{Chart} draw colored boxes with width proportional to data values. Use @samp{ } for empty box. Plot looks most attractive in polar coordinates -- well known pie chart. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData ch(7,2);  for(int i=0;i<7*2;i++)  ch.a[i]=mgl_rnd()+0.1;
  gr->SubPlot(2,2,0); gr->Title("Chart plot (default)");
  gr->Light(true);  gr->Rotate(50,60);  gr->Box();  gr->Chart(ch);

  gr->SubPlot(2,2,1); gr->Title("'\\#' style");
  gr->Rotate(50,60);  gr->Box();  gr->Chart(ch,"#");

  gr->SubPlot(2,2,2); gr->Title("Pie chart; ' ' color");
  gr->SetFunc("(y+1)/2*cos(pi*x)","(y+1)/2*sin(pi*x)","");
  gr->Rotate(50,60);  gr->Box();  gr->Chart(ch,"bgr cmy#");

  gr->SubPlot(2,2,3); gr->Title("Ring chart; ' ' color");
  gr->SetFunc("(y+2)/3*cos(pi*x)","(y+2)/3*sin(pi*x)","");
  gr->Rotate(50,60);  gr->Box();  gr->Chart(ch,"bgr cmy#");
  return 0;
}
@end verbatim

@float
@image{../png/chart, 11cm}
@caption{Example of Chart()}
@end float

@c ------------------------------------------------------------------
@node BoxPlot sample, Candle sample, Chart sample, 1D samples
@subsection BoxPlot sample

@code{BoxPlot} draw box-and-whisker diagram. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a(10,7);  a.Modify("(2*rnd-1)^3/2");
  gr->SubPlot(1,1,0,"");  gr->Title("Boxplot plot");
  gr->Box();  gr->BoxPlot(a);
  return 0;
}
@end verbatim

@float
@image{../png/boxplot, 11cm}
@caption{Example of BoxPlot()}
@end float

@c ------------------------------------------------------------------
@node Candle sample, Error sample, BoxPlot sample, 1D samples
@subsection Candle sample

@code{Candle} draw candlestick chart. This is a combination of a line-chart and a bar-chart, in that each bar represents the range of price movement over a given time interval. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y(30);  gr->Fill(y,"sin(2*pi*x)^2");
  mglData y1(30); gr->Fill(y1,"v/2",y);
  mglData y2(30); gr->Fill(y2,"(1+v)/2",y);
  gr->SubPlot(1,1,0,"");  gr->Title("Candle plot (default)");
  gr->SetRange('y',0,1);  gr->Box();  gr->Candle(y,y1,y2);
  return 0;
}
@end verbatim

@float
@image{../png/candle, 11cm}
@caption{Example of Candle()}
@end float

@c ------------------------------------------------------------------
@node Error sample, Mark sample, Candle sample, 1D samples
@subsection Error sample

@code{Error} draw error boxes around the points. You can draw default boxes or semi-transparent symbol (like marker, see @ref{Line styles}). Also you can set individual color for each box. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y);
  mglData x0(10), y0(10), ex0(10), ey0(10);
  float x;
  for(int i=0;i<10;i++)
  {
    x = i/9.;
    x0.a[i] = 2*x-1 + 0.1*mgl_rnd()-0.05;
    y0.a[i] = 0.7*sin(2*M_PI*x)+0.5*cos(3*M_PI*x)+0.2*sin(M_PI*x)+0.2*mgl_rnd()-0.1;
    ey0.a[i]=0.2; ex0.a[i]=0.1;
  }

  gr->SubPlot(2,2,0,"");  gr->Title("Error plot (default)");
  gr->Box();  gr->Plot(y.SubData(-1,0));  gr->Error(x0,y0,ex0,ey0,"ko");

  gr->SubPlot(2,2,1,"");  gr->Title("'!' style; no e_x");
  gr->Box();  gr->Plot(y.SubData(-1,0));  gr->Error(x0,y0,ey0,"o!rgb");

  gr->SubPlot(2,2,2,"");  gr->Title("'\\@' style");
  gr->Box();  gr->Plot(y.SubData(-1,0));  gr->Error(x0,y0,ex0,ey0,"@","alpha 0.5");

  gr->SubPlot(2,2,3); gr->Title("3d variant");  gr->Rotate(50,60);
  for(int i=0;i<10;i++)
    gr->Error(mglPoint(2*mgl_rnd()-1,2*mgl_rnd()-1,2*mgl_rnd()-1),
              mglPoint(0.2,0.2,0.2),"bo");
  gr->Axis();
  return 0;
}
@end verbatim

@float
@image{../png/error, 11cm}
@caption{Example of Error()}
@end float

@c ------------------------------------------------------------------
@node Mark sample, TextMark sample, Error sample, 1D samples
@subsection Mark sample

@code{Mark} draw markers at points. It is mostly the same as @code{Plot} but marker size can be variable. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y,y1; mgls_prepare1d(&y,&y1);
  gr->SubPlot(1,1,0,"");  gr->Title("Mark plot (default)");
  gr->Box();  gr->Mark(y,y1,"s");
  return 0;
}
@end verbatim

@float
@image{../png/mark, 11cm}
@caption{Example of Mark()}
@end float

@c ------------------------------------------------------------------
@node TextMark sample, Label sample, Mark sample, 1D samples
@subsection TextMark sample

@code{TextMark} like @code{Mark} but draw text instead of markers. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y,y1; mgls_prepare1d(&y,&y1);
  gr->SubPlot(1,1,0,"");  gr->Title("TextMark plot (default)");
  gr->Box();  gr->TextMark(y,y1,"\\gamma","r");
  return 0;
}
@end verbatim

@float
@image{../png/textmark, 11cm}
@caption{Example of TextMark()}
@end float

@c ------------------------------------------------------------------
@node Label sample, Tube sample, TextMark sample, 1D samples
@subsection Label sample

@code{Label} print text at data points. The string may contain @samp{%x}, @samp{%y}, @samp{%z} for x-, y-, z-coordinates of points, @samp{%n} for point index. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData ys(10); ys.Modify("0.8*sin(pi*2*x)+0.2*rnd");
  gr->SubPlot(1,1,0,"");  gr->Title("Label plot");
  gr->Box();  gr->Plot(ys," *");  gr->Label(ys,"y=%y");
  return 0;
}
@end verbatim

@float
@image{../png/label, 11cm}
@caption{Example of Label()}
@end float


@c ------------------------------------------------------------------
@node Tube sample, Tape sample, Label sample, 1D samples
@subsection Tube sample

@code{Tube} draw tube with variable radius. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y,y1,y2;  mgls_prepare1d(&y,&y1,&y2); y1/=20;
  gr->SubPlot(2,2,0,"");  gr->Title("Tube plot (default)");
  gr->Light(true);  gr->Box();  gr->Tube(y,0.05);

  gr->SubPlot(2,2,1,"");  gr->Title("variable radius");
  gr->Box();  gr->Tube(y,y1);

  gr->SubPlot(2,2,2,"");  gr->Title("'\\#' style");
  gr->Box();  gr->Tube(y,0.05,"#");
  mglData yc(50), xc(50), z(50);  z.Modify("2*x-1");
  yc.Modify("sin(pi*(2*x-1))"); xc.Modify("cos(pi*2*x-pi)");

  gr->SubPlot(2,2,3); gr->Title("3d variant");  gr->Rotate(50,60);
  gr->Box();  gr->Tube(xc,yc,z,y2,"r");
  return 0;
}
@end verbatim

@float
@image{../png/tube, 11cm}
@caption{Example of Tube()}
@end float


@c ------------------------------------------------------------------
@node Tape sample, Torus sample, Tube sample, 1D samples
@subsection Tape sample

@code{Tape} draw tapes which rotate around the curve as normal and binormal. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y;  mgls_prepare1d(&y);
  mglData xc(50), yc(50), z(50);
  yc.Modify("sin(pi*(2*x-1))");
  xc.Modify("cos(pi*2*x-pi)");  z.Fill(-1,1);
  gr->SubPlot(2,2,0,"");  gr->Title("Tape plot (default)");
  gr->Box();  gr->Tape(y);  gr->Plot(y,"k");

  gr->SubPlot(2,2,1); gr->Title("3d variant, 2 colors");
  gr->Rotate(50,60);  gr->Light(true);
  gr->Box();  gr->Plot(xc,yc,z,"k");  gr->Tape(xc,yc,z,"rg");

  gr->SubPlot(2,2,2); gr->Title("3d variant, x only");  gr->Rotate(50,60);
  gr->Box();  gr->Plot(xc,yc,z,"k");
  gr->Tape(xc,yc,z,"xr"); gr->Tape(xc,yc,z,"xr#");

  gr->SubPlot(2,2,3); gr->Title("3d variant, z only");  gr->Rotate(50,60);
  gr->Box();  gr->Plot(xc,yc,z,"k");
  gr->Tape(xc,yc,z,"zg"); gr->Tape(xc,yc,z,"zg#");
  return 0;
}
@end verbatim

@float
@image{../png/tape, 11cm}
@caption{Example of Tape()}
@end float


@c ------------------------------------------------------------------
@node Torus sample, , Tape sample, 1D samples
@subsection Torus sample

@code{Torus} draw surface of the curve rotation. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData y1,y2;  mgls_prepare1d(0,&y1,&y2);
  gr->SubPlot(2,2,0); gr->Title("Torus plot (default)");
  gr->Light(true);  gr->Rotate(50,60);  gr->Box();  gr->Torus(y1,y2);
  if(mini)  return;

  gr->SubPlot(2,2,1); gr->Title("'x' style"); gr->Rotate(50,60);
  gr->Box();  gr->Torus(y1,y2,"x");

  gr->SubPlot(2,2,2); gr->Title("'z' style"); gr->Rotate(50,60);
  gr->Box();  gr->Torus(y1,y2,"z");

  gr->SubPlot(2,2,3); gr->Title("'\\#' style"); gr->Rotate(50,60);
  gr->Box();  gr->Torus(y1,y2,"#");
  return 0;
}
@end verbatim

@float
@image{../png/torus, 11cm}
@caption{Example of Torus()}
@end float


@c ------------------------------------------------------------------
@node 2D samples, 3D samples, 1D samples, Examples
@section 2D samples

This section is devoted to visualization of 2D data arrays. 2D means the data which depend on 2 indexes (parameters) like matrix z(i,j)=z(x(i),y(j)), i=1...n, j=1...m or in parametric form @{x(i,j),y(i,j),z(i,j)@}. Most of samples will use the same data for plotting. So, I put its initialization in separate function
@verbatim
void mgls_prepare2d(mglData *a, mglData *b=0, mglData *v=0)
{
  register long i,j,n=50,m=40,i0;
  if(a) a->Create(n,m);   if(b) b->Create(n,m);
  if(v) { v->Create(9); v->Fill(-1,1);  }
  float x,y;
  for(i=0;i<n;i++)  for(j=0;j<m;j++)
  {
    x = i/(n-1.); y = j/(m-1.); i0 = i+n*j;
    if(a) a->a[i0] = 0.6*sin(2*M_PI*x)*sin(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
    if(b) b->a[i0] = 0.6*cos(2*M_PI*x)*cos(3*M_PI*y)+0.4*cos(3*M_PI*x*y);
  }
}
@end verbatim
or using C functions
@verbatim
void mgls_prepare2d(HMDT a, HMDT b=0, HMDT v=0)
{
  register long i,j,n=50,m=40,i0;
  if(a) mgl_data_create(a,n,m,1);
  if(b) mgl_data_create(b,n,m,1);
  if(v) { mgl_data_create(v,9,1,1); mgl_data_fill(v,-1,1,'x');  }
  float x,y;
  for(i=0;i<n;i++)  for(j=0;j<m;j++)
  {
    x = i/(n-1.); y = j/(m-1.); i0 = i+n*j;
    if(a) mgl_data_set_value(a, 0.6*sin(2*M_PI*x)*sin(3*M_PI*y)+0.4*cos(3*M_PI*x*y), i,j,0);
    if(b) mgl_data_set_value(b, 0.6*cos(2*M_PI*x)*cos(3*M_PI*y)+0.4*cos(3*M_PI*x*y), i,j,0);
  }
}
@end verbatim

@menu
* Surf sample::
* SurfC sample::
* SurfA sample::
* Mesh sample::
* Fall sample::
* Belt sample::
* Boxs sample::
* Tile sample::
* TileS sample::
* Dens sample::
* Cont sample::
* ContF sample::
* ContD sample::
* ContV sample::
* Axial sample::
@end menu

@c ------------------------------------------------------------------
@node Surf sample, SurfC sample, , 2D samples
@subsection Surf sample

@code{Surf} is most standard way to visualize 2D data array. @code{Surf} use color scheme for coloring (see @ref{Color scheme}). You can use @samp{#} style for drawing black meshes on the surface. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->SubPlot(2,2,0); gr->Title("Surf plot (default)");
  gr->Light(true);  gr->Rotate(50,60);  gr->Box();  gr->Surf(a);

  gr->SubPlot(2,2,1); gr->Title("'\\#' style; meshnum 10");
  gr->Rotate(50,60);  gr->Box();  gr->Surf(a,"#","meshnum 10");

  gr->SubPlot(2,2,2); gr->Title("'|' style");
  gr->Rotate(50,60);  gr->Box();  gr->Surf(a,"|");

  gr->SubPlot(2,2,3); gr->Title("parametric form");
  mglData x(50,40),y(50,40),z(50,40);
  gr->Fill(x,"0.8*sin(pi*x)*sin(pi*(y+1)/2)");
  gr->Fill(y,"0.8*cos(pi*x)*sin(pi*(y+1)/2)");
  gr->Fill(z,"0.8*cos(pi*(y+1)/2)");
  gr->Rotate(50,60);  gr->Box();  gr->Surf(x,y,z,"BbwrR");
  return 0;
}
@end verbatim

@float
@image{../png/surf, 11cm}
@caption{Example of Surf()}
@end float

@c ------------------------------------------------------------------
@node SurfC sample, SurfA sample, Surf sample, 2D samples
@subsection SurfC sample

@code{SurfC} is similar to @code{Surf} but its coloring is determined by another data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,b;  mgls_prepare2d(&a,&b);
  gr->Title("SurfC plot");  gr->Rotate(50,60);
  gr->Light(true);  gr->Box();  gr->SurfC(a,b);
  return 0;
}
@end verbatim

@float
@image{../png/surfc, 11cm}
@caption{Example of SurfC()}
@end float

@c ------------------------------------------------------------------
@node SurfA sample, Mesh sample, SurfC sample, 2D samples
@subsection SurfA sample

@code{SurfA} is similar to @code{Surf} but its transparency is determined by another data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,b;  mgls_prepare2d(&a,&b);
  gr->Title("SurfA plot");  gr->Rotate(50,60);
  gr->Alpha(true);  gr->Light(true);
  gr->Box();  gr->SurfA(a,b);
  return 0;
}
@end verbatim

@float
@image{../png/surfa, 11cm}
@caption{Example of SurfA()}
@end float


@c ------------------------------------------------------------------
@node Mesh sample, Fall sample, SurfA sample, 2D samples
@subsection Mesh sample

@code{Mesh} draw wired surface. You can use @code{SetMeshNum} for changing number of lines to be drawn. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->Title("Mesh plot"); gr->Rotate(50,60);
  gr->Box();  gr->Mesh(a);
  return 0;
}
@end verbatim

@float
@image{../png/mesh, 11cm}
@caption{Example of Mesh()}
@end float

@c ------------------------------------------------------------------
@node Fall sample, Belt sample, Mesh sample, 2D samples
@subsection Fall sample

@code{Fall} draw waterfall surface. You can use @code{SetMeshNum} for changing number of lines to be drawn. Also you can use @samp{x} style for drawing lines in other direction. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->Title("Fall plot"); gr->Rotate(50,60);
  gr->Box();  gr->Fall(a);
  return 0;
}
@end verbatim

@float
@image{../png/fall, 11cm}
@caption{Example of Fall()}
@end float

@c ------------------------------------------------------------------
@node Belt sample, Boxs sample, Fall sample, 2D samples
@subsection Belt sample

@code{Belt} draw surface by belts. You can use @samp{x} style for drawing lines in other direction. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->Title("Belt plot"); gr->Rotate(50,60);
  gr->Box();  gr->Belt(a);
  return 0;
}
@end verbatim

@float
@image{../png/belt, 11cm}
@caption{Example of Belt()}
@end float

@c ------------------------------------------------------------------
@node Boxs sample, Tile sample, Fall sample, 2D samples
@subsection Boxs sample

@code{Boxs} draw surface by boxes. You can use @samp{#} for drawing wire plot. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->SetOrigin(0,0,0); gr->Light(true);
  gr->SubPlot(2,2,0);  gr->Title("Boxs plot (default)");
  gr->Rotate(40,60);  gr->Box();  gr->Boxs(a);

  gr->SubPlot(2,2,1); gr->Title("'\\@' style");
  gr->Rotate(50,60);  gr->Box();  gr->Boxs(a,"@");

  gr->SubPlot(2,2,2); gr->Title("'\\#' style");
  gr->Rotate(50,60);  gr->Box();  gr->Boxs(a,"#");

  gr->SubPlot(2,2,3); gr->Title("compare with Tile");
  gr->Rotate(50,60);  gr->Box();  gr->Tile(a);
  return 0;
}
@end verbatim

@float
@image{../png/boxs, 11cm}
@caption{Example of Boxs()}
@end float

@c ------------------------------------------------------------------
@node Tile sample, TileS sample, Boxs sample, 2D samples
@subsection Tile sample

@code{Tile} draw surface by tiles. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->Title("Tile plot");
  gr->Rotate(40,60);  gr->Box();  gr->Tile(a);
  return 0;
}
@end verbatim

@float
@image{../png/tile, 11cm}
@caption{Example of Tile()}
@end float

@c ------------------------------------------------------------------
@node TileS sample, Dens sample, Tile sample, 2D samples
@subsection TileS sample

@code{TileS} is similar to @code{Tile} but tile sizes is determined by another data. This allows one to simulate transparency of the plot. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,b;  mgls_prepare2d(&a,&b);
  gr->SubPlot(1,1,0,""); gr->Title("TileS plot");
  gr->Box();  gr->TileS(a,b);
  return 0;
}
@end verbatim

@float
@image{../png/tiles, 11cm}
@caption{Example of TileS()}
@end float


@c ------------------------------------------------------------------
@node Dens sample, Cont sample, TileS sample, 2D samples
@subsection Dens sample

@code{Dens} draw density plot for surface. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,a1(30,40,3);  mgls_prepare2d(&a);
  gr->Fill(a1,"0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)");
  gr->SubPlot(2,2,0,""); gr->Title("Dens plot (default)");
  gr->Box();  gr->Dens(a);

  gr->SubPlot(2,2,1); gr->Title("3d variant");
  gr->Rotate(50,60);  gr->Box();  gr->Dens(a);

  gr->SubPlot(2,2,2,"");  gr->Title("'\\#' style; meshnum 10");
  gr->Box();  gr->Dens(a,"#","meshnum 10");

  gr->SubPlot(2,2,3); gr->Title("several slices");
  gr->Rotate(50,60);    gr->Box();  gr->Dens(a1);
  return 0;
}
@end verbatim

@float
@image{../png/dens, 11cm}
@caption{Example of Dens()}
@end float

@c ------------------------------------------------------------------
@node Cont sample, ContF sample, Dens sample, 2D samples
@subsection Cont sample

@code{Cont} draw contour lines for surface. You can select automatic (default) or manual levels for contours, print contour labels, draw it on the surface (default) or at plane (as @code{Dens}). The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,v(5); mgls_prepare2d(&a); v.a[0]=-0.5;  v.a[1]=-0.15; v.a[2]=0; v.a[3]=0.15;  v.a[4]=0.5;
  gr->SubPlot(2,2,0); gr->Title("Cont plot (default)");
  gr->Rotate(50,60);  gr->Box();  gr->Cont(a);

  gr->SubPlot(2,2,1); gr->Title("manual levels");
  gr->Rotate(50,60);  gr->Box();  gr->Cont(v,a);

  gr->SubPlot(2,2,2); gr->Title("'\\_' style");
  gr->Rotate(50,60);  gr->Box();  gr->Cont(a,"_");

  gr->SubPlot(2,2,3,"");  gr->Title("'t' style");
  gr->Box();  gr->Cont(a,"t");
  return 0;
}
@end verbatim

@float
@image{../png/cont, 11cm}
@caption{Example of Cont()}
@end float

@c ------------------------------------------------------------------
@node ContF sample, ContD sample, Cont sample, 2D samples
@subsection ContF sample

@code{ContF} draw filled contours.  You can select automatic (default) or manual levels for contours. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,v(5),a1(30,40,3); mgls_prepare2d(&a); v.a[0]=-0.5;
  v.a[1]=-0.15; v.a[2]=0; v.a[3]=0.15;  v.a[4]=0.5;
  gr->SubPlot(2,2,0); gr->Title("ContF plot (default)");
  gr->Rotate(50,60);  gr->Box();  gr->ContF(a);

  gr->SubPlot(2,2,1); gr->Title("manual levels");
  gr->Rotate(50,60);  gr->Box();  gr->ContF(v,a);

  gr->SubPlot(2,2,2); gr->Title("'\\_' style");
  gr->Rotate(50,60);  gr->Box();  gr->ContF(a,"_");

  gr->Fill(a1,"0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)");
  gr->SubPlot(2,2,3); gr->Title("several slices");
  gr->Rotate(50,60);  gr->Box();  gr->ContF(a1);
  return 0;
}
@end verbatim

@float
@image{../png/contf, 11cm}
@caption{Example of ContF()}
@end float

@c ------------------------------------------------------------------
@node ContD sample, ContV sample, ContF sample, 2D samples
@subsection ContD sample

@code{ContD} is similar to @code{ContF} but with manual contour colors. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,v(5),a1(30,40,3); mgls_prepare2d(&a); v.a[0]=-0.5;
  v.a[1]=-0.15; v.a[2]=0; v.a[3]=0.15;  v.a[4]=0.5;
  gr->SubPlot(2,2,0); gr->Title("ContD plot (default)");
  gr->Rotate(50,60);  gr->Box();  gr->ContD(a);

  gr->SubPlot(2,2,1); gr->Title("manual levels");
  gr->Rotate(50,60);  gr->Box();  gr->ContD(v,a);

  gr->SubPlot(2,2,2); gr->Title("'\\_' style");
  gr->Rotate(50,60);  gr->Box();  gr->ContD(a,"_");

  gr->Fill(a1,"0.6*sin(2*pi*x+pi*(z+1)/2)*sin(3*pi*y+pi*z) + 0.4*cos(3*pi*(x*y)+pi*(z+1)^2/2)");
  gr->SubPlot(2,2,3); gr->Title("several slices");
  gr->Rotate(50,60);  gr->Box();  gr->ContD(a1);
  return 0;
}
@end verbatim

@float
@image{../png/contd, 11cm}
@caption{Example of ContD()}
@end float

@c ------------------------------------------------------------------
@node ContV sample, Axial sample, ContD sample, 2D samples
@subsection ContV sample

@code{ContV} draw vertical cylinders (belts) at contour lines. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a,v(5); mgls_prepare2d(&a); v.a[0]=-0.5;
  v.a[1]=-0.15; v.a[2]=0; v.a[3]=0.15;  v.a[4]=0.5;
  gr->SubPlot(2,2,0); gr->Title("ContV plot (default)");
  gr->Rotate(50,60);  gr->Box();  gr->ContV(a);

  gr->SubPlot(2,2,1); gr->Title("manual levels");
  gr->Rotate(50,60);  gr->Box();  gr->ContV(v,a);

  gr->SubPlot(2,2,2); gr->Title("'\\_' style");
  gr->Rotate(50,60);  gr->Box();  gr->ContV(a,"_");

  gr->SubPlot(2,2,3); gr->Title("ContV and ContF");
  gr->Rotate(50,60);  gr->Box();  gr->Light(true);
  gr->ContV(a); gr->ContF(a); gr->Cont(a,"k");
  return 0;
}
@end verbatim

@float
@image{../png/contv, 11cm}
@caption{Example of ContV()}
@end float

@c ------------------------------------------------------------------
@node Axial sample, , ContV sample, 2D samples
@subsection Axial sample

@code{Axial} draw surfaces of rotation for contour lines. You can draw wire surfaces (@samp{#} style) or ones rotated in other directions (@samp{x}, @samp{z} styles). The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData a;  mgls_prepare2d(&a);
  gr->SubPlot(2,2,0); gr->Title("Axial plot (default)");
  gr->Light(true);  gr->Alpha(true);  gr->Rotate(50,60);
  gr->Box();  gr->Axial(a);

  gr->SubPlot(2,2,1); gr->Title("'x' style"); gr->Rotate(50,60);
  gr->Box();  gr->Axial(a,"x");

  gr->SubPlot(2,2,2); gr->Title("'z' style"); gr->Rotate(50,60);
  gr->Box();  gr->Axial(a,"z");

  gr->SubPlot(2,2,3); gr->Title("'\\#' style"); gr->Rotate(50,60);
  gr->Box();  gr->Axial(a,"#");
  return 0;
}
@end verbatim

@float
@image{../png/axial, 11cm}
@caption{Example of Axial()}
@end float


@c ------------------------------------------------------------------
@node 3D samples, Vector field samples, 2D samples, Examples
@section 3D samples

This section is devoted to visualization of 3D data arrays. 3D means the data which depend on 3 indexes (parameters) like tensor a(i,j,k)=a(x(i),y(j),x(k)), i=1...n, j=1...m, k=1...l or in parametric form @{x(i,j,k),y(i,j,k),z(i,j,k),a(i,j,k)@}. Most of samples will use the same data for plotting. So, I put its initialization in separate function
@verbatim
void mgls_prepare3d(mglData *a, mglData *b=0)
{
  register long i,j,k,n=61,m=50,l=40,i0;
  if(a) a->Create(n,m,l);   if(b) b->Create(n,m,l);
  float x,y,z;
  for(i=0;i<n;i++)  for(j=0;j<m;j++)  for(k=0;k<l;k++)
  {
    x=2*i/(n-1.)-1; y=2*j/(m-1.)-1; z=2*k/(l-1.)-1; i0 = i+n*(j+m*k);
    if(a) a->a[i0] = -2*(x*x + y*y + z*z*z*z - z*z - 0.1);
    if(b) b->a[i0] = 1-2*tanh((x+y)*(x+y));
  }
}
@end verbatim
or using C functions
@verbatim
void mgls_prepare3d(HMDT a, HMDT b=0)
{
  register long i,j,k,n=61,m=50,l=40,i0;
  if(a) mgl_data_create(a,n,m,l);
  if(b) mgl_data_create(b,n,m,l);
  float x,y,z;
  for(i=0;i<n;i++)  for(j=0;j<m;j++)  for(k=0;k<l;k++)
  {
    x=2*i/(n-1.)-1; y=2*j/(m-1.)-1; z=2*k/(l-1.)-1; i0 = i+n*(j+m*k);
    if(a) mgl_data_set_value(a, -2*(x*x + y*y + z*z*z*z - z*z - 0.1), i,j,k);
    if(b) mgl_data_set_value(b, 1-2*tanh((x+y)*(x+y)), i,j,k);
  }
}
@end verbatim

@menu
* Surf3 sample::
* Surf3C sample::
* Surf3A sample::
* Cloud sample::
* Dens3 sample::
* Cont3 sample::
* ContF3 sample::
* Dens projection sample::
* Cont projection sample::
* ContF projection sample::
* TriPlot and QuadPlot::
* Dots sample::
@end menu

@c ------------------------------------------------------------------
@node Surf3 sample, Surf3C sample, , 3D samples
@subsection ContV sample

@code{Surf3} is one of most suitable (for my opinion) functions to visualize 3D data. It draw the isosurface(s) -- surface(s) of constant amplitude (3D analogue of contour lines). You can draw wired isosurfaces if specify @samp{#} style. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Surf3 plot");  gr->Rotate(50,60);
  gr->Light(true);  gr->Alpha(true);
  gr->Box();  gr->Surf3(c);
  return 0;
}
@end verbatim

@float
@image{../png/surf3, 11cm}
@caption{Example of Surf3()}
@end float

@c ------------------------------------------------------------------
@node Surf3C sample, Surf3A sample, Surf3 sample, 3D samples
@subsection Surf3C sample

@code{Surf3C} is similar to @code{Surf3} but its coloring is determined by another data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c,d;  mgls_prepare3d(&c,&d);
  gr->Title("Surf3C plot"); gr->Rotate(50,60);
  gr->Light(true);  gr->Alpha(true);
  gr->Box();  gr->Surf3C(c,d);
  return 0;
}
@end verbatim

@float
@image{../png/surf3c, 11cm}
@caption{Example of Surf3C()}
@end float

@c ------------------------------------------------------------------
@node Surf3A sample, Cloud sample, Surf3C sample, 3D samples
@subsection Surf3A sample

@code{Surf3A} is similar to @code{Surf3} but its transparency is determined by another data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c,d;  mgls_prepare3d(&c,&d);
  gr->Title("Surf3A plot"); gr->Rotate(50,60);
  gr->Light(true);  gr->Alpha(true);
  gr->Box();  gr->Surf3A(c,d);
  return 0;
}
@end verbatim

@float
@image{../png/surf3a, 11cm}
@caption{Example of Surf3A()}
@end float

@c ------------------------------------------------------------------
@node Cloud sample, Dens3 sample, Surf3A sample, 3D samples
@subsection Cloud sample

@code{Cloud} draw cloud-like object which is less transparent for higher data values. Similar plot can be created using many (about 10-20) @code{Surf3A(a,a)} isosurfaces. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->SubPlot(2,2,0); gr->Title("Cloud plot");
  gr->Rotate(50,60);  gr->Alpha(true);
  gr->Box();  gr->Cloud(c,"wyrRk");

  gr->SubPlot(2,2,1); gr->Title("'!' style");
  gr->Rotate(50,60);  gr->Box();  gr->Cloud(c,"!wyrRk");

  gr->SubPlot(2,2,2); gr->Title("'.' style");
  gr->Rotate(50,60);  gr->Box();  gr->Cloud(c,".wyrRk");

  gr->SubPlot(2,2,3); gr->Title("meshnum 10");
  gr->Rotate(50,60);  gr->Box();  gr->Cloud(c,"wyrRk","meshnum 10");
  return 0;
}
@end verbatim

@float
@image{../png/cloud, 11cm}
@caption{Example of Cloud()}
@end float

@c ------------------------------------------------------------------
@node Dens3 sample, Cont3 sample, Cloud sample, 3D samples
@subsection Dens3 sample

@code{Dens3} draw just usual density plot but at slices of 3D data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Dens3 sample");  gr->Rotate(50,60);
  gr->Alpha(true);  gr->SetAlphaDef(0.7);
  gr->SetOrigin(0,0,0); gr->Axis("_xyz"); gr->Box();
  gr->Dens3(c,"x"); gr->Dens3(c); gr->Dens3(c,"z");
  return 0;
}
@end verbatim

@float
@image{../png/densa, 11cm}
@caption{Example of Dens3()}
@end float

@c ------------------------------------------------------------------
@node Cont3 sample, ContF3 sample, Dens3 sample, 3D samples
@subsection Cont3 sample

@code{Cont3} draw just usual contour lines but at slices of 3D data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Cont3 sample");  gr->Rotate(50,60);
  gr->Alpha(true);  gr->SetAlphaDef(0.7);
  gr->SetOrigin(0,0,0); gr->Axis("_xyz"); gr->Box();
  gr->Cont3(c,"x"); gr->Cont3(c); gr->Cont3(c,"z");
  return 0;
}
@end verbatim

@float
@image{../png/conta, 11cm}
@caption{Example of Cont3()}
@end float

@c ------------------------------------------------------------------
@node ContF3 sample, Dens projection sample, Cont3 sample, 3D samples
@subsection ContF3 sample

@code{ContF3} draw just usual filled contours but at slices of 3D data. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("ContF3 sample");  gr->Rotate(50,60);
  gr->Alpha(true);  gr->SetAlphaDef(0.7);
  gr->SetOrigin(0,0,0); gr->Axis("_xyz"); gr->Box();
  gr->ContF3(c,"x");  gr->ContF3(c);    gr->ContF3(c,"z");
  gr->Cont3(c,"kx");  gr->Cont3(c,"k"); gr->Cont3(c,"kz");
  return 0;
}
@end verbatim

@float
@image{../png/contfa, 11cm}
@caption{Example of ContF3()}
@end float

@c ------------------------------------------------------------------
@node Dens projection sample, Cont projection sample, ContF3 sample, 3D samples
@subsection Dens projection sample

@code{Dens[XYZ]} draw density plot on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Dens[XYZ] sample");  gr->Rotate(50,60);
  gr->Box();  gr->DensX(c.Sum("x"),0,-1);
  gr->DensY(c.Sum("y"),0,1);  gr->DensZ(c.Sum("z"),0,-1);
  return 0;
}
@end verbatim

@float
@image{../png/dens_xyz, 11cm}
@caption{Example of DensX(), DensY(), DensZ()}
@end float

@c ------------------------------------------------------------------
@node Cont projection sample, ContF projection sample, Dens projection sample, 3D samples
@subsection Cont projection sample

@code{Cont[XYZ]} draw contour lines on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Cont[XYZ] sample");  gr->Rotate(50,60);
  gr->Box();  gr->ContX(c.Sum("x"),"",-1);
  gr->ContY(c.Sum("y"),"",1); gr->ContZ(c.Sum("z"),"",-1);
  return 0;
}
@end verbatim

@float
@image{../png/cont_xyz, 11cm}
@caption{Example of ContX(), ContY(), ContZ()}
@end float

@c ------------------------------------------------------------------
@node ContF projection sample, TriPlot and QuadPlot, Cont projection sample, 3D samples
@subsection ContF projection sample

@code{Dens[XYZ]} draw filled contours on plane perpendicular to corresponding axis. One of possible application is drawing projections of 3D field. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  mglData c;  mgls_prepare3d(&c);
  gr->Title("Cont[XYZ] sample");  gr->Rotate(50,60);
  gr->Box();  gr->ContFX(c.Sum("x"),"",-1);
  gr->ContFY(c.Sum("y"),"",1);  gr->ContFZ(c.Sum("z"),"",-1);
  return 0;
}
@end verbatim

@float
@image{../png/contf_xyz, 11cm}
@caption{Example of ContFX(), ContFY(), ContFZ()}
@end float

@c ------------------------------------------------------------------
@node TriPlot and QuadPlot, Axial sample, ContF projection sample, 3D samples
@subsection TriPlot and QuadPlot

@code{TriPlot} and @code{QuadPlot} draw set of triangles (or quadrangles for @code{QuadPlot}) for irregular data arrays. Note, that you have to provide not only vertexes, but also the indexes of triangles or quadrangles. I.e. perform triangulation by some other library. The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  float q[] = {0,1,2,3, 4,5,6,7, 0,2,4,6, 1,3,5,7, 0,4,1,5, 2,6,3,7};
  float xc[] = {-1,1,-1,1,-1,1,-1,1}, yc[] = {-1,-1,1,1,-1,-1,1,1}, zc[] = {-1,-1,-1,-1,1,1,1,1};
  mglData qq(6,4,q), xx(8,xc), yy(8,yc), zz(8,zc);
  gr->Light(true);  //gr->Alpha(true);
  gr->SubPlot(2,1,0); gr->Title("QuadPlot sample"); gr->Rotate(50,60);
  gr->QuadPlot(qq,xx,yy,zz,"yr");
  gr->QuadPlot(qq,xx,yy,zz,"k#");

  float t[] = {0,1,2, 0,1,3, 0,2,3, 1,2,3};
  float xt[] = {-1,1,0,0}, yt[] = {-1,-1,1,0}, zt[] = {-1,-1,-1,1};
  mglData tt(4,3,t), uu(4,xt), vv(4,yt), ww(4,zt);
  gr->SubPlot(2,1,1); gr->Title("TriPlot sample");  gr->Rotate(50,60);
  gr->TriPlot(tt,uu,vv,ww,"b");
  gr->TriPlot(tt,uu,vv,ww,"k#");
  return 0;
}
@end verbatim

@float
@image{../png/triplot, 11cm}
@caption{Example of TriPlot() and QuadPlot()}
@end float

@c ------------------------------------------------------------------
@node Dots sample, , TriPlot and QuadPlot, 3D samples
@subsection Dots sample

@code{Dots} is another way to draw irregular points. @code{Dots} use color scheme for coloring (see @ref{Color scheme}). The sample code is:
@verbatim
int sample(mglGraph *gr)
{
  int i, n=1000;
  mglData x(n),y(n),z(n);
  for(i=0;i<n;i++)
  {
    float t=M_PI*(mgl_rnd()-0.5), f=2*M_PI*mgl_rnd();
    x.a[i] = 0.9*cos(t)*cos(f);
    y.a[i] = 0.9*cos(t)*sin(f);
    z.a[i] = 0.6*sin(t);
  }
  gr->Title("Dots sample"); gr->Rotate(50,60);
  gr->Box();  gr->Dots(x,y,z);
  return 0;
}
@end verbatim

@float
@image{../png/dots, 11cm}
@caption{Example of Dots()}
@end float

@c ------------------------------------------------------------------
@node Vector field samples, Hints, 3D samples, Examples
@section Vector field samples

Vector field visualization (especially in 3d case) may look tangly -- there are too many overlapping lines. I may suggest 2 ways to solve this problem. The first one is to change @code{MeshNum} for decreasing the number of hachures. The second way is to use the flow thread chart @code{Flow}. Unfortunately, I don't know any other methods to visualize 3d vector field. If you know any, e-mail me and I shall add it to MathGL.


@c ------------------------------------------------------------------
@node Hints, FAQ, Vector field samples, Examples
@section Hints

In this section I have included some small hints and advices for the improving of the quality of plots and for the demonstration of some non-trivial features of MathGL library. In contrast to previous examples I showed mostly the idea but not the whole drawing function.

@menu
* ``Compound'' graphics::
* Two axes in one plot::
* Titles for the plot::
* Changing of the color range::
* Management of a point cutting::
* Vector field visualization::
* Several light sources::
* CutMin and CutMax features::
* Mapping visualization::
* Log-scaled plot::
* ``Templates''::
* Nonlinear fitting hints::
* PDE solving hints::
* MGL parser using::
* Stereo image::
@end menu

@c ------------------------------------------------------------------
@node ``Compound'' graphics, Two axes in one plot, , Hints
@subsection ``Compound'' graphics

As I noted above, MathGL functions (except the special one, like Clf()) do  not erase the previous plotting but just add the new one. It allows one to draw ``compound'' plots easily. For example, popular Matlab command @code{surfc} can be emulated in MathGL by 2 calls:
@verbatim
    Surf(a);
    Cont(a, 0, 7, -1);     // draw contours at z = -1
@end verbatim
Here @var{a} is 2-dimensional data for the plotting, @code{-1} is the value of z-coordinate at which the contour should be plotted (at the bottom in this example). Analogously, one can draw density plot instead of contour lines and so on.

Another nice plot is contour lines plotted directly on the surface:
@verbatim
    Light(true);       // switch on light for the surface
    Surf(a, "BbcyrR"); // select 'jet' colormap for the surface
    Cont(a, "y");      // and yellow color for contours
@end verbatim
The possible difficulties arise in black&white case, when the color of the surface can be close to the color of a contour line. In that case I may suggest the following code:
@verbatim
    Light(true);       // switch on light for the surface
    Surf(a, "kw");     // select 'gray' colormap for the surface
    CAxis(-1,0);       // first draw for darker surface colors
    Cont(a, "w");      // white contours
    CAxis(0,1);        // now draw for brighter surface colors
    Cont(a, "k");      // black contours
    CAxis(-1,1);       // return color range to original state
@end verbatim
The idea is to divide the color range on 2 parts (dark and bright) and to select the contrasting color for contour lines for each of part.

Similarly, one can plot flow thread over density plot of vector field amplitude (this is another amusing plot from Matlab) and so on. The list of compound graphics can be prolonged but I hope that the general idea is clear.

@c ------------------------------------------------------------------
@node Two axes in one plot, Titles for the plot, ``Compound'' graphics, Hints
@subsection Two axes in one plot

Developing the previous hint one can make a plot with 2 or more axes. The idea is that the change of settings does not influence on the already drawn graphics. So, for 2-axes plot let us set the first axis and draw everything concerning it. Then let us setup the second axis and draw things for the second axis. The corresponding code is (@pxref{2-axes sample}):
@verbatim
    // set up first axis
    Axis(mglPoint(-1,-1,-1),mglPoint(1,1,1),mglPoint(-1,-1,-1));
    Axis();            // draw it
    Plot(y1,"b");      // draw something in first axis
    // set up second axis
    Axis(mglPoint(0,0,0),mglPoint(1,1,1),mglPoint(1,1,1));
    Axis();            // draw it
    Stem(y2,"r");      // draw something in second axis
@end verbatim
Note, that the first and the second axes look better if being placed in different corners. In the code presented above the first axis is placed in the left-bottom corner, and the second one is placed in the right-top corner.

@c ------------------------------------------------------------------
@node Titles for the plot, Changing of the color range, Two axes in one plot, Hints
@subsection Titles for the plot

The printing of nice titles for the plot is not so trivial task in general case. The problem is that the rotation and aspect change lead to different looks for titles of different subplots. So, the resulting look is not so good as it could be. The solution is simple -- to print titles exactly after @code{SubPlot}() call and before any rotation, aspect change and so on! Analogously, the title for the whole picture looks better if it is printed first (before any @code{SubPlot()} calls). Alternatively you can use function @code{Title()} for plotting title for the picture at any time.

@c ------------------------------------------------------------------
@node Changing of the color range, Management of a point cutting, Titles for the plot, Hints
@subsection Changing of the color range

By default (for the user comfort), the color range is set equal to z-range of the plot. However, there are different ranges. So, one can obtain amusing plot by the change of color range manually. For example, there are plots with one-color bottom (or top) or practically bi-color picture and so on.

For example, compare 2 surfaces:
@verbatim
    SubPlot(2,1,0)
    Surf(a);           // usual coloring range
    SubPlot(2,1,1)
    CAxis(0,1);
    Surf(a);           // bottom of the surface have one-colour filling
@end verbatim

@c ------------------------------------------------------------------
@node Management of a point cutting, Vector field visualization, Changing of the color range, Hints
@subsection Management of a point cutting

Sometimes an experimental or numerical surface has outstanding points. Visualization of such surface will lead to the hole(s) in place of such points. The standard method of ``fighting''  -- to change data values -- is not always good and is not so convenient. MathGL library has another method -- to set variable @code{Cut=false}. As a consequence, all outstanding points will be projected on the bounding box.

Such method is good not only for outstanding points but also for the case when one need to plane the bottom or the top of the plot. Exactly such case is demonstrated in the code:
@verbatim
        mglData a(20,30);  // create some data
        a.Modify("0.6*sin(2*pi*x)*sin(3*pi*y) + 0.4*cos(3*pi*(x*y))");
        // set lower border above the data minimal value
        Axis(mglPoint(-1,-1,0),mglPoint(1,1,1));
        Cut = false;       // set off cutting flag
`       Surf(a);           // and draw the surface
@end verbatim
It is an interesting result, is not it?

@c ------------------------------------------------------------------
@node Vector field visualization, Several light sources, Management of a point cutting, Hints
@subsection Vector field visualization

Vector field visualization (especially in 3d case @code{Vect3} or @code{VectC}) may look tangly -- there are too many overlapping lines. I may suggest 2 ways to solve this problem. The first one is to change @code{MeshNum} for decreasing the number of hachures. The second way is to use the flow thread chart @code{Flow}. Unfortunately, I don't know any other methods to visualize 3d vector field. If you know any, e-mail me and I shall add it to MathGL.

@c ------------------------------------------------------------------
@node Several light sources, CutMin and CutMax features, Vector field visualization, Hints
@subsection Several light sources

In contrast to the most of other programs, MathGL supports several (up to 10) light sources. Moreover, the color each of them can be different: white (this is usual), yellow, red, cyan, green and so on. The use of several light sources may be interesting for the highlighting of some peculiarities of the plot or just to make an amusing picture. Note, each light source can be switched on/off individually (@pxref{Several light sample}).

@c ------------------------------------------------------------------
@node CutMin and CutMax features, Mapping visualization, Several light sources, Hints
@subsection CutMin and CutMax features

MathGL library has a feature for cutting of points in some region @var{CutMin*CutMax}. Such an excision can be used to improve the look of the graphics. Moreover, this cutting may help to show an internal structure of an object (like @code{isocaps} plot in Matlab). For example, let us use the standard 3D data array and show its interior (@pxref{CutMinMax sample}).

@verbatim
    mglData  c(61,51,40);      // create the data
    mglData v(10);	v.Fill(-0.5,1);
    c.Modify("(-2*((2*x-1)^2 + (2*y-1)^2 + (2*z-1)^4 - (2*z-1)^2 - 0.1))");
    gr->CutMin = mglPoint(0,-1,-1);     gr->CutMax = mglPoint(1,0,1.1);
    gr->Surf3(-0.5,c,"BbcyrR");
    gr->ContF3(v,c,'x',-1,"BbcyrR");    gr->ContF3(v,c,'y',-1,"BbcyrR");
    gr->ContF3(v,c,'z',0,"BbcyrR");     gr->ContF3(v,c,'z',39,"BbcyrR");
@end verbatim

One can also exclude points from arbitrary area in space. This area defined by textual formula @code{CutOff()} (@pxref{Cutting}). The algorithm is the same as shown for ``rectangular cutting''.

@c ------------------------------------------------------------------
@node Mapping visualization, Log-scaled plot, CutMin and CutMax features, Hints
@subsection Mapping visualization

Sometime ago I worked with mapping and have a question about its visualization. Let me remember you that mapping is some transformation rule for one set of number to another one. The 1d mapping is just an ordinary function -- it takes a number and transforms it to another one. The 2d mapping (which I used) is a pair of functions which take 2 numbers and transform them to another 2 ones. Except general plots (like @code{SurfC}, @code{SurfA}) there is a special plot -- Arnold diagram. It shows the area which is the result of mapping of some initial area (usually square).

I tried to make such plot in @code{Map}. It shows the set of points or set of faces, which final position is the result of mapping. At this, the color gives information about their initial position and the height describes Jacobian value of the transformation. Unfortunately, it looks good only for the simplest mapping but for the  real multivalent quasi-chaotic mapping it produces a confusion. So, use it if you like :).

@c ------------------------------------------------------------------
@node Log-scaled plot, ``Templates'', Mapping visualization, Hints
@subsection Log-scaled plot

Log-scaled plot can be drawn by 2 steps. First, one should change the scale of axis by call @code{SetFunc("lg(x)", "lg(y)");} (in this example, x- and y-axis will be log-scaled). Second, one should set logarithmic scale for axis ticks by changing variables: @code{SetTicks('x',0); SetTicks('y',0);}. Finally, one should check (or change) the axis ranges and origin so that their values to be positive. For example of log-log plot @pxref{Log-log sample}.

@c ------------------------------------------------------------------
@node ``Templates'', Nonlinear fitting hints, Log-scaled plot, Hints
@subsection ``Templates''

As I have noted before, the change of settings will influence only for the further plotting commands. This allows one to create template function which will contain settings and primitive drawing for often used plots. Correspondingly one may call this template-function for drawing simplification.

For example, let one has a set of points (experimental or numerical) and wants to compare it with theoretical law (for example, with exponent law @math{\exp(-x/2), x \in [0, 20]}). The template-function for this task is:
@verbatim
    void template(mglGraph *gr)
    {
        mglData  law(100);      // create the law
        law.Modify("exp(-10*x)");
        gr->Axis(mglPoint(0,0.0001), mglPoint(20,1), mglPoint(0,0.0001));
        gr->SetFunc(0,"lg(y)",0);   gr->dy = 0;
        gr->Plot(law,"r2");
        gr->Text(mglPoint(10,0.2),"Theoretical law: e^x","rL");
        gr->Label('x',"x val."); gr->Label('y',"y val.");
        gr->Axis(); gr->Grid("xy","g;"); gr->Box();
    }
@end verbatim
At this, one will only write a few lines for data drawing:
@verbatim
    template(gr);     // apply settings and default drawing from template
    mglData dat("fname.dat"); // load the data
    // and draw it (suppose that data file have 2 columns)
    gr->Plot(dat.SubData(0),dat.SubData(1),"bx ");
@end verbatim
A template-function can also contain settings for font, transparency, lightning, color scheme and so on.

@c ------------------------------------------------------------------
@node Nonlinear fitting hints, PDE solving hints, ``Templates'', Hints
@subsection Nonlinear fitting hints

Nonlinear fitting is rather simple. All that you need is the data to fit, the approximation formula and the list of coefficients to fit (better with its initial guess values). Let me demonstrate it on the following simple example (@pxref{Fitting sample}). First, let us use sin function with some random noise:
@verbatim
    mglData rnd(100), idl(50); //data to be fitted and ideal data
    rnd.Modify("0.4*rnd+0.1+sin(4*pi*x)");
    idl.Modify("0.3+sin(4*pi*x)");
@end verbatim
and plot it to see that data we will fit
@verbatim
    gr->Axis(mglPoint(-1,-2), mglPoint(1,2));
    gr->Plot(rnd, ". "); gr->Plot(idl, "b");
    gr->Box();
    gr->Text(mglPoint(0,2.2), "initial: y = 0.3+sin(2\pi x)", "C:b", -1);
@end verbatim

The next step is the fitting itself. For that let me specify an initial values @var{ini} for coefficients @samp{abc} and do the fitting for approximation formula @samp{a+b*sin(c*x)}
@verbatim
    mglData res;   // The data for found formula
    float ini[3] = {1, 1, 3};
    gr->Fit(res, rnd, "a+b*sin(c*x)", "abc", ini);
@end verbatim
Now display it
@verbatim
    gr->Plot(res, "r");
    gr->Text(mglPoint(-1,-1.3), "fitted:", "L:r", -1);
    gr->PutsFit(mglPoint(0,-1.8), "y = ", "C:r", -1);
@end verbatim

NOTE! the fitting results may have strong dependence on initial values for coefficients due to algorithm features. The problem is that in general case there are several local "optimums" for coefficients and the program returns only first found one! There are no guaranties that it will be the best. Try for example to set @code{ini[3] = @{0, 0, 0@}} in the code above.

@c ------------------------------------------------------------------
@node PDE solving hints, MGL parser using, Nonlinear fitting hints, Hints
@subsection PDE solving hints

Solving of Partial Differential Equations (PDE, including beam tracing) and ray tracing (or finding particle trajectory) are more or less common task. So, MathGL have several functions for that. There are @code{mglRay()} for ray tracing, @code{mglPDE()} for PDE solving, @code{mglQO2d()} for beam tracing in 2D case (@pxref{Global functions}). Note, that these functions take ``Hamiltonian'' or equations as string values. And I don't plan now to allow one to use user-defined functions. There are 2 reasons: the complexity of corresponding interface; and the basic nature of used methods which are good for samples but may not good for serious scientific calculations.

The ray tracing can be done by @code{mglRay()} function. Really ray tracing equation is Hamiltonian equation for 3D space. So, the function can be also used for finding a particle trajectory (i.e. solve Hamiltonian ODE) for 1D, 2D or 3D cases. The function have a set of arguments. First of all, it is Hamiltonian which defined the media (or the equation) you are planning to use. The Hamiltonian is defined by string which may depend on coordinates @samp{x}, @samp{y}, @samp{z}, time @samp{t} (for particle dynamics) and momentums @samp{p}=@math{p_x}, @samp{q}=@math{p_y}, @samp{v}=@math{p_z}. Next, you have to define the initial conditions for coordinates and momentums at @samp{t}=0 and set the integrations step (default is 0.1) and its duration (default is 10). The Runge-Kutta method of 4-th order is used for integration.
@verbatim
    mglData r,a,re(128),im(128);
    r = mglRay("p^2+q^2-x-1", mglPoint(-0.7, -1), mglPoint(0, 0.5));
    gr->Plot(r.SubData(0), r.SubData(1));
@end verbatim
This example calculate the reflection from linear layer (media with Hamiltonian @samp{p^2+q^2-x-1}=@math{p_x^2+p_y^2-x-1}). This is parabolic curve. The resulting array have 7 columns which contain data for @{x,y,z,p,q,v,t@}.

The solution of PDE is a bit more complicated. As previous you have to specify the equation as pseudo-differential operator @math{\hat H(x, \nabla)} which is called sometime as ``Hamiltonian'' (for example, in beam tracing). As previously, it is defined by string which may depend on coordinates @samp{x}, @samp{y}, @samp{z} (but not time!), momentums @samp{p}=@math{(d/dx)/i k_0}, @samp{q}=@math{(d/dy)/i k_0} and field amplitude @samp{u}=@math{|u|}. The evolutionary coordinate is @samp{z} in all cases. So that, the equation look like @math{du/dz = ik_0 H(x,y,\hat p, \hat q, |u|)[u]}. Dependence on field amplitude @samp{u}=@math{|u|} allows one to solve nonlinear problems too. For example, for nonlinear Shrodinger equation you may set @code{ham="p^2 + q^2 - u^2"}. Also you may specify imaginary part for wave absorption, like @code{ham = "p^2 + i*x*(x>0)"}, but only if dependence on variable @samp{i} is linear (i.e. @math{H = Hre+i*Him}).

Next step is specifing the initial conditions at @samp{z}=@code{Min.z}. The function need 2 arrays for real and for imaginary part. Note, that coordinates x,y,z are supposed to be in specified range [Min, Max]. So, the data arrays should have corresponding scales. Finally, you may set the integration step and paramter k0=@math{k_0}. Also keep in mind, that internally the 2 times large box is used (for suppressing numerical reflection from boundaries) and the equation should well defined even in this extended range.

Final comment is concerning the possible form of pseudo-differential operator @math{H}. At this moment, simplified form of operator @math{H} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this operator is effectively @math{H = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed for 3D case.

So, for example let solve the equation for beam deflected from linear layer and absorbed later. The operator will have the form @samp{"p^2+q^2-x-1+i*0.5*(z+x)*(z>-x)"} that correspond to equation @math{ik_0 \partial_z u + \Delta u + x \cdot u + i (x+z)/2 \cdot u = 0}. This is typical equation for Electron Cyclotron (EC) absorption in magnetized plasmas. For initial conditions let me select the beam with plane phase front @math{exp(-48*(x+0.7)^2)}. The corresponding code looks like this (@pxref{PDE sample}):
@verbatim
    mglData a,re(128),im(128);
    re.Fill("exp(-48*(x+0.7)^2)", gr->Min, gr->Max);
    a = mglPDE("p^2+q^2-x-1+i*0.5*(z+x)*(z>-x)", re, im,
                gr->Min, gr->Max, 0.01, 30);
    a.Transpose("yxz");
    gr->CAxis(0, 1);
    gr->Dens(a,"wyrRk");
@end verbatim

The last example is example of beam tracing. Beam tracing equation is special kind of PDE equation written in coordinates accompanied to a ray. Generally this is the same parameters and limitation as for PDE solving but the coordinates are defined by the ray and by parameter of grid width @var{w} in direction transverse the ray. So, you don't need to specify the range of coordinates. @strong{BUT} there is limitation. The accompanied coordinates are well defined only for smooth enough rays, i.e. then the ray curvature @math{K} (which is defined as @math{1/K^2 = (|\ddot r|^2 |\dot r|^2 - (\ddot r, \dot r)^2)/|\dot r|^6}) is much large then the grid width: @math{K>>w}. So, you may receive incorrect results if this condition will be broken.

You may use following code for obtaining the same solution as in previous example:
@verbatim
    mglData r, xx, yy, a, im(128), re(128);
    const char *ham = "p^2+q^2-x-1+i*0.5*(y+x)*(y>-x)";
    r = mglRay(ham, mglPoint(-0.7, -1), mglPoint(0, 0.5), 0.02, 2);
    // now start beam tracing
    re.Fill("exp(-48*x^2)", gr->Min, gr->Max);
    a = mglQO2d(ham, re, im, r, 1, 30, &xx, &yy);
    gr->CAxis(0, 1);
    gr->Dens(xx, yy, a, "wyrRk");
@end verbatim


@c ------------------------------------------------------------------
@node MGL parser using, Stereo image, PDE solving hints, Hints
@subsection MGL parser using

Sometimes you may prefer to use MGL scripts in yours code. It is simpler (especially in comparison with C/Fortran interfaces) and fast way to plot the data with annotations, labels and so on. Class @code{mglParse} (@pxref{mglParse class} parse MGL scripts in C++. It have also the corresponding interface for C/Fortran.

The key function here is @code{mglParse::Parse()} (or @code{mgl_parse()} for C/Fortran) which execute one command per string. At this the detailed information about the possible errors or warnings is passed as function value. Or you may execute the whole script as long string with lines separated by @samp{\n}. Functions @code{mglParse::Execute()} and @code{mgl_parse_text()} perform it. Also you may set the values of paramters @samp{$0}...@samp{$9} for the script by functions @code{mglParse::AddParam()} or @code{mgl_add_param()}, allow/disable picture resizing, check ``once'' status and so on. The usage is rather stright-forward.

The only non-obvious thing is data transition between script and yours program. There are 2 stages: add or find variable; and set data to variable. In C++ you may use functions @code{mglParse::AddVar()} and @code{mglParse::FindVar()} which return pointer to @code{mglVar} structure. This structure contain data itself, the variable name and callback function which will be called if variable destroied. Last feature allows you to control the presence of the variable and, for example, close a window with data if this variable is destroyed. In C/Fortran the corresponding functions are @code{mgl_add_var()}, @code{mgl_find_var()}. But these functions return the data array only. Note, you @strong{must not delete or free} the data obtained from these functions!

So, some simple example at the end. Here I define a data array, create variable, put data into it and plot it. The C++ code looks like this:
@verbatim
    float a[100];   // let a_i = sin(4*pi*x), x=0...1
    for(int i=0;i<100;i++)  a[i]=sin(4*M_PI*i/99);
    mglParse *parser = new mglParse;
    mglData &d = (parser->AddVar("dat"))->d;
    d.Set(a,100); // set data to variable
    parser->Execute(gr, "plot dat; xrange 0 1\nbox\naxis");
    // you may break script at any line do something
    // and continue after that
    parser->Execute(gr, "xlabel 'x'\nylabel 'y'");
    // also you may use cycles or conditions in script
    parser->Execute(gr, "for $0 -1 1 0.1\nline 0 0 -1 $0 'r'\nnext");
    gr->WritePNG("test.png");   // don't forgot to save picture
@end verbatim
The code in C/Fortran looks practically the same:
@verbatim
    float a[100];   // let a_i = sin(4*pi*x), x=0...1
    int i;
    for(i=0;i<100;i++)  a[i]=sin(4*M_PI*i/99);
    HMPR parser = mgl_create_parser();
    HMDT d = mgl_add_var(parser, "dat");
    mgl_data_set_float(d,a,100,1,1);    // set data to variable
    mgl_parse_text(gr, parser, "plot dat; xrange 0 1\nbox\naxis");
    // you may break script at any line do something
    // and continue after that
    mgl_parse_text(gr, parser, "xlabel 'x'\nylabel 'y'");
    // also you may use cycles or conditions in script
    mgl_parse_text(gr, parser, "for $0 -1 1 0.1\nline 0 0 -1 $0 'r'\nnext");
    mgl_write_png(gr, "test.png", "");  // don't forgot to save picture
@end verbatim

@c ------------------------------------------------------------------
@node Stereo image, , MGL parser using, Hints
@subsection Stereo image

One can easily create stereo image in MathGL. Stereo image can be produced by making two subplots with slightly different rotation angles. The corresponding code looks like this (@pxref{Stereo image sample}):
@verbatim
    gr->SubPlot(2,1,0);     // left image
    gr->Rotate(40,60+3);
    // draw something here

    gr->SubPlot(2,1,1);     // right image
    gr->Rotate(40,60-3);
    // draw the same here
@end verbatim

@node FAQ, , Hints, Examples
@section FAQ

@table @strong
@item The plot does not appear
Check that points of the plot lie  inside the bounding box and resize the bounding box using @code{Axis()} function. Check that the data have correct dimensions for selected type of plot. Be sure that  @code{Finish()} is called after the plotting functions (or be sure that the plot is saved to a file). Sometimes the light reflection from flat surfaces (like, @code{Dens()}) can look as if the plot were absent.

@item I can not find some special kind of plot.
Most ``new'' types of plots can be created by using the existing drawing functions. For example, the surface of curve rotation can be created by a special function @code{Torus()}, or as a parametrically specified surface by @code{Surf()}. See also, @ref{Hints}. If you can not find a specific type of plot, please e-mail me and this plot will appear in the next version of MathGL library.

@item Should I know some graphical libraries (like OpenGL) before using the MathGL library?
No. The MathGL library is self-contained and does not require the knowledge of external libraries.

@item In which language is the library written? For which languages does it have an interface?
The core of the MathGL library is written in C++. But there are interfaces for: pure C, Fortran, Pascal, Forth, and its own command language MGL. Also there is a large set of interpreted languages, which are supported (Python, Java,  ALLEGROCL, CHICKEN, Lisp, CFFI, C#, Guile, Lua, Modula 3, Mzscheme, Ocaml, Octave, Perl, PHP, Pike, R, Ruby, Tcl). These interfaces are written using SWIG (both pure C functions and classes) but only the interface for Python and Octave is included in the autoconf/automake script. The reason is that I don't know any other interpreted languages :(. Note that most other languages can use (link to) the pure C functions.

@item How can I use MathGL with Fortran?
You can use MathGL as is with @code{gfortran} because it uses by default the AT&T notation for external functions. For other compilers (like Visual Fortran) you have to switch on the AT&T notation manually. The AT&T notation requires that the symbol @samp{_} is added at the end of each function name, function argument(s) is passed by pointers and the string length(s) is passed at the end of the argument list. For example:

@emph{C function} -- @code{void mgl_fplot(HMGL graph, const char *fy, const char *stl, int n);}

@emph{AT&T function} -- @code{void mgl_fplot_(uintptr_t *graph, const char *fy, const char *stl, int *n, int ly, int ls);}

@item I have a class Foo and a drawing method Foo::draw(mglGraph *gr). How I can use it in FLTK or GLUT window?
The member-functions of classes have a hidden parameter (the pointer to a class instance) in C++. So, their direct usage is impossible. The solution is to write an interface function:
@example
int foo_draw(mglGraph *gr, void *par)
@{   ((Foo *)foo)->draw(gr);    @}
@end example
and to use it in the call of @code{Window()} function:
@example
gr->Window(argc,argv,foo_draw,"Title",this);
@end example

Alternatively you can inherit your class from @code{mglDraw} class and use the functions like @code{gr->Window(argc, argv, foo, "Title");}.

@item How can I print in Russian/Spanish/Arabic/Japanese, and so on?
The standard way is to use Unicode encoding for the text output. But the MathGL library also has interface for 8-bit (char *) strings with internal conversion to Unicode. This conversion depends on the current locale OS. You may change it by @code{setlocale()} function. For example, for Russian text in CP1251 encoding you may use @code{setlocale(LC_CTYPE, "ru_RU.cp1251");} (under MS Windows the name of locale may differ -- @code{setlocale(LC_CTYPE, "russian_russia.1251")}). I strongly recommend not to use the constant @code{LC_ALL} in the conversion. Since it also changes the number format, it may lead to mistakes in formula writing and reading of the text in data files. For example, the program will await a @samp{,} as a decimal point but the user will enter @samp{.}.

@item How can I exclude a point or a region of plot from the drawing?
There are 3 general ways. First, the point with @code{NAN} value as one of the coordinates will never be plotted. Second, special variables @var{CutMin}, @var{CutMax} or function @code{CutOff}() define the condition when the points should be omitted (@pxref{Cutting}). Last, you may change the transparency of a part of the plot by the help of functions @code{SurfA()}, @code{Surf3A()} (@pxref{Dual plotting}). In this last case the transparency is switched on smoothly.

@item I use VisualStudio, CBuilder or some other compiler (not MinGW/gcc). How can I link the MathGL library?
In version 2.0, the recommended class @code{mglGraph} (header file @code{#include <mgl/mgl.h>}) contains only @code{inline} functions and is acceptable for any compiler with the same binary files. However, if you plan to access low-level features (i.e. classes mglBase, mglCanvas and so on) then you have to recompile MathGL by yours compiler.

@c @strong{Finally!} Please @emph{do not} ask me Windows-specific questions. I do not use Windows. I know nothing about Visual Basic, Visual C++, CBuiled or .NET. Please find the appropriate Usenet discussion group and ask your question there.

@item How I can build MathGL under Windows?
The simplest way is using the combination CMake+MinGW. Also you need some extra libraries like GSL, PNG, JPEG and so on. All of them can be found at @url{http://gnuwin32.sourceforge.net/packages.html}. After installing all components, just run CMake configurator and make the MathGL itself.

@item How I can create FLTK/GLUT/Qt window in parallel with calculation?
You should create a separate thread for processing window messages. The cross-platform way is using the @code{pthread} library. You can update the data by calling @code{mglGraphFLTK::Update()} function. The code can look like this:
@verbatim
//-----------------------------------------------------------------------------
#include <mgl/window.h>
#include <pthread.h>

mglPoint pnt;  // some global variable for changable data
//-----------------------------------------------------------------------------
int sample(mglGraph *gr)
{
  gr->Box();  gr->Line(mglPoint(),pnt,"Ar2"); // just draw a vector
  return 0;
}
//-----------------------------------------------------------------------------
void *mgl_fltk_tmp(void *)      {       mglFlRun();     return 0;       }
int main (int argc, char ** argv)
{
  mglWindow gr(0,sample,"test");  // create window
  static pthread_t tmp;
  pthread_create(&tmp, 0, mgl_fltk_tmp, 0);
  pthread_detach(tmp);    // run window handling in the separate thread
  for(int i=0;i<10;i++)   // do calculation
  {
    sleep(1);             // which can be very long
    pnt = mglPoint(2*mgl_rnd()-1,2*mgl_rnd()-1);
    gr.Update();          // update window
  }
  return 0;   // finish calculations and close the window
}
//-----------------------------------------------------------------------------
@end verbatim
If you just need a static image with current results of calculation then you can set @code{NULL} as plotting function and call @code{Update()} when you want to update the image. This way is also usefult for Fortran users.
@verbatim
//-----------------------------------------------------------------------------
#include <mgl/window.h>
//-----------------------------------------------------------------------------
int sample(mglGraph *gr)
{
  gr->Box();  gr->Line(mglPoint(),pnt,"Ar2"); // just draw a vector
  return 0;
}
//-----------------------------------------------------------------------------
void *mgl_fltk_tmp(void *)      {       mglFlRun();     return 0;       }
int main (int argc, char ** argv)
{
  mglWindow gr(0,NULL,"test");  // create window
  for(int i=0;i<10;i++)   // do calculation
  {
    sleep(1);             // which can be very long
    pnt = mglPoint(2*mgl_rnd()-1,2*mgl_rnd()-1);
    sample(&gr);          // draw picture
    gr.Update();          // update window
  }
  return 0;   // finish calculations and close the window
}
//-----------------------------------------------------------------------------
@end verbatim


@item How many people write this library?
Most of the library was written by one person. This is a result of nearly a year of work (mostly in the evening and on holidays): I spent half a year to write the kernel and half a year to a year on extending, improving the library and writing documentation. This process continues now :). The autoconf/automake script was written mostly by D.Kulagin, and the export to IDTF was written mostly by M.Vidassov.

@item How can I display a bitmap on the figure?
You can import data into a @code{mglData} instance and display it by @code{Dens()} function. For example, for black-and-white bitmap you can use the code: @code{mglData bmp; bmp.Import("fname.png","wk"); gr->Dens(bmp,"wk");}.

@item How can I use MathGL in Qt, FLTK, wxWidgets etc.?
There are special classes (widgets) for these libraries: QMathGL for Qt, Fl_MathGL for FLTK and so on. If you don't find the appropriate class then you can create your own widget that displays a bitmap using mglCanvas::GetBits().

@item How can I create U3D file (make 3D in PDF)?
There are 2 steps: first you should create IDTF file, and later convert it to U3D. You can use @uref{http://sourceforge.net/project/showfiles.php?group_id=152187&package_id=300628, U3D tools} for converting IDTF file to U3D. It needs @uref{http://libharu.org, libharu} 2.1.0 or later. For installation use @code{./bootstrap, ./configure, make, sudo make install}. It provides  IDTFConverter program for converting text files *.idtf to binary files *.u3d. The latter can be included into PDF.

@item How I can change the font family?
First, you should download new font files from @uref{http://mathgl.sourceforge.net/download.html, here} or from @uref{http://sourceforge.net/project/showfiles.php?group_id=152187&package_id=267177, here}. Next, you should load the font files into mglGraph class instance @var{gr} by the following command: @code{gr->LoadFont(fontname,path);}. Here @var{fontname} is the base font name like @samp{STIX} and @var{path} sets the location of font files. Use @code{gr->RestoreFont();} to start using the default font.

@item How can I draw tick out of a bounding box?
Just set a negative value in @var{SetTickLen}. For example, use @code{gr->SetTickLen(-0.1);}.

@end table



@c ------------------------------------------------------------------
@node Surface transparency, , Plots for 3D data, Data plotting
@subsection Surface transparency

MathGL library has advanced features for setting and handling the surface transparency. The simplest way to add transparency is the using of function @code{Alpha()}. As a result, all further surfaces (and isosurfaces, density plots and so on) become transparent. However, their  look can be additionally improved.

First, the selected surface will be non-transparent if one sets the flag @code{Transparent} before the surface drawing and sets it off after the drawing.

Second, the value of transparency can be different from surface to surface. To do it just change the value of @code{AlphaDef} before the drawing of the selected surface. If its value is close to 0 then the surface becomes more and more transparent. Contrary, if its value is close to 1 then the surface becomes practically non-transparent. This is some analogue of @code{Transparent=true}.

Third feature is the changing of the way how the light goes through overlapped surfaces. The variable @code{TranspType} defines it. By default the usual transparency is used (@code{TranspType=0}) -- surfaces below is less visible than the upper ones. A ``glass-like'' transparency (@code{TranspType=1}) has a different look when the surface just decreases the background light (the surfaces are commutable in this case).

A ``neon-like'' transparency (@code{TranspType=2}) has more interesting look. In this case a surface is the light source (like a lamp on the dark background) and just adds some intensity to the color. At this, the library sets automatically the black color for the background and changes the default line color to white.

As example I shall show the variant of plot from @ref{Plots for 2D data} (grid drawing is disabled) for different types of transparency.
@float
@image{../png/type0, 7cm}
@caption{Example of @code{TranspType=0}.}
@end float
@float
@image{../png/type1, 7cm}
@caption{Example of @code{TranspType=1}.}
@end float
@float
@image{../png/type2, 7cm}
@caption{Example of @code{TranspType=2}.}
@end float

