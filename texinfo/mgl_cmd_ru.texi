@c ------------------------------------------------------------------
@chapter Язык MGL

MathGL имеет встроенный скриптовый язык MGL для обработки и отображения данных. Скрипты MGL можно использовать как независимо (программами UDAV, mgl2png, mgl2eps, mgl2svg и пр., @pxref{Utilities}) так и вызовами библиотеки.

Язык MGL достаточно простой. Каждая строка -- отдельная команда. Первое слово -- имя команды, а все остальные ее аргументы. Команда может иметь до 1000 аргументов (по крайней мере сейчас). Слова разделяются одно от другого пробелом или символом табуляции. Различий между верхним и нижним индексом нет, т.е. переменные @var{a} и @var{A} идентичны. Символ @samp{#} начинает комментарий -- все символы после него игнорируются до конца строки. Исключением является случай, когда @samp{#} входит в строку. Опции команды указываются после символа @samp{;} (@pxref{Command options @MGL{}}). Символ @samp{:} начинает новую команду (подобно переводу строки) если он расположен не внутри скобок или строки.

Если строка содержит ссылки на внешние параметры (@samp{$0}, @samp{$1} ... @samp{$9}) или макроопределения (@samp{$a}, @samp{$b} ... @samp{$z}), то текущие значения параметров/макроопределений подставляются в строку вместо ссылки до выполнением команды. Это позволяет использовать один и тот же скрипт при различных входных параметрах командной строки или вводить макроопределения по ходу исполнения команд скрипта.

Аргументы команды могут быть строками, переменными или числами. 
@itemize @bullet
@item 
Строка -- произвольный набор символов между метками @samp{'}.

@item 
Обычно переменная имеет имя, состоящее из букв и чисел (должно начинаться с буквы и не быть длиннее 64 символов). В качестве переменной можно использовать временные массивы, включающие в себя:
@itemize @bullet
@item 
срезы (``подмассивы'') массивов данных (подобно команде @ref{subdata}). Например, @code{a(1)} или @code{a(1,:)} или @code{a(1,:,:)} -- вторая строка массива @var{a}, @code{a(:,2)} или @code{a(:,2,:)} -- третий столбец, @code{a(:,:,0)} -- первый срез и т.д. Также можно выделить часть массива с m-го по n-ый элемент @code{a(m:n,:,:)} или просто @code{a(m:n)}.

@item 
произвольные комбинации столбцов данных (например, @code{a('n*w^2/exp(t)')}), если столбцы данных были именованы командой @ref{idset} или в файле данных (в строке начинающейся с @code{##}).

@item 
произвольное выражение из существующих переменных и констант. Например, @samp{sqrt(dat(:,5)+1)} даст временный массив данных с элементами равными @code{tmp[i,j] = sqrt(dat[i,5,j]+1)}.

@item 
массивы с элементами заданными в квадратных скобках [], разделенные @samp{,}. При этом внутри выражения не должно быть пробелов! Например, @samp{[1,2,3]} даст временный массив из 3 элементов @{1, 2, 3@}; @samp{[[11,12],[21,22]]} даст матрицу 2*2 и т.д. Элементами такой конструкции могут быть и массивы если их размерности одинаковые, например @samp{[v1,v2,...,vn]}.

@item 
результат команд построения новых данных (@pxref{Make another data}), если они заключены в фигурные скобки @{@}. Например, @samp{@{sum dat 'x'@}} даст временный массив, который есть результат суммирования @var{dat} вдоль 'x'. Это такой же массив как и @var{tmp}, полученный командой @samp{sum tmp dat 'x'}. При этом можно использовать вложенные конструкции, например @samp{@{sum @{max dat 'z'@} 'x'@}}.
@end itemize
Временные массивы не могут стоять в качестве первого аргумента команд, создающих массивы (например, @samp{new}, @samp{read}, @samp{hist} и т.д.).

@item 
К скалярным переменным, кроме собственно чисел, относятся: специальные переменные @code{nan=#QNAN, pi=3.1415926..., on=1, off=0, :=-1}, переменные с суффиксами (@pxref{Suffixes}), переменные определенные командой @ref{define}. Также массивы размером 1x1x1 считаются скалярами (например, @samp{pi/dat.nx}).
@end itemize
Перед первым использованием все переменные должны быть определены с помощью команд, создающих массивы (@ref{new}, @ref{var}, @ref{list}, @ref{copy}, @ref{read}, @ref{hist}, @ref{sum} и др., @pxref{Data create @MGL{}} и @ref{Make another data @MGL{}}). 

Команды могут иметь несколько наборов аргументов (например, @code{plot ydat} и @code{plot xdat ydat}). Все аргументы команды для выбранного набора должны быть указаны, однако часть из них могут иметь значения по умолчанию. Такие аргументы в описании команд будут помещены в квадратные скобки [], например @code{plot ydat ['stl'='' zval=nan]}. При этом запись @code{[arg1 arg2 arg3 ...]} подразумевает @code{[arg1 [arg2 [arg3 ...]]]}, т.е. опускать можно только аргументы с конца, если вы согласны с их значениями по умолчанию. Например, @code{plot ydat '' 1} или @code{plot ydat ''} правильно, а @code{plot ydat 1} не правильно (аргумент @code{'stl'} пропущен).

Все команды MGL можно разделить на несколько групп. В дальнейшем будет использованы следующие обозначения при описании команд: имя команды выделено жирным, строки заключены в одинарные кавычки '', переменные выделены курсивом, числа (скаляры) выделены моноширинным шрифтом. Необязательные аргументы будут помещены в квадратные скобки [] и показаны их значения по умолчанию. Подробную информацию о цвете и стиле линий (@pxref{Line styles}), цветовых схемах (@pxref{Color scheme}), стиле текста и символах TeX (@pxref{Font styles}), текстовых формулах (@pxref{Textual formulas}) можно найти в соответствующих разделах.

@menu
@ifset UDAV
* General concepts::             
@end ifset
* Graphics setup @MGL{}::        
* Axis settings @MGL{}::         
* Transformation matrix @MGL{}::  
* Export to file @MGL{}::        
* Primitives drawing @MGL{}::    
* Text printing @MGL{}::         
* Axis and Colorbar @MGL{}::     
* Legend @MGL{}::                
* 1D plotting @MGL{}::           
* 2D plotting @MGL{}::           
* 3D plotting @MGL{}::           
* Dual plotting @MGL{}::         
* Vector fields @MGL{}::         
* Other plotting @MGL{}::        
* Nonlinear fitting @MGL{}::     
* Data create @MGL{}::           
* Data filling @MGL{}::          
* Rearrange data @MGL{}::        
* File I/O @MGL{}::              
* Make another data @MGL{}::     
* Change data @MGL{}::  
* Operators @MGL{}::             
* Program flow @MGL{}::          
* Command options @MGL{}::       
* Suffixes::                    
* Utilities::                   
@end menu

@c ##################################################################
@ifset UDAV
@node  General concepts, , Utilities, MGL interface
@section Основные принципы

Возможности библиотеки MathGL довольно богаты -- число только основных типов графиков превышает 50 видов. Кроме того, есть функции для обработки данных, настройки вида графика и пр. и пр. Тем не менее, я старался придерживаться единого стиля в порядке аргументов функций и способе их ``настройки''. В основном все ниже сказанное относится к функциям рисования различных графиков.

Всего основных концепций (базисных идей) четыре:
@enumerate
@item
@strong{Все настройки графиков (стиль линий, цветовые схемы поверхностей, стиль и цвет текста) задаются строками.} Это обеспечивает: удобство для пользователя -- короткую строку легче читать и здесь тяжелее ошибиться, чем в большом списке параметров; переносимость -- строки выглядят одинаково на всех платформах и не надо заботиться о типе и числе аргументов.
@item
@strong{Все функции имеют ``упрощенный'' и ``продвинутый'' варианты.} Сделано опять из-за удобства. В ``упрощенном'' варианте для построения графика нужны только один-два массив(а) данных, которые автоматически равнораспределяются в заданном диапазоне осей координат. В ``продвинутой'' версии можно не только указать явно диапазон построения графика, но и задать его параметрически. Последнее позволяет легко строить довольно сложные кривые и поверхности. В обоих вариантах функций порядок аргументов стандартен: сначала идут массивы данных, потом необязательный строковый параметр стиля графика, а далее -- второстепенные необязательные параметры для более точной настройки графика.
@item
@strong{Все элементы рисунков векторные.} Изначально библиотека MathGL была ориентированна на работу с научными данными, которые по своей природе векторные (линии, грани, матрицы и т.д.). Поэтому векторность используется во всех рисунках! Причем иногда даже в ущерб производительности (например, при выводе шрифтов). Помимо всего прочего, векторность позволяет легко масштабировать рисунок -- измените размер картинки в 2 раза, и рисунок пропорционально растянется.
@item
@strong{Новые графики не удаляют уже нарисованное.} Этот, в чем-то неожиданный, подход позволяет создавать огромное количество ``комбинированных'' графиков. Например, поверхность с наложенными линиями уровня строится двумя последовательными вызовами функций рисования поверхности и линий уровня (в любом порядке). И совершенно не надо писать специальную функцию (как в Matlab и некоторых других программах) для рисования этого графика. Примеров таких графиков можно привести множество (см. раздел @ref{Hints} и сайт программы @uref{http://mathgl.sf.net/index.html}).
@end enumerate

Кроме основных концепций я хотел бы остановиться на нескольких, как оказалось, нетривиальных моментах -- способе указания положения графика, осей координат и строковых параметров линий, поверхностей, текста.

@menu
* Coordinate axes::             
* Line styles::                 
* Color scheme::                
* Font styles::                  
* Textual formulas::            
@end menu

@include concept_ru.texi

@node Graphics setup @MGL{}, Axis settings @MGL{}, General concepts, MGL interface
@end ifset
@ifclear UDAV

@c ##################################################################
@node Graphics setup @MGL{}, Axis settings @MGL{}, , MGL interface
@end ifclear
@section Настройка графика @MGL{}

Команды в этой группе влияют на вид всего рисунка. Соответственно они должны располагаться @emph{перед} вызовом функций непосредственно рисующих графики.

@menu
* Transparency @MGL{}::          
* Lighting @MGL{}::              
* Fog @MGL{}::                   
* Default sizes @MGL{}::         
* Zooming @MGL{}::               
* Cutting @MGL{}::               
* Other settings @MGL{}::        
@end menu

@c ==================================================================
@node Transparency @MGL{}, Lighting @MGL{}, , Graphics setup @MGL{}
@subsection Прозрачность @MGL{}

Эти команды настраивают тип и степень прозрачности поверхностей. Главной является функция @ref{alpha}, которая включает/выключает прозрачность для всех графиков, созданных после вызова @ref{alpha}. Функция @ref{alphadef} устанавливает величину alpha-канала по умолчанию. Прозрачность можно выключить для отдельного графика с помощью @ref{transparent}. Наконец, функция @ref{transptype} задает тип прозрачности. @sref{Transparent surface sample}

@cindex alpha
@anchor{alpha}
@deffn {Команда MGL} alpha @code{[val=on]}
Включает/выключает прозрачность для @emph{всего} рисунка. По умолчанию прозрачность выключена. Используйте @code{transparent off} для конкретного графика для выключения прозрачности.
@end deffn
@cindex alphadef
@anchor{alphadef}
@deffn {Команда MGL} alphadef @code{val}
Задает значение прозрачности по умолчанию для всех графиков. Начальное значение 0.5.
@end deffn
@cindex transparent
@anchor{transparent}
@deffn {Команда MGL} transparent @code{val}
Временно включает/возвращает прозрачность графиков.
@end deffn
@cindex transptype
@anchor{transptype}
@deffn {Команда MGL} transptype @code{val}
Задает тип прозрачности. Обычная прозрачность (@samp{0}) -- "закрытые" объекты видны меньше чем закрывающие. "Стеклянная" прозрачность (@samp{1}) -- закрытые и закрывающие объекты единообразно ослабляют интенсивность света (по RGB каналам). "Ламповая" прозрачность (@samp{2}) -- закрытые и закрывающие объекты являются источниками дополнительного освещения (рекомендую установить @code{alphadef 0.3} или меньше в этом случае). @xref{Normal transparency}, @ref{Glass-like transparency}, @ref{Lamp-like transparency}.
@end deffn

@c ==================================================================
@node Lighting @MGL{}, Fog @MGL{}, Transparency @MGL{}, Graphics setup @MGL{}
@subsection Освещение @MGL{}

Эти функции настраивают освещение графика. Главная функция @ref{light} включает/выключает освещение графиков построенных после ее вызова. MathGL  поддерживает до 10 независимых источников света. Положение, цвет, яркость каждого источника света можно задавать по отдельности. По умолчанию включен только первый (с порядковым номером @code{0}) источник света белого цвета, расположенный сверху.

@cindex light
@anchor{light}
@deffn {Команда MGL} light @code{[val=on]}
Включает/выключает освещение графика. По умолчанию освещение выключено.
@end deffn
@deffn {Команда MGL} light @code{n val}
Включает/выключает @var{n}-ый источник света.
@end deffn

@deffn {Команда MGL} light @code{n xpos ypos zpos} ['col'='w' @code{br=0.5}]
Добавляет источник света с номером @var{n} в положение @{@var{xpos}, @var{ypos}, @var{zpos}@} с цветом @var{col} и яркостью @var{br}, которая должна быть в диапазоне [0,1].
@end deffn

@cindex ambient
@anchor{ambient}
@deffn {Команда MGL} ambient @code{val}
Задает яркость рассеянного освещения. Значение должно быть в диапазоне [0,1].
@end deffn

@c ==================================================================
@node Fog @MGL{}, Default sizes @MGL{}, Lighting @MGL{}, Graphics setup @MGL{}
@subsection Туман @MGL{}

@cindex fog
@anchor{fog}
@deffn {Команда MGL} fog @code{val [dz=0.25]}
Имитирует туман на графике. Туман начинается на относительном расстоянии @var{dz} от точки обзора и его плотность растет экспоненциально вглубь по закону ~@math{1-exp(-d*z)}. Здесь @emph{z} -- нормализованная на 1 глубина графика. Если @var{d}=@code{0} то туман отсутствует. @sref{Surface in fog sample}
@end deffn

@c ==================================================================
@node Default sizes @MGL{}, Zooming @MGL{}, Fog @MGL{}, Graphics setup @MGL{}
@subsection Базовые размеры @MGL{}

Эти команды задают величины большинства параметров графика, включая размеры маркеров, стрелок, толщину линий и т.д. Как и любые другие настройки, они подействуют только на графики созданные после изменения настроек.

@cindex barwidth
@anchor{barwidth}
@deffn {Команда MGL} barwidth @code{val}
Относительный размер прямоугольников в @code{bars, barh, boxplot}. Значение по умолчанию @code{0.7}.
@end deffn

@cindex marksize
@anchor{marksize}
@deffn {Команда MGL} marksize @code{val}
Размер маркеров для @ref{1D plotting}. Значение по умолчанию @code{1}.
@end deffn

@cindex arrowsize
@anchor{arrowsize}
@deffn {Команда MGL} arrowsize @code{val}
Размер стрелок для @ref{1D plotting}, линий и кривых (@pxref{Primitives drawing}). Значение по умолчанию @code{1}.
@end deffn

@cindex linewidth
@anchor{linewidth}
@deffn {Команда MGL} linewidth @code{val}
Базовая толщина линий. Значения <1 игнорируются. Для значений >1 реальная толщина получается перемножением указанной ширины линии на данное значение. Увеличение ширины линии актуально для больших растровых рисунков. Значение по умолчанию @code{1}.
@end deffn

@cindex ticklen
@anchor{ticklen}
@deffn {Команда MGL} ticklen @code{val} [@code{stt=1}]
Относительная длина меток осей координат. Значение по умолчанию @code{0.1}. Параметр @var{stt}>0 задает относительную длину подметок, которые в @code{sqrt(1+stt)} раз меньше.
@end deffn

@cindex tickstl
@anchor{tickstl}
@deffn {Команда MGL} tickstl 'stl' ['sub'='']
Стиль меток (@var{stl}) и подметок (@var{sub}) осей координат. Если @code{stl=''}, то используется стиль по умолчанию (@samp{k} или @samp{w} в зависимости от типа прозрачности). Если @code{sub=''}, то используется стиль меток (т.е. @var{stl}).
@end deffn

@c ==================================================================
@node Zooming @MGL{}, Cutting @MGL{}, Default sizes @MGL{}, Graphics setup @MGL{}
@subsection Масштабирование @MGL{}

Эти команды управляют масштабированием всего рисунка (@ref{zoom}) или отдельной картинки (@ref{plotfactor}). Обычно эти функции используются для удаления пустого места вокруг графиков.

@cindex plotfactor
@anchor{plotfactor}
@deffn {Команда MGL} plotfactor @code{val}
Масштаб картинки (значение должно быть больше 1). Не рекомендуется устанавливать значения меньше 1.5. Это аналог @ref{zoom}, но применяется только к конкретной картинке, заданной @ref{inplot}. Используйте ноль для включения автоматического масштабирования.
@end deffn

@cindex zoom
@anchor{zoom}
@deffn {Команда MGL} zoom @code{x1 y1 x2 y2}
Масштабирует весь рисунок. После вызова функции текущий график будет очищен и в дальнейшем рисунок будет содержать только область [x1,x2]*[y1,y2] от исходного рисунка. Координаты @var{x1}, @var{x2}, @var{y1}, @var{y2} меняются в диапазоне от 0 до 1. Внимание! эти настройки не могут быть переписаны никакими другими функциями. Используйте @code{zoom 0 0 1 1} для перехода в масштаб по умолчанию.
@end deffn

@c ==================================================================
@node Cutting @MGL{}, Other settings @MGL{}, Zooming @MGL{}, Graphics setup @MGL{}
@subsection Обрезание @MGL{}

Эти команды задают условия когда точка будет исключена (вырезана) из рисования. Замечу, что все точки со значением(-ями) @code{nan} по одной из координат или амплитуде автоматически исключаются из рисования.

@cindex cut
@anchor{cut}
@deffn {Команда MGL} cut @code{val}
Задает обрезание точек за пределами осей координат. Если @code{on} то такие точки исключаются из рисования (это по умолчанию) иначе они проецируются на ограничивающий прямоугольник.
@end deffn

@deffn {Команда MGL} cut @code{x1 y1 z1 x2 y2 z2}
Задает границы параллелепипеда внутри которого точки не рисуются. Если границы одинаковы (переменные равны), то параллелепипеда считается пустым. @sref{CutMinMax sample}
@end deffn

@deffn {Команда MGL} cut 'cond'
Задает условие обрезания по формуле @var{cond}. Это условие исключает точки из рисования если результат вычисления формулы не равен нулю. Установите аргумент @code{''} для выключения условия обрезания. @sref{CutOff sample}
@end deffn

@c ==================================================================
@node Other settings @MGL{}, , Cutting @MGL{}, Graphics setup @MGL{}
@subsection Прочие настройки @MGL{}

@cindex font
@anchor{font}
@deffn {Команда MGL} font 'fnt' [@code{val=6}]
Задает стиль и размер шрифта (@pxref{Text printing}). Вначале используется @samp{rC} -- прямой шрифт с выравниванием по центру. По умолчанию размер подписей оси координат в 1.4 раза больше.
@end deffn

@cindex rotatetext
@anchor{rotatetext}
@deffn {Команда MGL} rotatetext @code{val}
Включает/выключает вращение меток и подписей осей координат вдоль оси. Начальное значение @code{on}.
@end deffn

@cindex palette
@anchor{palette}
@deffn {Команда MGL} palette 'colors'
Задает палитру как последовательность цветов. Значение по умолчанию @code{"Hbgrcmyhlnqeup"}, что соответствует цветам: темно серый @samp{H}, синий @samp{b}, зеленый @samp{g}, красный @samp{r}, голубой @samp{c}, малиновый @samp{m}, желтый @samp{y}, серый @samp{h}, сине-зеленый  @samp{l}, небесно-голубой @samp{n}, оранжевый @samp{q}, желто-зеленый @samp{e}, сине-фиолетовый @samp{u}, фиолетовый @samp{p}. Палитра в основном используется в 1D графиках (@pxref{1D plotting}) для кривых с неопределенным стилем линии.
@end deffn

@cindex meshnum
@anchor{meshnum}
@deffn {Команда MGL} meshnum @code{num}
Задает ориентировочное число линий в @ref{mesh}, @ref{fall}, @ref{grid}, число стрелок (штрихов) в @ref{vect}, @ref{dew} и число ячеек в @ref{cloud}. По умолчанию (=0) рисуются все линии, стрелки, ячейки.
@end deffn

@cindex axialdir
@anchor{axialdir}
@deffn {Команда MGL} axialdir 'dir'
Задает ось вращения для @ref{axial}, @ref{torus}. По умолчанию это 'z'.
@end deffn

@c ==================================================================
@node Axis settings @MGL{}, Transformation matrix @MGL{}, Graphics setup @MGL{}, MGL interface
@section Параметры осей координат @MGL{}

Этот большой набор команд определяет вид осей и меток координат. Перед построением для каждой точки выполняются 3 преобразования: сначала определяется возможность рисования точки (@pxref{Cutting @MGL{}}), далее применяются формулы перехода к криволинейным координатам и наконец точка отображается.

@cindex axis
@anchor{axis}
@deffn {Команда MGL} axis @code{x1 y1 x2 y2}
@deffnx {Команда MGL} axis @code{x1 y1 z1 x2 y2 z2}
@cindex ranges
@anchor{ranges}
@deffnx {Команда MGL} ranges @code{x1 x2 y1 y2 [z1=0 z2=0]}
Задает диапазон изменения координат. Если минимальное и максимальное значение координаты равны, то они игнорируются по данному направлению. Также устанавливает размер цветовой шкалы, аналогично команде  @code{caxis z1 z2}. Начальные диапазоны равны [-1, 1].
@end deffn

@deffn {Команда MGL} axis 'fx' 'fy' ['fz'='' 'fa'='']
Задает формулы перехода к криволинейным координатам. Каждая строка является математическим выражением, зависящим от старых координат @samp{x}, @samp{y}, @samp{z} и @samp{a} или @samp{c} для цветовой шкалы. Например, для цилиндрических координат будет @code{axis 'x*cos(y)' 'x*sin(y)' 'z'}. Для удаления формул соответствующий параметр должен быть пустым @code{''}. Использование формул преобразования слегка замедляет программу, т.е.. @code{axis '' '' ''} быстрее чем @code{axis '1*x' '1*y' '1*z'}. Параметр @var{fa} задает аналогичную формулу для цветовой шкалы. @xref{Textual formulas}.
@end deffn

@deffn {Команда MGL} axis @code{how}
Устанавливает одну из предопределенных систем криволинейных координат в зависимости от параметра @var{how}: @samp{0} -- декартова система (нет преобразования координат, наиболее быстрая); @samp{1} -- полярные координаты @math{x_n=x*cos(y),y_n=x*sin(y), z_n=z}; @samp{2} -- сферические координаты @math{x_n=x*sin(y)*cos(z), y_n=x*sin(y)*sin(z), z_n=x*cos(y)}; @samp{3} -- параболические координаты @math{x_n=x*y, y_n=(x*x-y*y)/2, z_n=z}; @samp{4} -- Paraboloidal coordinates @math{x_n=(x*x-y*y)*cos(z)/2, y_n=(x*x-y*y)*sin(z)/2, z_n=x*y}; @samp{5} -- Oblate coordinates @math{x_n=cosh(x)*cos(y)*cos(z), y_n=cosh(x)*cos(y)*sin(z), z_n=sinh(x)*sin(y)}; @samp{6} -- Prolate coordinates @math{x_n=sinh(x)*sin(y)*cos(z), y_n=sinh(x)*sin(y)*sin(z), z_n=cosh(x)*cos(y)}; @samp{7} -- эллиптические координаты @math{x_n=cosh(x)*cos(y), y_n=sinh(x)*sin(y), z_n=z}; @samp{8} -- тороидальные координаты @math{x_n=sinh(x)*cos(z)/(cosh(x)-cos(y)), y_n=sinh(x)*sin(z)/(cosh(x)-cos(y)), z_n=sin(y)/(cosh(x)-cos(y))}; @samp{9} -- бисферические координаты @math{x_n=sin(y)*cos(z)/(cosh(x)-cos(y)), y_n=sin(y)*sin(z)/(cosh(x)-cos(y)), z_n=sinh(x)/(cosh(x)-cos(y))}; @samp{10} -- биполярные координаты @math{x_n=sinh(x)/(cosh(x)-cos(y)), y_n=sin(y)/(cosh(x)-cos(y)), z_n=z}.
@end deffn

@cindex caxis
@anchor{caxis}
@deffn {Команда MGL} caxis @code{z1 z2}
Задает масштаб цветовой шкалы (c-координаты). Эти значения используются для определения цвета поверхностей и прочих 2D и 3D графиков. Начальный диапазон равен [-1, 1].
@end deffn

@cindex origin
@anchor{origin}
@deffn {Команда MGL} origin @code{x0 y0 [z0=nan]}
Задает центр пересечения осей координат. Если одно из значений равно @code{nan}, то выбрается оптимальное положение осей координат по этому направлению.
@end deffn

@cindex ternary
@anchor{ternary}
@deffn {Команда MGL} ternary @code{val}
Задает рисование треугольных (Ternary) осей координат. Это специальный тип графика для 3 зависимых координат (компонент) @var{a}, @var{b}, @var{c} таких, что @var{a}+@var{b}+@var{c}=1. MathGL использует только 2 независимые координаты @var{a}=x и @var{b}=y поскольку их достаточно для построения всех графиков. При этом третья координата z является независимым параметром для построения линий уровня, поверхностей и т.д. @sref{Ternary plot sample}
@end deffn

@cindex xrange
@anchor{xrange}
@deffn {Команда MGL} xrange dat [@code{add=off fact=0}]
@cindex yrange
@anchor{yrange}
@deffnx {Команда MGL} yrange dat [@code{add=off fact=0}]
@cindex zrange
@anchor{zrange}
@deffnx {Команда MGL} zrange dat [@code{add=off fact=0}]
@cindex crange
@anchor{crange}
@deffnx {Команда MGL} crange dat [@code{add=off fact=0}]
Задает диапазон изменения x-,y-,z-,c- координат как минимальное и максимальное значение массива @var{dat}. Параметр @var{add} указывает добавлять новый диапазон к существующему или заменять его. Параметр @var{fact} дополнительно расширяет диапазон на величину (@var{Max}-@var{Min})*@var{fact}.
@end deffn

@deffn {Команда MGL} xrange @code{x1 x2}
@deffnx {Команда MGL} yrange @code{x1 x2}
@deffnx {Команда MGL} zrange @code{x1 x2}
@deffnx {Команда MGL} crange @code{x1 x2}
Задает диапазон изменения x-,y-,z-,c- координат. См. также @ref{axis}.
@end deffn

@cindex xtick
@anchor{xtick}
@deffn {Команда MGL} xtick @code{val [sub=0 org=nan]}
@cindex ytick
@anchor{ytick}
@deffnx {Команда MGL} ytick @code{val [sub=0 org=nan]}
@cindex ztick
@anchor{ztick}
@deffnx {Команда MGL} ztick @code{val [sub=0 org=nan]}
@cindex ctick
@anchor{ctick}
@deffnx {Команда MGL} ctick @code{val}
Задает шаг меток осей @var{val}, число подметок @var{ns} и начальное положение меток @var{org}. Переменная @var{val} задает шаг меток (если положительна) или их число на оси (если отрицательна). Нулевое значение задает логарифмические метки. Если @var{org}=@code{NAN}, то используется значение из @ref{origin}.
@end deffn

@deffn {Команда MGL} xtick 'templ'
@deffnx {Команда MGL} ytick 'templ'
@deffnx {Команда MGL} ztick 'templ'
@deffnx {Команда MGL} ctick 'templ'
Задает шаблоны для меток вдоль x-,y-,z-оси или colorbar. Шаблон может содержать и символы TeX. Если @var{xtt}, @var{ytt}, @var{ztt}, @var{ctt}=@code{''}, то используется шаблон по умолчанию (в простейшем случае @samp{%.2g}). Установка шаблона выключает автоматическое улучшение вида меток.
@end deffn

@deffn {Команда MGL} xtick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {Команда MGL} ytick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
@deffnx {Команда MGL} ztick @code{val1} 'lbl1' [@code{val2} 'lbl2' ...]
Задает явное положение @var{val} и подписи @var{lbl} для меток вдоль оси. Метки могут содержать и символы TeX.
@end deffn

@cindex adjust
@anchor{adjust}
@deffn {Команда MGL} adjust ['dir'='xyzc']
Автоматически задает шаг меток осей, число подметок и начальное положение меток для осей координат @var{dir} в виде наиболее удобном для человека.
@end deffn


@c ##################################################################
@node Transformation matrix @MGL{}, Export to file @MGL{}, Axis settings @MGL{}, MGL interface
@section Матрица преобразования @MGL{}

Эти команды контролируют где и как график будет расположен. Существует определенный порядок вызова этих функций для лучшего вида графика. Вначале должны вызываться команды @ref{subplot} или @ref{inplot} для указания местоположения вывода. После них -- команды вращения @ref{rotate} и сжатия @ref{aspect}. И наконец любые другие функции для рисования графика. Вместо вращения графика можно вызвать команды @ref{columnplot} для расположения графиков в столбец одного над другим или @ref{stickplot} для расположения в линейку.

@cindex subplot
@anchor{subplot}
@deffn {Команда MGL} subplot @code{nx ny m [dx=0 dy=0]}
Помещает последующий вывод в @var{m}-ую ячейку сетки размером @var{nx}*@var{ny} от всего рисунка. Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика". С эстетической точки зрения не рекомендуется вызывать эту функцию с различными (или не кратными) размерами сетки. Ячейка может быть дополнительно сдвинута относительно своего обычного положения на относительный размер @var{dx}, @var{dy}.
@end deffn

@deffn {Команда MGL} subplot @code{nx ny m} 'style'
Аналогично предыдущему, но место для осей/colorbar резервируется только если строка @var{style} содержит: @samp{L} или @samp{<} -- с левого края, @samp{R} или @samp{>} -- с правого края, @samp{A} или @samp{^} -- с верхнего края, @samp{U} или @samp{_} -- с нижнего края.
@end deffn

@cindex inplot
@anchor{inplot}
@deffn {Команда MGL} inplot @code{x1 x2 y1 y2 [rel=off]}
Помещает последующий вывод в прямоугольную область [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}] (исходный размер [0,1]*[0,1]). Эта функция позволяет поместить график в произвольную область рисунка. Если параметр @var{rel}=@code{on}, то используется позиция относительно текщего @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). Функция сбрасывает матрицу трансформации (повороты и сжатие графика) и должна вызываться первой для создания "подграфика".
@end deffn

@cindex columnplot
@anchor{columnplot}
@deffn {Команда MGL} columnplot @code{num ind [d=0]}
Помещает последующий вывод в @var{ind}-ую строку столбца из @var{num} строк. Положение столбца выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). Параметр @var{d} задает дополнительный зазор между строк. @sref{ColumnPlot sample}
@end deffn

@cindex stickplot
@anchor{stickplot}
@deffn {Команда MGL} stickplot @code{num ind tet phi}
Помещает последующий вывод в @var{ind}-ую ячейку "бруска" из @var{num} ячеек. При этом сам брусок повернут на углы @var{tet}, @var{phi}. Положение выбирается относительно последнего вызова @ref{subplot} (или @ref{inplot} с @var{rel}=@code{off}). @sref{StickPlot sample}
@end deffn

@cindex rotate
@anchor{rotate}
@deffn {Команда MGL} rotate @code{tetz tetx [tety=0]}
Вращает систему координат относительно осей @{x, z, y@} последовательно на углы @var{tetx}, @var{tetz}, @var{tety}.
@end deffn

@deffn {Команда MGL} rotate @code{tet x y z}
Вращает систему координат относительно вектора @{@var{x}, @var{y}, @var{z}@} на угол @var{tet}.
@end deffn

@cindex aspect
@anchor{aspect}
@deffn {Команда MGL} aspect @code{ax ay [az=1]}
Устанавливает соотношение размеров осей в отношении @var{ax:ay:az}. Для лучшего вида следует вызывать после функции @ref{rotate}.
@end deffn

@cindex perspective
@anchor{perspective}
@deffn {Команда MGL} perspective @code{val}
Добавляет (включает) перспективу для графика. Параметр @math{val ~ 1/z_@{eff@} \in [0,1)}. По умолчанию (@code{val=0}) перспектива отключена.
@end deffn

@c ##################################################################
@node Export to file @MGL{}, Primitives drawing @MGL{}, Transformation matrix @MGL{}, MGL interface
@section Экспорт в файл @MGL{}

@cindex write
@anchor{write}
@deffn {Команда MGL} write 'fname' [@code{solid=off}]
Экспортирует текущий кадр в файл 'fname' (тип определяется по расширению). Параметр @var{solid} задает вывод картинки на текущем фоне (обычно белом) или полупрозрачной. Если 'fname'='', то используется имя @samp{frame####.jpg}, где @samp{####} -- текущий номер кадра.
@end deffn

@cindex setsize
@anchor{setsize}
@deffn {Команда MGL} setsize @code{w h}
Изменяет размер картинки в пикселях. Функция должна вызываться @strong{перед} любыми функциями построения потому что полностью очищает содержимое рисунка. В некоторых программах исполнение этой команды может запрещено.
@end deffn


@c ##################################################################
@node Primitives drawing @MGL{}, Text printing @MGL{}, Export to file @MGL{}, MGL interface
@section Рисование примитивов

Эти команды рисуют рисуют простые объекты типа линий, точек, сфер, капель, конусов, и т.д.

@cindex clf
@anchor{clf}
@deffn {Команда MGL} clf
Очищает рисунок и заполняет его цветом по умолчанию (обычно белым). 
@end deffn

@cindex ball
@anchor{ball}
@deffn {Команда MGL} ball @code{x y} ['col'='r']
@deffnx {Команда MGL} ball @code{x y z} ['col'='r']
Рисует точку (шарик) с координатами @{@var{x}, @var{y}, @var{z}@} и цветом @var{col}.
@end deffn

@cindex line
@anchor{line}
@deffn {Команда MGL} line @code{x1 y1 x2 y2} ['stl'='']
@deffnx {Команда MGL} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Рисует геодезическую линию (декартовых координатах -- прямую) из точки @{@var{x1},@var{y1},@var{z1}@} в @{@var{x2},@var{y2},@var{z2}@} использую стиль линии @var{stl}. Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex curve
@anchor{curve}
@deffn {Команда MGL} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deffnx {Команда MGL} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
Рисует кривую Безье из точки @{@var{x1},@var{y1},@var{z1}@} в @{@var{x2},@var{y2},@var{z2}@} использую стиль линии @var{stl}. Касательные в точках пропорциональны @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@}. Кривая рисуется даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex facex
@anchor{facex}
@deffn {Команда MGL} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facey
@anchor{facey}
@deffnx {Команда MGL} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@cindex facez
@anchor{facez}
@deffnx {Команда MGL} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
Рисует закрашенный прямоугольник (грань) перпендикулярно оси [x,y,z] в точке @{@var{x0}, @var{y0}, @var{z0}@} цветом @var{stl} и шириной @var{wx}, @var{wy}, @var{wz} вдоль соответствующего направления. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета (полезно для градиента цвета, например @samp{wwrr}). Параметры @var{d1}!=0, @var{d2}!=0 задают дополнительный сдвиг последней точки (т.е. рисуют четырехугольник). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deffn

@cindex sphere
@anchor{sphere}
@deffn {Команда MGL} sphere @code{x0 y0 r} ['col'='r']
@deffnx {Команда MGL} sphere @code{x0 y0 z0 r} ['col'='r']
Рисует сферу радиуса @var{r} с центром в точке @{@var{x}, @var{y}, @var{z}@} цветом @var{stl}.
@end deffn

@cindex drop
@anchor{drop}
@deffn {Команда MGL} drop @code{x0 y0 dx dy r} ['col'='b' @code{sh=1 asp=1}]
@deffnx {Команда MGL} drop @code{x0 y0 z0 dx dy dz r} ['col'='b' @code{sh=1 asp=1}]
Рисует каплю радиуса @var{r} в точке @{@var{x0},@var{y0},@var{z0}@} вытянутую вдоль направления @{@var{dx},@var{dy},@var{dz}@} цветом @var{col}. Параметр @var{sh} определяет степень вытянутости: @samp{0} -- сфера, @samp{1} -- классическая капля. Параметр @var{asp} определяет относительную ширину капли (аналог "эллиптичности" для сферы). @sref{Drops sample}
@end deffn

@cindex cone
@anchor{cone}
@deffn {Команда MGL} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'stl'='' @code{edge=off}]
Рисует трубу (или усеченный конус если @var{edge}=@code{off}) между точками @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} с радиусами на концах @var{r1}, @var{r2}. Если @var{r2}<0, то полагается @var{r2}=@var{r1}. Цвет конуса задается строкой @var{stl}.
@end deffn

@cindex rect
@anchor{rect}
@deffn {Команда MGL} rect @code{x1 y1 x2 y2} ['st'='']
@deffnx {Команда MGL} rect @code{x1 y1 z1 x2 y2 z2} ['st'='']
Рисует закрашенный прямоугольник (грань) с противоположными вершинами в точках @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} цветом @var{stl}. При этом цвет может быть один для всей грани, или различным для разных вершин если указаны все 4 цвета (полезно для градиента цвета, например @samp{wwrr}). Грань будет нарисована даже если часть ее лежит вне диапазона осей координат.
@end deffn

@c ##################################################################
@node Text printing @MGL{}, Axis and Colorbar @MGL{}, Primitives drawing @MGL{}, MGL interface
@section Вывод текста @MGL{}

Команды для вывода текста позволяют вывести строку текста в произвольном месте рисунка, в произвольном направлении и вдоль произвольной кривой. Можно использовать произвольное начертание шрифта и многие ТеХ-ие команды (детальнее @pxref{Font styles}). Аргумент @var{size} определяет размер текста: размер шрифта если положителен или относительный размер (=-@var{size}*@var{fontsize}) если отрицателен.

Параметры шрифта задаются строкой, которая может содержать символы стиля (@samp{rbiwou}) и/или выравнивания (@samp{LRC}). Также строка может содержать символы цвета @samp{wkrgbcymhRGBCYMHW} (@pxref{Line styles}) после символа @samp{:}. Стили шрифта: @samp{r} -- прямой, @samp{i} -- курсив, @samp{b} -- жирный, @samp{w} -- контурный, @samp{o} -- надчеркнутый, @samp{u} -- подчеркнутый. По умолчанию используется прямой шрифт. Типы выравнивания: @samp{L} -- по левому краю (по умолчанию), @samp{C} -- по центру, @samp{R} -- по правому краю. Например, строка @samp{iC:b} соответствует курсиву синего цвета с выравниванием по центру. По умолчанию используются параметры, определенные командой @ref{font}.

Если строка содержит символы @samp{aA}, то текст выводится в абсолютных координатах (полагаются в диапазоне [0,1]). При этом используются координаты относительно рисунка (если указано @samp{A}) или относительно последнего @ref{subplot}/@ref{inplot} (если указано @samp{a}).

@cindex text
@anchor{text}
@deffn {Команда MGL} text @code{x y} 'text' ['fnt'='' @code{size=-1.4}]
@deffnx {Команда MGL} text @code{x y z} 'text' ['fnt'='' @code{size=-1.4}]
Выводит строку @var{text} от точки @{@var{x},@var{y},@var{z}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn

@deffn {Команда MGL} text @code{x y dx dy} 'text' [@code{size=-1.4}]
@deffnx {Команда MGL} text @code{x y z dx dy dz} 'text' [@code{size=-1.4}]
Выводит строку @var{text} от точки @{@var{x},@var{y},@var{z}@} вдоль направления @{@var{dx},@var{dy},@var{dz}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn

@deffn {Команда MGL} text ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {Команда MGL} text xdat ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {Команда MGL} text xdat ydat zdat 'text' ['fnt'='' @code{size=-1}]
Выводит строку @var{text} вдоль кривой @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} шрифтом @var{font}. Строка @var{font} может содержать символы: @samp{t} для вывода текста под кривой (по умолчанию), или @samp{T} для вывода текста над кривой. Если массив @var{xdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. Если массив @var{zdat} не указан, то используется @var{zdat}[i] = @var{zval}. @sref{Text sample}
@end deffn

@cindex title
@anchor{title}
@deffn {Команда MGL} title 'text' ['fnt'='' @code{size=-2}]
Выводит строку @var{text} как заголовок (сверху рисунка). Может использоваться в любом месте (даже внутри @ref{subplot}).
@end deffn

@cindex fgets
@anchor{fgets}
@deffn {Команда MGL} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deffnx {Команда MGL} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Выводит @var{n}-ую строку файла @var{fname} от точки @{@var{x},@var{y},@var{z}@} шрифтом @var{fnt} и размером @var{size}.
@end deffn


@c ##################################################################
@node Axis and Colorbar @MGL{}, Legend @MGL{}, Text printing @MGL{}, MGL interface
@section Оси и Colorbar @MGL{}

Эти команды рисуют объекты для "измерения" типа осей координат, цветовой таблицы (colorbar), сетку по осям, обрамляющий параллелепипед и подписи по осям координат. См. также @ref{Axis settings @MGL{}}.

@cindex axis
@c @anchor{}
@deffn {Команда MGL} axis ['dir'='xyz' @code{adjust=off}]
Рисует оси координат и метки на них (@pxref{Axis settings @MGL{}}) в направлениях, указанных строкой @var{dir}. Если строка содержит символ @samp{_}, то подписи меток отображаться не будут. Шрифт подписей определяется командой @ref{font}. Метки будут "подогнаны" если @var{adjust}=@code{on} (с помощью вызова @code{adjust 'dir'}). 
@end deffn

@cindex colorbar
@anchor{colorbar}
@deffn {Команда MGL} colorbar ['sch'='' @code{pos=0}]
Рисует полосу соответствия цвета и числовых значений (colorbar) для цветовой схемы @var{sch} (используется текущая для @code{sch=''}) с краю от графика. Параметр @var{pos} задает местоположение: @samp{0} - справа (по умолчанию), @samp{1} - слева, @samp{2} - сверху, @samp{3} - снизу. Если строка @var{sch} содержит @samp{<>^_}, то параметр @var{pos} определяется как: @code{pos=0} для @samp{>} (справа), @code{pos=1} для @samp{<} (слева), @code{pos=2} для @samp{^} (сверху), @code{pos=3} для @samp{_} (снизу). Если строка содержит @samp{A}, то используются абсолютные координаты (относительно рисунка). @sref{Dens sample}
@end deffn

@deffn {Команда MGL} colorbar vdat ['sch'='' @code{pos=0}]
Аналогично предыдущему, но для цветовой схемы без сглаживания с заданными значениями @var{vdat}. @sref{ContD sample}
@end deffn

@deffn {Команда MGL} colorbar 'sch' @code{pos x y w h}
Аналогично первому, но в произвольном месте графика @{@var{x}, @var{y}@} (полагаются в диапазоне [0,1]). Параметры @var{w}, @var{h} задают относительную ширину и высоту colorbar.
@end deffn

@cindex grid
@anchor{grid}
@deffn {Команда MGL} grid ['dir'='xyz' 'pen'='B']
Рисует линии сетки в направлениях перпендикулярным @var{dir}. Шаг сетки такой же как у меток осей координат. Стиль линий задается параметром @var{pen} (по умолчанию -- сплошная темно синяя линия @samp{B-}).
@end deffn

@cindex box
@anchor{box}
@deffn {Команда MGL} box ['stl'='k' @code{ticks=on}]
Рисует ограничивающий параллелепипед цветом 'stl'. При @code{ticks=on} рисуются метки в соответствии с текущими настройками осей координат @ref{axis}.
@end deffn

@cindex xlabel
@anchor{xlabel}
@deffn {Команда MGL} xlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex ylabel
@anchor{ylabel}
@deffnx {Команда MGL} ylabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex zlabel
@anchor{zlabel}
@deffnx {Команда MGL} zlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
@cindex tlabel
@anchor{tlabel}
@deffnx {Команда MGL} tlabel 'text' [@code{pos=0 size=-1.4 shift=0}]
Выводит подпись @var{text} для x-,y-,z-,t-оси (где @samp{t} -- ``тернарная'' ось @math{t=1-x-y}). Параметр @var{pos} задает положение подписи: при @var{pos}=0 -- по центру оси, при @var{pos}>0 -- около максимальных значений, при @var{pos}<0 -- около минимальных значений. Параметр @var{size} задает размер шрифта (по умолчанию в 1.4 раза больше чем у меток). @xref{Text printing @MGL{}}.
@end deffn

@c ##################################################################
@node Legend @MGL{}, 1D plotting @MGL{}, Axis and Colorbar @MGL{}, MGL interface
@section Легенда @MGL{}

Эти команды обеспечивают рисование легенды графика (полезно для @ref{1D plotting}). Запись в легенде состоит из двух строк: одна для стиля линии и маркеров, другая с текстом описания (с включенным разбором TeX-их команд), накапливаемые во внутренние массивы с помощью команды @ref{addlegend} или опции @ref{legend}. Положение легенды можно задать автоматически или вручную. Параметры @var{font} и @var{size} задают стиль и размер шрифта. Параметр @var{llen} задает относительную ширину примера линии. Ели стиль линии пустой, то соответствующий текст печатается без отступа. Если строка @var{font} содержит символ @samp{A}, то координаты легенды считаются относительно картинки (а не текущего subplot). @sref{Legend sample}

@cindex legend
@anchor{legend}
@deffn {Команда MGL} legend [@code{pos=3} 'fnt'='rL' @code{size=-1 llen=0.1}]
Рисует легенду из накопленных записей шрифтом @var{fnt} размером @var{size}. Параметр @var{pos} задает положение легенды: @samp{0} -- в нижнем левом углу, @samp{1} -- нижнем правом углу, @samp{2} -- верхнем левом углу, @samp{3} -- верхнем правом углу (по умолчанию).
@end deffn

@deffn {Команда MGL} legend @code{x y} ['fnt'='rL' @code{size=-1 llen=0.1}]
Рисует легенду из накопленных записей шрифтом @var{font} размером @var{size}. Положение легенды задается параметрами @var{x}, @var{y}, которые полагаются нормированными в диапазоне [0,1].
@end deffn

@cindex addlegend
@anchor{addlegend}
@deffn {Команда MGL} addlegend 'text' 'stl'
Добавляет описание @var{text} кривой со стилем @var{stl} (@pxref{Line styles}) во внутренний массив записей легенды. Максимальное число записей 100.
@end deffn

@cindex clearlegend
@anchor{clearlegend}
@deffn {Команда MGL} clearlegend
Очищает внутренний массив записей легенды.
@end deffn

@cindex legendbox
@anchor{legendbox}
@deffn {Команда MGL} legendbox @code{val}
Включает/выключает рисование прямоугольника вокруг легенды. По умолчанию (=@code{on}) прямоугольник рисуется.
@end deffn

@cindex legendmarks
@anchor{legendmarks}
@deffn {Команда MGL} legendmarks @code{val}
Задает число маркеров в легенде. По умолчанию используется 1 маркер.
@end deffn

@c ##################################################################
@node 1D plotting @MGL{}, 2D plotting @MGL{}, Legend @MGL{}, MGL interface
@section 1D графики @MGL{}

Эти команды строят графики для одномерных (1D) массивов. Одномерными считаются массивы, зависящие только от одного параметра (индекса) подобно кривой в параметрической форме @{x(i),y(i),z(i)@}, i=1...n. Есть 5 основных типов 1D графиков: линия (@ref{plot}), линия с заполнением (@ref{area}), ступеньки (@ref{step}), прямоугольники (@ref{bars}, @ref{barh}) и вертикальные линии (@ref{stem}). Все эти типы графиков имеют похожий интерфейс. Есть версии для рисования в пространстве и на плоскости. В последнем случае имеется возможность использования только одного массива. Стиль линии и маркеров указывается строковой переменной. Если она равна @code{''}. Кроме того, есть еще несколько типов графиков для одномерных массивов, имеющих другой интерфейс и вид: поверхность вращения кривой (@ref{torus}), диаграмма (@ref{chart}), размер ошибки (@ref{error}), маркеры переменного размера (@ref{mark}), трубками (@ref{tube}) и т.д. @sref{1D plot sample}

График рисуется для каждой строки если один из массивов матрица. Размер по 1-ой координате @strong{должен быть одинаков} для всех массивов @code{xdat.nx=ydat.nx=zdat.nx}. Если массив @var{xdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. Если массив @var{zdat} не указан, то используется @var{zdat}[i] = @var{zval}. Строка @var{stl} задает цвет и стиль линии и маркеров (@pxref{Line styles}). По умолчанию (@code{stl=''}) рисуется сплошная линия с текущим цветом из палитры.

@cindex plot
@anchor{plot}
@deffn {Команда MGL} plot ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} plot xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} plot xdat ydat zdat ['stl'='']
Рисует ломанную линию между точками @{@var{x}[i], @var{y}[i], @var{z}[i]@}. См. также @ref{area}, @ref{step}, @ref{stem}, @ref{tube}, @ref{mark}, @ref{error}, @ref{belt}, @ref{tens}. @sref{Plot sample}
@end deffn


@cindex radar
@anchor{radar}
@deffn {Команда MGL} radar adat ['stl'='' @code{r=-1}]
Рисует radar chart, представляющий собой ломанную с вершинами на радиальных линиях (типа ломанной в полярных координатах). График рисуется для каждой строки если один из массивов матрица. Параметр @var{r} задает дополнительный сдвиг данных (т.е. используется @var{a}+@var{r} вместо @var{a}). Если @code{r<0}, то @code{r=max(0, -min(a)}. Если @var{stl} содержит символ @samp{#}, то также рисуется "сетка" (радиальные линии и круг для @var{r}). См. также @ref{plot}. @sref{Radar sample}
@end deffn

@cindex tens
@anchor{tens}
@deffn {Команда MGL} tens ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tens xdat ydat cdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tens xdat ydat zdat cdat ['stl'='']
Рисует ломанную линию по точкам @{@var{x}[i], @var{y}[i], @var{z}[i]@} с цветом, определяемым массивом @var{c}[i] (типа графика натяжений). См. также @ref{plot}, @ref{mesh}, @ref{fall}. @sref{Tens sample}
@end deffn

@cindex area
@anchor{area}
@deffn {Команда MGL} area ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} area xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} area xdat ydat zdat ['stl'='']
Рисует ломанную линию по точками @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} и закрашивает ее вниз до плоскости осей координат. Можно использовать градиентное закрашивание если число указанных цветов в @var{stl} равно удвоенному числу кривых для построения. Если строка содержит символ @samp{a}, то линии рисуются одна поверх другой (с суммированием) -- того же эффекта можно достичь вызовом @code{cumsum ydat 'y'} перед построением графика. См. также @ref{plot}, @ref{bars}, @ref{stem}, @ref{region}. @sref{Area sample}
@end deffn

@cindex region
@anchor{region}
@deffn {Команда MGL} region fdat gdat ['stl'='' @code{inside=off}]
@deffnx {Команда MGL} region xdat fdat gdat ['stl'='' @code{inside=off}]
Закрашивает область между 2 кривыми @{@var{xdat}[i], @var{fdat}[i]@} и @{@var{xdat}[i], @var{gdat}[i]@}. При  @code{inside=off} закрашивается только область y1<y<y2, в противном случае также будет закращена область y2<y<y1. Можно использовать градиентное закрашивание если число указанных цветов @var{stl} равно удвоенному числу кривых для построения. См. также @ref{area}, @ref{bars}, @ref{stem}. @sref{Region sample}
@end deffn

@cindex stem
@anchor{stem}
@deffn {Команда MGL} stem ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} stem xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} stem xdat ydat zdat ['stl'='']
Рисует вертикальные линии из точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} до плоскости осей координат. См. также @ref{area}, @ref{bars}, @ref{plot}, @ref{mark}. @sref{Stem sample}
@end deffn

@cindex bars
@anchor{bars}
@deffn {Команда MGL} bars ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} bars xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} bars xdat ydat zdat ['stl'='']
Рисует вертикальные полосы (прямоугольники) из точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} до плоскости осей координат. Если строка @var{stl} содержит символ @samp{a}, то линии рисуются одна поверх другой. Если строка содержит символ @samp{f}, то рисуется график типа waterfall для определения кумулятивного эффекта последовательности положительных и отрицательных значений. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. См. также @ref{barh}, @ref{area}, @ref{stem}, @ref{chart}. @sref{Bars sample}
@end deffn

@cindex barh
@anchor{barh}
@deffn {Команда MGL} barh xdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} barh ydat xdat ['stl'='' @code{zval=nan}]
Рисует горизонтальные полосы (прямоугольники) из точек @{@var{xdat}[i], @var{ydat}[i]@} до плоскости оси y. Если массив @var{ydat} не указан, то используется массив со значениями равно распределенными вдоль оси y. Если строка @var{stl} содержит символ @samp{a}, то линии рисуются одна поверх другой. Если строка содержит символ @samp{f}, то рисуется график типа waterfall для определения кумулятивного эффекта последовательности положительных и отрицательных значений. Можно использовать разные цвета для положительных и отрицательных значений если число указанных цветов равно удвоенному числу кривых для построения. См. также @ref{bars}. @sref{Barh sample}
@end deffn

@cindex chart
@anchor{chart}
@deffn {Команда MGL} chart adat ['col'='']
Рисует цветные полосы (пояса) для массива данных @var{adat}. Число полос равно числу строк @var{adat} (равно @var{a.ny}). Цвет полос поочередно меняется из цветов указанных в @var{col} или в палитре (если @code{col=''}). Пробел в цветах соответствует прозрачному "цвету", т.е. соответствующая полоса не рисуется. Ширина полосы пропорциональна значению элемента в @var{adat}. График строится только для массивов не содержащих отрицательных значений. Если строка @var{col} содержит @samp{#}, то рисуется также черная граница полос. График выглядит лучше в 3d (после вращения системы координат) и/или в полярной системе координат (становится Pie chart). @sref{Chart sample}
@end deffn

@cindex step
@anchor{step}
@deffn {Команда MGL} step ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} step xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} step xdat ydat zdat ['stl'='']
Рисует ступеньки для точек массива @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. См. также @ref{plot}, @ref{stem}, @ref{tile}, @ref{boxs}. @sref{Step sample}
@end deffn

@cindex torus
@anchor{torus}
@deffn {Команда MGL} torus zdat ['stl'='']
@deffnx {Команда MGL} torus rdat zdat ['stl'='']
Рисует поверхность вращения кривой @{@var{rdat}[i], @var{zdat}[i], @var{zdat}[i]@} относительно оси @ref{axialdir}. Если массив @var{rdat} не указан, то используется массив со значениями равно распределенными вдоль оси x. См. также @ref{plot}, @ref{axial}. @sref{Torus sample}
@end deffn

@cindex tube
@anchor{tube}
@deffn {Команда MGL} tube ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tube ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tube xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tube xdat ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} tube xdat ydat zdat rdat ['stl'='']
@deffnx {Команда MGL} tube xdat ydat zdat @code{rval} ['stl'='']
Рисует трубу радиуса @var{rdat}[i] (or @var{rval}) вдоль кривой между точками @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. См. также @ref{plot}. @sref{Tube sample}
@end deffn

@cindex mark
@anchor{mark}
@deffn {Команда MGL} mark ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} mark xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} mark xdat ydat zdat rdat ['stl'='']
Рисует маркеры размером @var{rdat}[i]*@code{marksize} в точках @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Для рисования маркеров одинакового размера можно использовать функцию @code{plot} с невидимой линией (со стилем содержащим @samp{ }). См. также @ref{plot}, @ref{textmark}, @ref{stem}, @ref{error}. @sref{Mark sample}
@end deffn

@cindex textmark
@anchor{textmark}
@deffn {Команда MGL} textmark ydat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} textmark ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} textmark xdat ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} textmark xdat ydat zdat rdat 'txt' ['stl'='']
Рисует текст @var{txt} как маркер с размером пропорциональным @var{rdat}[i]*@code{marksize} в точках @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если массив @var{rdat} не указан, то полагается @var{rdat}[i] = 1. См. также @ref{plot}, @ref{mark}, @ref{stem}. @sref{TextMark sample}
@end deffn

@cindex error
@anchor{error}
@deffn {Команда MGL} error ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} error xdat ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} error xdat ydat xerr yerr ['stl'='' @code{zval=nan}]
Рисует размер ошибки @{@var{xerr}[i], @var{yerr}[i]@} в точках @{@var{xdat}[i], @var{ydat}[i]@} на плоскости @var{z} = @var{zval}. Такой график полезен для отображения ошибки эксперимента, вычислений и пр. См. также @ref{plot}. @sref{Error sample}
@end deffn

@cindex boxplot
@anchor{boxplot}
@deffn {Команда MGL} boxplot adat ['stl'='' @code{zval=nan}]
@deffnx {Команда MGL} boxplot xdat adat ['stl'='' @code{zval=nan}]
Рисует boxplot (называемый также как box-and-whisker diagram или как "ящик с усами") в точках @var{xdat}[i] на плоскости @var{z} = @var{zval}. Это график, компактно изображающий распределение вероятностей @var{adat}[i,j] (минимум, нижний квартиль (Q1), медиана (Q2), верхний квартиль (Q3) и максимум) вдоль второго (j-го) направления. См. также @ref{plot}, @ref{error}, @ref{bars}. @sref{BoxPlot sample}
@end deffn

@c ##################################################################
@node 2D plotting @MGL{}, 3D plotting @MGL{}, 1D plotting @MGL{}, MGL interface
@section 2D графики @MGL{}

Эти команды строят графики для двумерных (2D) массивов. Двумерными считаются массивы, зависящие только от двух параметров (индексов) подобно матрице @math{f(x_i,y_j), i=1...n, j=1...m}. Есть несколько основных типов 2D графиков: сплошная поверхность (@ref{surf}), сетчатая поверхность (@ref{mesh}), поверхность из ящиков (@ref{boxs}), поверхность из плиток (@ref{tile}), водопад (@ref{fall}), ленточки (@ref{belt}), график плотности (@ref{dens}), линии уровня (@ref{cont}), линии уровня с заполнением (@ref{contf}) и результат их вращения (@ref{axial}). В функциях @ref{cont}, @ref{contf} и @ref{axial} значения уровней можно задавать автоматически и вручную. Можно также нарисовать сетку (@ref{grid}) по массиву данных для улучшения вида графика плотности или линий уровня. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданной поверхности. @sref{1D plot sample}

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}. Предыдущая цветовая схема используется по умолчанию. Младшие размерности массивов @var{xdat}, @var{ydat}, @var{zdat} должны быть одинаковы @code{xdat.nx=zdat.nx && ydat.nx=zdat.ny} или @code{xdat.nx=ydat.nx=zdat.nx && xdat.ny=ydat.ny=zdat.ny}. Массивы @var{xdat} и @var{ydat} могут быть векторами (не матрицами как @var{zdat}). Если массивы @var{xdat}, @var{ydat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y. График строится для каждого z среза данных.

@cindex surf
@anchor{surf}
@deffn {Команда MGL} surf zdat ['sch'='']
@deffnx {Команда MGL} surf xdat ydat zdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{mesh}, @ref{dens}, @ref{belt}, @ref{tile}, @ref{boxs}, @ref{surfc}, @ref{surfa}. @sref{Surf sample}
@end deffn

@cindex mesh
@anchor{mesh}
@deffn {Команда MGL} mesh zdat ['sch'='']
@deffnx {Команда MGL} mesh xdat ydat zdat ['sch'='']
Рисует сетчатую поверхность, заданную параметрически @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. См. также @ref{surf}, @ref{fall}, @ref{meshnum}, @ref{cont}, @ref{tens}. @sref{Mesh sample}
@end deffn

@cindex fall
@anchor{fall}
@deffn {Команда MGL} fall zdat ['sch'='']
@deffnx {Команда MGL} fall xdat ydat zdat ['sch'='']
Рисует водопад для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. График удобен для построения нескольких кривых, сдвинутых вглубь друг относительно друга. Если @var{sch} содержит @samp{x}, то линии рисуются вдоль x-оси (по умолчанию линии рисуются вдоль y-оси). См. также @ref{belt}, @ref{mesh}, @ref{tens}, @ref{meshnum}. @sref{Fall sample}
@end deffn

@cindex belt
@anchor{belt}
@deffn {Команда MGL} belt zdat ['sch'='']
@deffnx {Команда MGL} belt xdat ydat zdat ['sch'='']
Рисует ленточки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Если @var{sch} содержит @samp{x}, то линии рисуются вдоль x-оси (по умолчанию линии рисуются вдоль y-оси). См. также @ref{fall}, @ref{surf}, @ref{plot}, @ref{meshnum}. @sref{Belt sample}
@end deffn

@cindex boxs
@anchor{boxs}
@deffn {Команда MGL} boxs zdat ['sch'='']
@deffnx {Команда MGL} boxs xdat ydat zdat ['sch'='']
Рисует вертикальные ящики для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. См. также @ref{surf}, @ref{dens}, @ref{tile}, @ref{step}. @sref{Boxs sample}
@end deffn

@cindex tile
@anchor{tile}
@deffn {Команда MGL} tile zdat ['sch'='']
@deffnx {Команда MGL} tile xdat ydat zdat ['sch'='']
Рисует плитки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. График может использоваться как 3d обобщение @ref{step}. См. также @ref{surf}, @ref{boxs}, @ref{step}, @ref{tiles}. @sref{Tile sample}
@end deffn

@cindex dens
@anchor{dens}
@deffn {Команда MGL} dens zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} dens xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует график плотности для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zVal}. Если @var{sch} содержит @samp{#}, то рисуется сетка. См. также @ref{surf}, @ref{cont}, @ref{contf}, @ref{boxs}, @ref{tile}, @code{dens[xyz]}. @sref{Dens sample}
@end deffn

@cindex cont
@anchor{cont}
@deffn {Команда MGL} cont vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} cont vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует линии уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=vdat}[k] если @code{zval==nan}). Линии уровня рисуются для @var{z}=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетка. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{vdat}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens}, @ref{contf}, @ref{contd}, @ref{axial}, @code{cont[xyz]}. @sref{Cont sample}
@end deffn

@deffn {Команда MGL} cont zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {Команда MGL} cont xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contf
@anchor{contf}
@deffn {Команда MGL} contf vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} contf vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=v}[k] если @code{zval=nan}). Линии уровня рисуются для @var{z}=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетка. См. также @ref{dens}, @ref{cont}, @ref{contd}, @code{contf[xyz]}. @sref{ContF sample}
@end deffn

@deffn {Команда MGL} contf zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {Команда MGL} contf xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contd
@anchor{contd}
@deffn {Команда MGL} contd vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} contd vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует закрашенные линии (контуры) уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval} (или при @var{z=v}[k] если @code{zval==nan}) цветами заданными явно. Линии уровня рисуются для @var{z}=@var{vdat}[k]. Строка @var{sch} задает цвет контуров: цвет k-го контура определяется символом @code{sch[k%strlen(sch)]}. См. также @ref{dens}, @ref{cont}, @ref{contf}, @code{cont[xyz]}. @sref{ContD sample}
@end deffn

@deffn {Команда MGL} contd zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {Команда MGL} contd xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex axial
@anchor{axial}
@deffn {Команда MGL} axial vdat zdat ['sch'='']
@deffnx {Команда MGL} axial vdat xdat ydat zdat ['sch'='']
Рисует поверхность вращения линии уровня для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Линии уровня рисуются для @var{zdat}[i,j]=@var{vdat}[k]. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. Если строка содержит символы @samp{x}, @samp{y} или @samp{z}, то ось вращения устанавливается в указанное направление (по умолчанию вдоль оси @ref{axialdir}). См. также @ref{cont}, @ref{contf}, @ref{torus}, @ref{surf3}. @sref{Axial sample}
@end deffn

@deffn {Команда MGL} axial zdat ['sch'='' @code{num=3}]
@deffnx {Команда MGL} axial xdat ydat zdat ['sch'='' @code{num=3}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex grad
@anchor{grad}
@deffn {Команда MGL} grad pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {Команда MGL} grad xdat ydat pdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {Команда MGL} grad xdat ydat zdat pdat ['sch'='' @code{num=5}]
Рисует линии градиента скалярного поля @var{pdat} заданного параметрически @{@var{xdat}[i,j], @var{ydat}[i,j]@} или @{@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]@}. Число линий пропорционально @var{num}. Линии рисуются только с границ интервала при @var{num}<0. См. также @ref{dens}, @ref{cont}, @ref{dens3}, @ref{cont3}, @ref{flow}. @sref{Grad sample}
@end deffn


@cindex grid2
@anchor{grid2}
@deffn {Команда MGL} grid2 zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} grid2 xdat ydat zdat ['sch'='' @code{zval=nan}]
Рисует плоскую сету для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} при @var{z} = @var{zval}. См. также @ref{dens}, @ref{cont}, @ref{contf}.
@end deffn


@c ##################################################################
@node 3D plotting @MGL{}, Dual plotting @MGL{}, 2D plotting @MGL{}, MGL interface
@section 3D графики @MGL{}

Эти функции строят графики для трехмерных (3D) массивов. Трехмерными считаются массивы, зависящие от трех параметров (индексов) подобно матрице @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. Есть 5 основных типов 3D графиков: поверхность постоянного уровня (@ref{surf3}), график плотности на срезе (@var{dens3}), линии уровня на срезе (@ref{cont3}), закрашенные контуры уровня на срезе (@ref{contf3}) и график объемной прозрачности типа облака (@ref{cloud}). В функциях @ref{cont3}, @ref{contf3} и @ref{surf3} значения уровней можно задавать автоматически и вручную. Можно также нарисовать на срезе сетку (@ref{grid3}) по массиву данных для улучшения вида графика плотности или линий уровня. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива. @sref{3D plot sample}

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию. Массивы @var{x}, @var{y}, @var{z} могут быть векторами (не 3d массивами как @var{a}). Если массивы @var{xdat}, @var{ydat}, @var{zdat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y, z.


@cindex surf3
@anchor{surf3}
@deffn {Команда MGL} surf3 adat @code{val} ['sch'='']
@deffnx {Команда MGL} surf3 xdat ydat zdat adat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{adat}(x,y,z)=@var{val}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{cloud}, @ref{dens3}, @ref{surf3c}, @ref{surf3a}, @ref{axial}. @sref{Surf3 sample}
@end deffn

@deffn {Команда MGL} surf3 adat ['sch'='' @code{num=5}]
@deffnx {Команда MGL} surf3 xdat ydat zdat adat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex dens3
@anchor{dens3}
@deffn {Команда MGL} dens3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {Команда MGL} dens3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует график плотности для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График рисуется на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{cont3}, @ref{contf3}, @ref{dens}, @ref{grid3}. @sref{Dens3 sample}
@end deffn

@cindex densa
@anchor{densa}
@deffn {Команда MGL} densa adat ['sch'='']
@deffnx {Команда MGL} densa xdat ydat zdat adat ['sch'='']
Рисует графики плотности на всех центральных срезах 3d данных.
@end deffn

@cindex cont3
@anchor{cont3}
@deffn {Команда MGL} cont3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {Команда MGL} cont3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует линии уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. Если @var{sch} содержит @samp{t} или @samp{T}, то значения @var{vdat}[k] будут выведены вдоль контуров над (или под) кривой. См. также @ref{dens3}, @ref{contf3}, @ref{cont}, @ref{grid3}. @sref{Cont3 sample}
@end deffn

@deffn {Команда MGL} cont3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {Команда MGL} cont3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex conta
@anchor{conta}
@deffn {Команда MGL} conta adat ['sch'='' @code{num=7}]
@deffnx {Команда MGL} conta xdat ydat zdat adat ['sch'='' @code{num=7}]
Рисует линии уровня на всех центральных срезах 3d данных.
@end deffn

@cindex contf3
@anchor{contf3}
@deffn {Команда MGL} contf3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {Команда MGL} contf3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует закрашенные линии (контуры) уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Линии рисуются для значений из массива @var{v} на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. Если @var{stl} содержит @samp{#}, то на срезе рисуется сетка. См. также @ref{dens3}, @ref{cont3}, @ref{contf}, @ref{grid3}. @sref{ContF3 sample}
@end deffn

@deffn {Команда MGL} contf3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {Команда MGL} contf3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
Как предыдущий с вектором @var{v} из @var{num} элементов равно распределенных в интервале цветовой шкалы (см., @ref{caxis}).
@end deffn

@cindex contfa
@anchor{contfa}
@deffn {Команда MGL} contfa adat ['sch'='' @code{num=7}]
@deffnx {Команда MGL} contfa xdat ydat zdat adat ['sch'='' @code{num=7}]
Рисует закрашенные линии (контуры) уровня на всех центральных срезах 3d данных.
@end deffn

@cindex grid3
@anchor{grid3}
@deffn {Команда MGL} grid3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {Команда MGL} grid3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Рисует сетку для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График рисуется на срезе @var{sval} в направлении @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@}. См. также @ref{cont3}, @ref{contf3}, @ref{dens3}, @ref{grid2}.
@end deffn

@cindex grida
@anchor{grida}
@deffn {Команда MGL} grida adat ['sch'='']
@deffnx {Команда MGL} grida xdat ydat zdat adat ['sch'='']
Рисует сетку на всех центральных срезах 3d данных.
@end deffn

@cindex cloud
@anchor{cloud}
@deffn {Команда MGL} cloud adat ['sch'='']
@deffnx {Команда MGL} cloud xdat ydat zdat adat ['sch'='']
Рисует облачный график для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). График состоит из кубиков с цветом и прозрачностью пропорциональной значениям @var{adat}. Результат похож на облако -- малые значения прозрачны, а большие нет. Число кубиков зависит от @ref{meshnum}. Параметр @var{alpha} меняет общую прозрачность графика. См. также @ref{surf3}. @sref{Cloud sample}
@end deffn

@cindex beam
@anchor{beam}
@deffn {Команда MGL} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
Рисует поверхность уровня для 3d массива @var{adat} при постоянном значении @var{adat}=@var{val}. Это специальный тип графика для @var{adat} заданного в сопровождающей системе координат вдоль кривой @var{tr} с ортами @var{g1}, @var{g2} и с поперечным размером @var{rval}. Переменная @var{flag} -- битовый флаг: @samp{0x1} - рисовать в сопровождающих (не лабораторных) координатах; @samp{0x2} - рисовать проекцию на плоскость @math{\rho-z}; @samp{0x4} - рисовать нормированное в каждом сечении поле. Размеры массивов по 1-му индексу @var{tr}, @var{g1}, @var{g2} должны быть nx>2. Размеры массивов по 2-му индексу @var{tr}, @var{g1}, @var{g2} и размер по 3-му индексу массива @var{adat} должны быть одинаковы. См. также @ref{surf3}.
@end deffn


@c ##################################################################
@node Dual plotting @MGL{}, Vector fields @MGL{}, 3D plotting @MGL{}, MGL interface
@section Парные графики @MGL{}

Эти команды строят графики для двух связанных массивов. Есть несколько основных типов 3D графиков: поверхность и поверхность уровня с окраской по второму массиву (@ref{surfc}, @ref{surf3c}), поверхность и поверхность уровня с прозрачностью по второму массиву (@ref{surfa}, @ref{surf3a}), плитки переменного размера (@ref{tiles}), диаграмма точечного отображения (@ref{map}), STFA диаграмма (@ref{stfa}). В командах @ref{surf3a} и @ref{surf3c} значения уровней можно задавать автоматически и вручную. Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива.

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию. Массивы @var{x}, @var{y}, @var{z} могут быть векторами (не 3d массивами как @var{a}). Если массивы @var{xdat}, @var{ydat}, @var{zdat} не указаны, то используются массивы со значениями равно распределенными вдоль осей x, y, z.

@cindex surfc
@anchor{surfc}
@deffn {Команда MGL} surfc zdat cdat ['sch'='']
@deffnx {Команда MGL} surfc xdat ydat zdat cdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} с цветом, заданным массивом @var{cdat}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{surf}, @ref{surfa}, @ref{surf3c}. @sref{SurfC sample}
@end deffn

@cindex surf3c
@anchor{surf3c}
@deffn {Команда MGL} surf3c adat cdat @code{val} ['sch'='']
@deffnx {Команда MGL} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но цвет задается массивом @var{cdat}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{surf3}, @ref{surfc}, @ref{surf3a}. @sref{Surf3C sample}
@end deffn

@deffn {Команда MGL} surf3c adat cdat ['sch'='' @code{num=5}]
@deffnx {Команда MGL} surf3c xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex surfa
@anchor{surfa}
@deffn {Команда MGL} surfa zdat cdat ['sch'='']
@deffnx {Команда MGL} surfa xdat ydat zdat cdat ['sch'='']
Рисует параметрически заданную поверхность @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} с прозрачностью, заданным массивом @var{cdat}[i,j]. Если @var{sch} содержит @samp{#}, то на поверхности рисуется сетка. См. также @ref{surf}, @ref{surfc}, @ref{surf3a}. @sref{SurfA sample}
@end deffn

@cindex surf3a
@anchor{surf3a}
@deffn {Команда MGL} surf3a adat cdat @code{val} ['sch'='']
@deffnx {Команда MGL} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
Рисует поверхность уровня для 3d массива, заданного параметрически @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) при @var{a}(x,y,z)=@var{val}. Аналогично @ref{surf3}, но прозрачность задается массивом @var{cdat}. Если @var{sch} содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{surf3}, @ref{surfa}, @ref{surf3c}. @sref{Surf3A sample}
@end deffn

@deffn {Команда MGL} surf3a adat cdat ['sch'='' @code{num=5}]
@deffnx {Команда MGL} surf3a xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Рисует @var{num} поверхностей уровня равномерно распределенных в интервале цветовой шкалы (см. @ref{caxis}).
@end deffn

@cindex tiles
@anchor{tiles}
@deffn {Команда MGL} tiles zdat rdat ['sch'='']
@deffnx {Команда MGL} tiles xdat ydat zdat rdat ['sch'='']
Рисует плитки для параметрически заданной поверхности @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Аналогично @ref{tile}, но размер плиток задается массивов @var{rdat}. Это создает эффект "прозрачности" при экспорте в файлы EPS. См. также @ref{surfa}, @ref{tile}. @sref{TileS sample}
@end deffn

@cindex map
@anchor{map}
@deffn {Команда MGL} map udat vdat ['sch'='' @code{pnts=on}]
@deffnx {Команда MGL} map xdat ydat udat vdat ['sch'='' @code{pnts=on}]
Визуализирует точечное отображение для матриц @{@var{udat}, @var{vdat} @} параметрически зависящих от координат @var{xdat}, @var{ydat}. Исходное положение ячейки задает ее цвет. Высота пропорциональна якобиану Jacobian(udat,vdat). График является аналогом диаграммы Арнольда. Если @code{pnts=off}, то рисуются грани, иначе цветные точки рисуются в узлах матриц (полезно для "запутанного" отображения). @sref{Map sample}
@end deffn

@cindex stfa
@anchor{stfa}
@deffn {Команда MGL} stfa re im @code{dn} ['sch'='' @code{pnts=on}]
@deffnx {Команда MGL} stfa xdat ydat re im @code{dn} ['sch'='' @code{pnts=on}]
Рисует спектрограмму комплексного массива @var{re}+i*@code{im} для Фурье размером @var{dn} точек. Параметр @var{dn} -- любое четное число. Например в 1D случае, результатом будет график плотности от массива @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} размером @{int(nx/dn), dn, ny@}. Массивы @var{re}, @var{im} параметрически зависят от координат @var{xdat}, @var{ydat}. @sref{STFA sample}
@end deffn




@c ##################################################################
@node Vector fields @MGL{}, Other plotting @MGL{}, Dual plotting @MGL{}, MGL interface
@section Векторные поля @MGL{}

Эти функции рисуют графики для 2D и 3D векторных полей. Есть несколько типов графиков: просто векторное поле (@ref{vect}), вектора вдоль траектории (@ref{traj}), векторное поле каплями (@ref{dew}), нити тока (@ref{flow}), трубки тока (@ref{pipe}). Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива.

Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию. Все размеры массивов @var{ax} и @var{ay} должны быть одинаковы. Младшие размерности массивов @var{x}, @var{y} и @var{ax} должны быть одинаковы. Массивы @var{x} и @var{y} могут быть векторами (не матрицами как @var{ax}). График строится для каждого z среза @var{ax}, @var{ay} для 2D случаев.

@cindex traj
@anchor{traj}
@deffn {Команда MGL} traj xdat ydat udat vdat ['sch'='' @code{zval=nan len=0}]
@deffnx {Команда MGL} traj xdat ydat zdat udat vdat wdat ['sch'='' @code{len=0}]
Рисует вектора @{@var{udat}, @var{vdat}, @var{wdat}@} вдоль кривой @{@var{xdat}, @var{ydat}, @var{zdat}@}. Длина векторов пропорциональна @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. Строка @var{pen} задает цвет (@pxref{Line styles}). По умолчанию (@code{pen=''}). Параметр @var{len} задает фактор длины векторов (если не нуль) или выбирать длину пропорционально расстоянию между точками кривой (если @var{len}=0). См. также @ref{vect}. @sref{Traj sample}
@end deffn

@cindex vect
@anchor{vect}
@deffn {Команда MGL} vect udat vdat ['sch'='' @code{zval=nan flag=0}]
@deffnx {Команда MGL} vect xdat ydat udat vdat ['sch'='' @code{zval=nan flag=0}]
Рисует векторное поле @{@var{udat}, @var{vdat}@} параметрически зависящее от координат @var{xdat}, @var{ydat} на плоскости при @var{z}=@var{zval}. Длина и цвет векторов пропорциональна @math{\sqrt@{ax^2+ay^2@}}. Число рисуемых векторов зависит от @ref{meshnum}. Параметр @var{flag} побитовый флаг для настройки вид векторов: @code{1} -- двуцветный вектор, @code{2} -- одинаковая длина векторов, @code{4} -- рисует стрелку в точку сетки, @code{8} -- рисует стрелку с серединой в точке сетки, @code{16} -- рисует штрихи вместо стрелок. См. также @ref{flow}, @ref{dew}, @ref{vectc}. @sref{Vect sample}
@end deffn

@deffn {Команда MGL} vect udat vdat wdat ['sch'='' @code{flag=0}]
@deffnx {Команда MGL} vect xdat ydat zdat udat vdat wdat ['sch'='' @code{flag=0}]
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а длина и цвет пропорциональны @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Vect 3D sample}
@end deffn

@cindex vectc
@anchor{vectc}
@deffn {Команда MGL} vectc udat vdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} vectc xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Аналогично @ref{vect} c @code{flag=2+16=18}. @sref{VectC sample}
@end deffn

@deffn {Команда MGL} vectc udat vdat wdat ['sch'='']
@deffnx {Команда MGL} vectc xdat ydat zdat udat vdat wdat ['sch'='']
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а длина и цвет пропорциональны @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectC 3D sample}
@end deffn

@cindex vectl
@anchor{vectl}
@deffn {Команда MGL} vectl udat vdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} vectl xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Аналогично @ref{vect} c @code{flag=1+16=17}. @sref{VectL sample}
@end deffn

@deffn {Команда MGL} vectl udat vdat wdat ['sch'='']
@deffnx {Команда MGL} vectl xdat ydat zdat udat vdat wdat ['sch'='']
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а длина и цвет пропорциональны @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectL 3D sample}
@end deffn

@cindex dew
@anchor{dew}
@deffn {Команда MGL} dew udat vdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} dew xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Рисует капли для векторного поля @{@var{udat}, @var{vdat}@}, параметрически зависящего от координат @var{xdat}, @var{ydat} при @var{z=zval}. Замечу, что график требует много памяти и процессорного времени для своего создания! Цвет капель пропорционален @math{\sqrt@{ax^2+ay^2@}}. Число капель определяется @ref{meshnum}. См. также @ref{vect}. @sref{Dew sample}
@end deffn

@cindex flow
@anchor{flow}
@deffn {Команда MGL} flow udat vdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {Команда MGL} flow xdat ydat udat vdat ['sch'='' @code{num=5 zval=nan}]
Рисует нити тока для векторного поля @{@var{udat}, @var{vdat}@}, параметрически зависящего от координат @var{xdat}, @var{ydat} на плоскости при z = @var{zval}. Число нитей пропорционально @var{num}. При @var{num}>0 нитей могут стартовать и изнутри сетки, в противном случае только с краев. Цвет нитей пропорционален @math{\sqrt@{udat^2+vdat^2@}}. Теплые цвета соответствуют нормальному току (типа стока). Холодные цвета соответствуют обратному току (типа источника). См. также @ref{pipe}, @ref{vect}. @sref{Flow sample}
@end deffn

@deffn {Команда MGL} flow udat vdat wdat ['sch'='' @code{num=3}]
@deffnx {Команда MGL} flow xdat ydat zdat udat vdat wdat ['sch'='' @code{num=3}]
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а цвет пропорционален @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn

@deffn {Команда MGL} flow @code{x0 y0} udat vdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} flow @code{x0 y0} xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Рисует нить тока из точки @{@var{x0}, @var{y0}@} для векторного поля @{@var{udat}, @var{vdat}@}, параметрически зависящего от координат @var{xdat}, @var{ydat} на плоскости при z = @var{zval}. Цвет нити пропорционален @math{\sqrt@{udat^2+vdat^2@}}. Теплые цвета соответствуют нормальному току (типа стока). Холодные цвета соответствуют обратному току (типа источника).
@end deffn

@deffn {Команда MGL} flow @code{x0 y0 z0} udat vdat wdat ['sch'='']
@deffnx {Команда MGL} flow @code{x0 y0 z0} xdat ydat zdat udat vdat wdat ['sch'='']
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а цвет пропорционален @math{\sqrt@{udat^2+vdat^2+wdat^2@}}.
@end deffn


@cindex pipe
@anchor{pipe}
@deffn {Команда MGL} pipe udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
@deffnx {Команда MGL} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
Рисует трубки тока для векторного поля @{@var{udat}, @var{vdat}@}, параметрически зависящего от координат @var{xdat}, @var{ydat} на плоскости при z = @var{zval}. Число трубок пропорционально @var{num}. При @var{num}>0 нитей могут стартовать и изнутри сетки, в противном случае только с краев. Цвет и радиус трубок пропорционален @math{\sqrt@{udat^2+vdat^2@}}. Теплые цвета соответствуют нормальному току (типа стока). Холодные цвета соответствуют обратному току (типа источника). Параметр @var{r0} задает радиус трубок. При @var{r0}<0 радиус трубок обратно пропорционален их амплитуде. См. также @ref{flow}, @ref{vect}. @sref{Pipe sample}
@end deffn

@deffn {Команда MGL} pipe udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
@deffnx {Команда MGL} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
Это 3D версия графика. Здесь массивы @var{udat}, @var{vdat}, @var{wdat} должны быть 3d массивами, а цвет пропорционален @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Pipe 3D sample}
@end deffn


@c ##################################################################
@node Other plotting @MGL{}, Nonlinear fitting @MGL{}, Vector fields @MGL{}, MGL interface
@section Прочие графики @MGL{}

Это команды, не относящиеся к какой-то специальной категории. Сюда входят функции построения графиков по текстовым формулам (@ref{fplot}, @ref{fsurf}), рисования поверхностей из треугольников (@ref{triplot}), произвольных точек в пространстве (@ref{dots}) и реконструкции по ним поверхности (@ref{crust}), графики плотности и линии уровня на плоскостях, перпендикулярных осям x, y или z (dens[xyz], cont[xyz], contf[xyz]). Каждый тип графика имеет похожий интерфейс. Есть версия для рисования одного массива с автоматическими координатами и версия для параметрически заданного массива. Строка @var{sch} задает цветовую схему (@pxref{Color scheme}). Предыдущая цветовая схема используется по умолчанию.

@cindex densx
@cindex densy
@cindex densz
@anchor{densx} @anchor{densy} @anchor{densz}
@deffn {Команда MGL} densx dat ['sch'='' @code{val=nan}]
@deffnx {Команда MGL} densy dat ['sch'='' @code{val=nan}]
@deffnx {Команда MGL} densz dat ['sch'='' @code{val=nan}]
Рисуют график плотности на x, y или z плоскостях. Если @var{dat} -- 3d массив, то выполняется интерполяция к заданному срезу @var{val}. Функции полезны для создания проекций 3D массивов на оси координат. См. также @code{cont[xyz], contf[xyz]}, @ref{dens}. @sref{Dens projection sample}
@end deffn

@cindex contx
@cindex conty
@cindex contz
@anchor{contz} @anchor{conty} @anchor{contx}
@deffn {Команда MGL} contx dat ['sch'='' @code{val=nan num=7}]
@deffnx {Команда MGL} conty dat ['sch'='' @code{val=nan num=7}]
@deffnx {Команда MGL} contz dat ['sch'='' @code{val=nan num=7}]
Рисуют линии уровня на x, y или z плоскостях. Если @var{dat} -- 3d массив, то выполняется интерполяция к заданному срезу @var{val}. Функции полезны для создания проекций 3D массивов на оси координат. См. также @code{dens[xyz], contf[xyz]}, @ref{cont}. @sref{Cont projection sample}
@end deffn

@cindex contfx
@cindex contfy
@cindex contfz
@anchor{contfz} @anchor{contfy} @anchor{contfx}
@deffn {Команда MGL} contfx dat ['sch'='' @code{val=nan num=7}]
@deffnx {Команда MGL} contfy dat ['sch'='' @code{val=nan num=7}]
@deffnx {Команда MGL} contfz dat ['sch'='' @code{val=nan num=7}]
Рисуют закрашенные контуры уровня на x, y или z плоскостях. Если @var{dat} -- 3d массив, то выполняется интерполяция к заданному срезу @var{val}. Функции полезны для создания проекций 3D массивов на оси координат. См. также @code{dens[xyz], cont[xyz]}, @ref{contf}.
@end deffn

@cindex dots
@anchor{dots}
@deffn {Команда MGL} dots xdat ydat zdat ['sch'='']
@deffnx {Команда MGL} dots xdat ydat zdat adat ['sch'='']
Рисует произвольно расположенные точки @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если определен массив @var{adat}[i], то он задает прозрачность точек. См. также @ref{crust}, @ref{mark}, @ref{plot}. @sref{Dots sample}
@end deffn

@cindex crust
@anchor{crust}
@deffn {Команда MGL} crust xdat ydat zdat ['sch'='']
Реконструирует и рисует поверхность по произвольно расположенным точкам @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. См. также @ref{dots}, @ref{triplot}. @sref{Crust sample}
@end deffn

@cindex triplot
@anchor{triplot}
@deffn {Команда MGL} triplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} triplot idat xdat ydat zdat ['sch'='']
@deffnx {Команда MGL} triplot idat xdat ydat zdat cdat ['sch'='']
Рисует поверхность из треугольников. Вершины треугольников задаются индексами @var{idat} в массиве точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. Размер по 1-му индексу массива @var{idat} должен быть 3 или больше. Массивы @var{xdat}, @var{ydat}, @var{zdat} должны иметь одинаковые размеры. Массив @var{cdat} задает цвет треугольников (если @var{idat}.ny=@var{cdat}.nx) или цвет вершин (если @var{xdat}.nx=@var{cdat}.nx). См. также @ref{dots}, @ref{crust}, @ref{quadplot}, @ref{tricont}.
@end deffn

@cindex tricont
@anchor{tricont}
@deffn {Команда MGL} tricont vdat idat xdat ydat zdat cdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} tricont vdat idat xdat ydat zdat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} tricont idat xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
Рисует линии уровня поверхности из треугольников при @var{z} = @var{zval} (или для z=@var{vdat}[k] если @code{zval==NAN}). Вершины треугольников задаются индексами @var{idat} в массиве точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Размер по 1-му индексу массива @var{idat} должен быть 3 или больше. Массивы @var{xdat}, @var{ydat}, @var{zdat} должны иметь одинаковые размеры. Массив @var{cdat} (если указан) задает цвет треугольников (если @var{idat}.ny=@var{cdat}.nx) или цвет вершин (если @var{xdat}.nx=@var{cdat}.nx). См. также @ref{triplot}, @ref{cont}.
@end deffn

@cindex quadplot
@anchor{quadplot}
@deffn {Команда MGL} quadplot idat xdat ydat ['sch'='' @code{zval=nan}]
@deffnx {Команда MGL} quadplot idat xdat ydat zdat ['sch'='']
@deffnx {Команда MGL} quadplot idat xdat ydat zdat cdat ['sch'='']
Рисует поверхность из четырехугольников. Вершины треугольников задаются индексами @var{idat} в массиве точек @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. Если строка содержит @samp{#}, то рисуется сетчатая поверхность. Размер по 1-му индексу массива @var{idat} должен быть 4 или больше. Массивы @var{xdat}, @var{ydat}, @var{zdat} должны иметь одинаковые размеры. Массив @var{cdat} задает цвет четырехугольников (если @var{idat}.ny=@var{cdat}.nx) или цвет вершин (если @var{xdat}.nx=@var{cdat}.nx). См. также @ref{triplot}.
@end deffn

@cindex fplot
@anchor{fplot}
@deffn {Команда MGL} fplot 'y(x)' ['pen'='' @code{zval=nan num=100}]
Рисует функцию @samp{y(x)} в плоскости z=@var{zval} с координатой @samp{x} в диапазоне x-оси координат. Параметр @var{num} задает минимальное число точек по координате для графика. См. также @ref{plot}.
@end deffn

@deffn {Команда MGL} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='' @code{num=100}]
Рисует параметрическую кривую @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@}, где координата @samp{t} меняется в диапазоне [0, 1]. Параметр @var{num} задает минимальное число точек по координате для графика. См. также @ref{plot}.
@end deffn

@cindex fsurf
@anchor{fsurf}
@deffn {Команда MGL} fsurf 'z(x,y)' ['sch'='' @code{num=100}]
Рисует поверхность @samp{z(x,y)} с координатами @samp{x}, @samp{y} в диапазоне x-,y-осей координат. Параметр @var{num} задает минимальное число точек по координатам для графика. См. также @ref{surf}.
@end deffn

@deffn {Команда MGL} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='' @code{num=100}]
Рисует параметрическую поверхность @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@}, где координаты @samp{u}, @samp{v} меняются в диапазоне [0, 1]. Параметр @var{num} задает минимальное число точек по координатам для графика. См. также @ref{surf}.
@end deffn


@c ##################################################################
@node Nonlinear fitting @MGL{}, Data create @MGL{}, Other plotting @MGL{}, MGL interface
@section Nonlinear fitting @MGL{}

Эти команды подбирают параметры функций для наилучшей аппроксимации данных, т.е. минимизируют сумму @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. При этом аппроксимирующая функция @samp{f} может зависеть от одного аргумента @samp{x} (1D случай), от двух аргументов @samp{x,y} (2D случай) или от трех аргументов @samp{x,y,z} (3D случай). Функция @samp{f} также может зависеть от параметров. Список параметров задается строкой @var{var} (например, @samp{abcd}). Обычно пользователь должен предоставить начальные значения параметров в переменной @var{ini}. Однако, при его отсутствии используются нулевые значения.

Команды @ref{fit} и @ref{fits} не рисуют полученные массивы. Они заполняют массив @var{fit} по формуле @samp{f} с найденными коэффициентами. При этом, координаты @samp{x,y,z} равно распределены в вдоль осей координат. Число точек в @var{fit} выбирается максимальным из размера массива @var{fit} и 100. Формулу с найденными коэффициентами можно вывести с помощью команды @ref{putsfit}. @sref{Fitting sample}

Размерность массивов должны быть не меньше, чем число указанных массивов @var{xdat}, @var{ydat}, @var{zdat}. Также подбор коэффициентов будет осуществляться только вдоль указанных направлений (например, вдоль x и y если указаны только @var{xdat} и @var{ydat}). Если массив @var{xdat} не указан, то используется массив со значениями равно распределенными вдоль оси x.

@cindex fits
@anchor{fits}
@deffn {Команда MGL} fits adat sdat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fits xdat adat sdat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fits xdat ydat adat sdat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fits xdat ydat zdat adat sdat 'func' 'var' [ini=0]
"Подгоняют" формулу вдоль x-, y- и z-направлений для массива заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) с весовыми коэффициентами @var{sdat}[i,j,k].
@end deffn

@cindex fit
@anchor{fit}
@deffn {Команда MGL} fit adat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fit xdat adat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fit xdat ydat adat 'func' 'var' [ini=0]
@deffnx {Команда MGL} fit xdat ydat zdat adat 'func' 'var' [ini=0]
"Подгоняют" формулу вдоль x-, y- и z-направлений для массива заданного параметрически @var{a}[i,j,k](@var{x}[i,j,k], @var{y}[i,j,k], @var{z}[i,j,k]) с весовыми коэффициентами равными 1.
@end deffn

@cindex putsfit
@anchor{putsfit}
@deffn {Команда MGL} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
Печатает последнюю подобранную формулу с найденными коэффициентами в точке @{@var{x}, @var{y}@}. Строка @var{pre} будет напечатана перед формулой. Все другие параметры такие же как в @ref{Text printing @MGL{}}.
@end deffn


@c ##################################################################
@node Data create @MGL{}, Data filling @MGL{}, Nonlinear fitting @MGL{}, MGL interface
@section Создание данных @MGL{}

@cindex new
@anchor{new}
@deffn {Команда MGL} new dat [@code{nx=1 ny=1 nz=1}]
Создает/пересоздает массив с именем @var{dat} данных указанного размера и заполняет его нулями. Ничего не делает при @var{nx}, @var{ny}, @var{nz} отрицательных или равных нулю.
@end deffn

@cindex var
@anchor{var}
@deffn {Команда MGL} var dat @code{num v1 [v2=nan]}
Создает одномерный массив с именем @var{dat} размером @code{num} и заполняет его равномерно в диапазоне [@var{v1}, @var{v2}]. Если @var{v2}=@code{nan}, то используется @var{v2=v1}. 
@end deffn

@cindex list
@anchor{list}
@deffn {Команда MGL} list dat @code{v1 ...}
Создает массив с именем @var{dat} и заполняет его числовыми значениями аргументов @code{v1 ...}. Команда может создавать 1d- и 2d-массивы. Для создания 2d-массивов требуется указать разделитель строк данных @samp{|}. Размер массива будет [максимальное число чисел в строке * число строк]. Например, команда @code{list 1 | 2 3} создаст массив [1 0; 2 3]. Отмечу, что максимальное число аргументов 1000. 
@end deffn

@deffn {Команда MGL} list dat d1 ...
Создает массив с именем @var{dat} и заполняет его числами из массивов @code{d1 ...}. Команда может создавать 2d- и 3d-массивы (если аргументы 2d массивы). Младшие размерности всех массивов в аргументах должны быть равны размерности @var{d1}. Отмечу, что максимальное число аргументов 1000. 
@end deffn

@cindex copy
@anchor{copy}
@deffn {Команда MGL} copy dat dat2 ['eq'='' @code{on_axis=on}]
@deffnx {Команда MGL} copy dat @code{val}
Создает массив с именем @var{dat} и копирует в него данные из массива @var{dat2}. При этом, если указан параметр @var{eq}, то данные будут изменены по формуле аналогично команде @ref{fill} (для @code{on_axis=on}) или @ref{modify} (для @code{on_axis=off}).
@end deffn

@cindex idset
@anchor{idset}
@deffn {Команда MGL} idset dat 'ids'
Устанавливает символьные обозначения для колонок данных. Строка должна содержать символы 'a'...'z' один на колонку (без пробелов).
@end deffn

@cindex info
@anchor{info}
@deffn {Команда MGL} info dat [@code{detail=off}]
Выводит информацию о массиве (размер, максимальное/минимальное значение, моменты и пр.). При @code{detail=off} показывается только краткая информация.
@end deffn

@deffn {Команда MGL} info 'text'
Выводит текст @var{text} как информацию (предупреждение).
@end deffn

@c ------------------------------------------------------------------
@node Data filling @MGL{}, Rearrange data @MGL{}, Data create @MGL{}, MGL interface
@section Заполнение данных @MGL{}
@cindex fill
@cindex modify

@cindex fill
@anchor{fill}
@deffn {Команда MGL} fill dat v1 v2 ['dir'='x']
Заполняет значениями равно распределенными в диапазоне [@var{v1}, @var{v2}] в направлении @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deffn

@deffn {Команда MGL} fill dat 'eq' [vdat=0 wdat=0]
Заполняет значениями вычисленными по формуле @var{eq}. Формула представляет собой произвольное выражение, зависящее от переменных @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Координаты @samp{x}, @samp{y}, @samp{z} полагаются меняющимися в диапазоне осей координат (в отличие от @ref{modify}). Переменная @samp{u} -- значения исходного массива, переменные @samp{v}, @samp{w} -- значения массивов @var{vdat}, @var{wdat}. Последние могут быть опущены.
@end deffn

@cindex modify
@anchor{modify}
@deffn {Команда MGL} modify dat 'eq' [@code{dim=0}]
@deffnx {Команда MGL} modify dat 'eq' vdat [wdat=0]
Заполняет значениями вычисленными по формуле @var{eq}. Формула представляет собой произвольное выражение, зависящее от переменных @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Координаты @samp{x}, @samp{y}, @samp{z} полагаются меняющимися в диапазоне [0,1] (в отличие от @ref{fill}). Переменная @samp{u} -- значения исходного массива, переменные @samp{v}, @samp{w} -- значения массивов @var{vdat}, @var{wdat}. Последние могут быть опущены. Если указан @var{dim}>0, то изменяются только слои >=@var{dim}.
@end deffn


@cindex put
@anchor{put}
@deffn {MGL command} put dat @code{val [i=: j=: k=:]}
Присваивает значения (под-)массива @var{dat}[@var{i}, @var{j}, @var{k}] = @var{val}. Индексы @var{i}, @var{j}, @var{k} равные @samp{:} задают значениия @var{val} для всего диапазона соответствующего направления(ий). Например, @code{put dat val : 0 :} задает @var{dat}[i,0,j]=@var{val} для i=0...(@var{dat}.nx-1), j=0...(@var{dat}.nz-1).
@end deffn

@deffn {MGL command} put dat vdat [@code{i=: j=: k=:}]
Копирует значения из массива @var{vdat} в диапазон значений массива @var{dat}. Индексы @var{i}, @var{j}, @var{k} равные @samp{:} задают диапазон изменения значений в соответствующих направление(ях). Младшие размерности массива @var{vdat} должны быть больше выбранного диапазона массива @var{dat}. Например, @code{put dat v : 0 :} присвоит @var{dat}[i,0,j]=@var{vdat}.ny>@var{dat}.nz ? @var{vdat}[i,j] : @var{vdat}[i], где i=0...(@var{dat}.nx-1), j=0...(@var{dat}.nz-1) и условие vdat.nx>=dat.nx выполнено.
@end deffn



@c ------------------------------------------------------------------
@node Rearrange data @MGL{}, File I/O @MGL{}, Data filling @MGL{}, MGL interface
@section Изменение размеров данных @MGL{}

@cindex rearrange
@anchor{rearrange}
@deffn {Команда MGL} rearrange dat @code{mx [my=0 mz=0]}
Изменяет размерность данных без изменения самого массива данных, так что результирующий массив @var{mx}*@var{my}*@var{mz} < nx*ny*nz. Если один из параметров @var{my} или @var{mz} ноль, то он будет выбран оптимальным образом. Например, если @var{my}=0, то будет @var{my}=nx*ny*nz/@var{mx} и @var{mz}=1.
@end deffn

@cindex extend
@anchor{extend}
@deffn {Команда MGL} extend dat @code{n1 [n2=0]}
Увеличивает размер данных путем вставки (|@var{n1}|+1) новых срезов после (для @var{n1}>0) или перед (для @var{n1}<0) существующими данными. Можно добавить сразу 2 размерности для 1d массива, используя второй параметр @var{n2}. Данные в новые срезы будут скопированы из существующих. Например, для @var{n1}>0 новый массив будет
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Соответственно, для @var{n1}<0 новый массив будет @math{a_{ij}^{new} = a_j^{old}}, где i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Соответственно, для @var{n1}<0 новый массив будет a_ij^new = a_j^old, где i=0...|@var{n1}|.
@end ifnottex
@end deffn

@cindex transpose
@anchor{transpose}
@deffn {Команда MGL} transpose dat ['dim'='yxz']
Транспонирует (меняет порядок размерностей) массив данных. Новый порядок размерностей задается строкой @var{dim}.
@end deffn

@cindex squeeze
@anchor{squeeze}
@deffn {Команда MGL} squeeze dat @code{rx [ry=1 rz=1 sm=off]}
Уменьшает размер данных путем удаления элементов с индексами не кратными @var{rx}, @var{ry}, @var{rz} соответственно. Параметр @var{smooth} задает использовать сглаживания
@iftex
(т.е. @math{a_{out}[i]=\sum_{j=i,i+r}a[j]/r}) или нет (т.е. @math{a_{out}[i]=a[j*r]}).
@end iftex
@ifnottex
(т.е. out[i]=\sum_@{j=i,i+r@} a[j]/r) или нет (т.е. out[i]=a[j*r]).
@end ifnottex
@end deffn

@cindex crop
@anchor{crop}
@deffn {Команда MGL} crop dat @code{n1 n2} 'dir'
Обрезает границы данных при @var{i}<@var{n1} и @var{i}>@var{n2} (при @var{n2}>0) или @var{i}>@code{n[xyz]}-@var{n2} (при @var{n2}<=0) вдоль направления @var{dir}.
@end deffn

@cindex delete
@anchor{delete}
@deffn {Команда MGL} delete dat
Удаляет массив @var{dat} и освобождает использованную память. Может быть полезно для больших неиспользуемых массивов.
@end deffn

@deffn {Команда MGL} delete dat 'dir' @code{[pos=off num=0]}
Удаляет @var{num} срезов вдоль направления @var{dir} с позиции @var{pos}.
@end deffn

@cindex insert
@anchor{insert}
@deffn {Команда MGL} insert dat 'dir' @code{[pos=off num=0]}
Вставляет @var{num} срезов вдоль направления @var{dir} с позиции @var{pos} и заполняет их нулями.
@end deffn

@c ------------------------------------------------------------------
@node File I/O @MGL{}, Make another data @MGL{}, Rearrange data @MGL{}, MGL interface
@section Чтение/сохранение данных @MGL{}

@cindex read
@anchor{read}
@deffn {Команда MGL} read dat 'fname'
Читает данные из текстового файла с разделителями символом пробела/табуляции с автоматическим определением размера массива. Двойной перевод строки начинает новый срез данных (по направлению z).
@end deffn

@deffn {Команда MGL} read dat 'fname' @code{mx [my=1 mz=1]}
Читает данные из текстового файла с заданными размерами. Ничего не делается если параметры @var{mx}, @var{my} или @var{mz} равны нулю или отрицательны.
@end deffn

@cindex readmat
@anchor{readmat}
@deffn {Команда MGL} readmat dat 'fname' [@code{dim=2}]
Читает данные из текстового файла с размерами, указанными в первых @var{dim} числах файла. При этом переменная @var{dim} задает размерность (1d, 2d, 3d) данных.
@end deffn

@cindex readall
@anchor{readall}
@deffn {Команда MGL} readall dat 'templ' @code{v1 v2 [dv=1 slice=off]}
Объединяет данные из нескольких текстовых файлов. Имена файлов определяются вызовом функции @code{sprintf(fname,templ,val);}, где @var{val} меняется от @var{v1} до @var{v2} с шагом @var{dv}. Данные загружаются один за другим в один и тот же срез данных (при @var{slice}=@code{off}) или срез-за-срезом (при @var{slice}=@code{on}).
@end deffn

@deffn {Команда MGL} readall dat 'templ' @code{[slice=off]}
Объединяет данные из нескольких текстовых файлов, чьи имена удовлетворяют шаблону @var{templ} (например, @var{templ}=@code{"t_*.dat"}). Данные загружаются один за другим в один и тот же срез данных (при @var{slice}=@code{off}) или срез-за-срезом (при @var{slice}=@code{on}).
@end deffn

@cindex save
@anchor{save}
@deffn {Команда MGL} save dat 'fname'
Сохраняет массив данных в текстовый файл.
@end deffn

@cindex readhdf
@anchor{readhdf}
@deffn {Команда MGL} readhdf dat 'fname' 'dname'
Читает массив с именем @var{dname} из HDF5 или HDF4 файла @var{fname}.
@end deffn

@cindex savehdf
@anchor{savehdf}
@deffn {Команда MGL} savehdf dat 'fname' 'dname'
Сохраняет массив под именем @var{dname} в HDF5 или HDF4 файл @var{fname}.
@end deffn

@cindex import
@anchor{import}
@deffn {Команда MGL} import dat 'fname' 'sch' [@code{v1=0 v2=1}]
Читает данные из растрового файла. RGB значения пикселов преобразуются в число в диапазоне [@var{v1}, @var{v2}] используя цветовую схему @var{sch} (@pxref{Color scheme}).
@end deffn

@cindex export
@anchor{export}
@deffn {Команда MGL} export dat 'fname' 'sch' [@code{v1=0 v2=0}]
Сохраняет данные в растровый файл. Числовые значения, нормированные в диапазон [@var{v1}, @var{v2}], преобразуются в RGB значения пикселов, используя цветовую схему @var{sch} (@pxref{Color scheme}). Если @var{v1}>=@var{v2}, то значения @var{v1}, @var{v2} определяются автоматически как минимальное и максимальное значение данных.
@end deffn

@c ------------------------------------------------------------------
@node Make another data @MGL{}, Change data @MGL{}, File I/O @MGL{}, MGL interface
@section Создание новых данных @MGL{}

@cindex combine
@anchor{combine}
@deffn {Команда MGL} combine res adat bdat
Возвращает в массиве данных @var{res} прямое произведение массивов (наподобие, res[i,j] = adat[i]*bdat[j] и т.д.).
@end deffn

@cindex evaluate
@anchor{evaluate}
@deffn {Команда MGL} evaluate res dat idat [@code{norm=on}]
@deffnx {Команда MGL} evaluate res dat idat jdat [@code{norm=on}]
@deffnx {Команда MGL} evaluate res dat idat jdat kdat [@code{norm=on}]
Возвращает массив данных @var{res}, полученный в результате интерполяции исходного массива в точках других массивов (например, res[i,j]=dat[idat[i,j],jdat[i,j]]). Размеры массивов @var{idat}, @var{jdat}, @var{kdat} должны совпадать. Координаты в @var{idat}, @var{jdat}, @var{kdat} полагаются нормированными в диапазон [0,1] (при @var{norm}=@code{on}) или в диапазоны [0,nx], [0,ny], [0,nz] соответственно.
@end deffn

@cindex hist
@anchor{hist}
@deffn {Команда MGL} hist res dat @code{num v1 v2 [nsub=0]}
@deffnx {Команда MGL} hist res dat wdat @code{num v1 v2 [nsub=0]}
Возвращает распределение (гистограмму) @var{res} из @var{num} точек от значений массива @var{dat} в диапазоне [@var{v1}, @var{v2}]. Массив @var{wdat} задает веса элементов (все веса равны 1 если @var{wdat} не указан). Параметр @var{nsub} задает число дополнительных точек интерполяции (для сглаживания получившейся гистограммы).
@end deffn

@deffn {Команда MGL} hist res xdat adat
@deffnx {Команда MGL} hist res xdat ydat adat
@deffnx {Команда MGL} hist res xdat ydat zdat adat
Возвращает распределение (гистограмму) @var{res} от значений массива @var{adat}, параметрически зависящего от координат @{@var{xdat},@var{ydat},@var{zdat}@} в диапазоне осей координат. Массив @var{adat} играет роль веса точки. Число точек в результате @var{res} -- максимум из размера @var{res} и 100.
@end deffn


@cindex momentum
@anchor{momentum}
@deffn {Команда MGL} momentum res dat 'how' ['dir'='z']
Возвращает в массиве данных @var{res} момент (1d массив) данных @var{dat} вдоль направления @var{dir}. Строка @var{how} определяет тип момента. Момент определяется как
@iftex
@math{res_k = \sum_{ij} how(x_i,y_j,z_k) dat_{ij}/\sum_{ij} a_{ij}}
@end iftex
@ifnottex
res_k = \sum_ij how(x_i,y_j,z_k) dat_ij/ \sum_ij a_ij
@end ifnottex
если @var{dir}=@samp{z} и т.д. Координаты @samp{x}, @samp{y}, @samp{z} -- индексы массива в диапазоне [0,1].
@end deffn

@cindex sum
@anchor{sum}
@deffn {Команда MGL} sum res dat 'dir'
Возвращает в массиве данных @var{res} результат суммирования @var{dat} вдоль направления(ий) @var{dir}.
@end deffn

@cindex max
@anchor{max}
@deffn {Команда MGL} max res dat 'dir'
Возвращает в массиве данных @var{res} максимальное значение @var{dat} вдоль направления(ий) @var{dir}.
Gets array which is the maximal data values in given direction or direction(s).
@end deffn

@cindex min
@anchor{min}
@deffn {Команда MGL} min res dat 'dir'
Возвращает в массиве данных @var{res} минимальное значение @var{dat} вдоль направления(ий) @var{dir}.
@end deffn

@cindex resize
@anchor{resize}
@deffn {Команда MGL} resize res dat @code{mx [my=1 mz=1]}
Возвращает массив данных @var{res} размером @var{mx}, @var{my}, @var{mz} со значениями полученными интерполяцией значений массива @var{dat}.
@end deffn

@cindex subdata
@anchor{subdata}
@deffn {Команда MGL} subdata res dat @code{xx [yy=: zz=:]}
Возвращает в @var{res} подмассив массива данных @var{dat} с фиксированными значениями индексов с положительными значениями. Например, @code{subdata a b : 2} выделяет третью строку (индексы начинаются с нуля), @code{subdata a b 4 :} выделяет 5-ую колонку, @code{subdata a b : : 3} выделяет 4-ый срез и т.д.
@end deffn

@cindex trace
@anchor{trace}
@deffn {Команда MGL} trace res dat
Возвращает массив @var{ref} диагональных элементов @var{dat}[i,i] (для 2D данных) или @var{dat}[i,i,i] (для 3D данных) где i=0...nx-1. В 1D случае возвращается сам массив данных @var{dat}. Размеры массива данных должен быть @var{dat}.ny, @var{dat}.nz >= @var{dat}.nx или @var{dat}.ny, @var{dat}.nz = 1.
@end deffn

@cindex transform
@anchor{transform}
@deffn {Команда MGL} transform dat 'type' real imag
Выполняет интегральное преобразование комплексных данных @var{real}, @var{imag} в выбранном направлении и возвращает модуль результата в @var{res}. Порядок и тип преобразований задается строкой @var{type}: первый символ для x-направления, второй для y-направления, третий для z-направления. Возможные символы: @samp{f} -- прямое преобразование Фурье, @samp{i} -- обратное преобразование Фурье, @samp{s} -- синус преобразование, @samp{c} -- косинус преобразование, @samp{h} -- преобразование Ханкеля, @samp{n} или @samp{ } -- нет преобразования.
@end deffn

@cindex transforma
@anchor{transforma}
@deffn {Команда MGL} transforma dat 'type' ampl phase
Аналогично предыдущему с заданными амплитудой @var{ampl} и фазой @var{phase} комплексных чисел.
@end deffn

@cindex stfad
@anchor{stfad}
@deffn {Команда MGL} stfad res real imag @code{dn} ['dir'='x']
Выполняет оконное преобразование Фурье длиной @var{dn} для комплексных данных @var{real}, @var{imag} и возвращает модуль результата в @var{res}. Например, для @var{dir}=@samp{x} результат будет иметь размер @{int(nx/dn), dn, ny@} и будет равен @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deffn

@cindex pde
@anchor{pde}
@deffn {Команда MGL} pde res 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
Решает уравнение в частных производных du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], где p=-i/k0*d/dx, q=-i/k0*d/dy -- псевдо-дифференциальные операторы. Параметры @var{ini_re}, @var{ini_im} задают начальное распределение поля. Координаты в уравнении и в решении полагаются в диапазоне осей координат. Замечу, что внутри этот диапазон увеличивается в 3/2 раза для уменьшения отражения от границ расчетного интервала. Параметр @var{dz} задает шаг по эволюционной координате z. В данный момент использован упрощенный алгоритм, когда все ``смешанные'' члена (типа @samp{x*p}->x*d/dx) исключаются. Например, в 2D случае это функции типа @math{ham = f(p,z) + g(x,z,u)}. При этом допускаются коммутирующие комбинации (типа @samp{x*q}->x*d/dy). Переменная @samp{u} используется для обозначения амплитуды поля |u|. Это позволяет решать нелинейные задачи -- например, нелинейное уравнение Шредингера @code{ham='p^2+q^2-u^2'}. Также можно указать мнимую часть для поглощения (типа @code{ham = 'p^2+i*x*(x>0)'}), но только если зависимость от @samp{i} линейная, т.е. @math{ham = hre+i*him}. @sref{PDE sample}
@end deffn

@cindex ray
@anchor{ray}
@deffn {Команда MGL} ray res 'ham' @code{x0 y0 z0 p0 q0 v0 [dt=0.1 tmax=10]}
Решает систему геометрооптических уравнений d@emph{r}/dt = d @var{ham}/d@emph{p}, d@emph{p}/dt = -d @var{ham}/d@emph{r}. Это гамильтоновы уравнения для траектории частицы в 3D случае. Гамильтониан @var{ham} может зависеть от координат @samp{x}, @samp{y}, @samp{z}, импульсов @samp{p}=px, @samp{q}=py, @samp{v}=pz и времени @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. Начальная точка (при @code{t=0}) задается переменными @{@var{x0}, @var{y0}, @var{z0}, @var{p0}, @var{q0}, @var{v0}@}. Параметры @var{dt} и @var{tmax} задают шаг и максимальное время интегрирования. Результат @var{res} -- массив @{x,y,z,p,q,v,t@} с размером @{7 * int(@var{tmax}/@var{dt}+1) @}. @sref{Beam tracing sample}
@end deffn

@cindex qo2d
@anchor{qo2d}
@deffn {Команда MGL} qo2d res 'ham' ini_re ini_im ray [@code{r=1 k0=100} xx=0 yy=0]
Решает уравнение в частных производных du/dt = i*k0*@var{ham}(p,q,x,y,|u|)[u] в сопровождающей системе координат, где p=-i/k0*d/dx, q=-i/k0*d/dy -- псевдо-дифференциальные операторы. Параметры @var{ini_re}, @var{ini_im} задают начальное распределение поля. Параметр @var{ray} задает опорный луч для сопровождающей системы координат. Можно использовать луч найденный с помощью @code{ray}. Опорный луч должен быть достаточно гладкий, чтобы система координат была однозначной и для исключения ошибок интегрирования. Если массивы @var{xx} и @var{yy} указаны, то в них записываются декартовы координаты для каждой точки найденного решения. См. также @ref{pde}. @sref{Beam tracing sample} 
@end deffn

@cindex jacobian
@anchor{jacobian}
@deffn {Команда MGL} jacobian res xdat ydat [zdat=0]
Вычисляет якобиан преобразования @{i,j,k@} в @{@var{xdat},@var{ydat},@var{zdat}@}, где координаты @{i,j,k@} полагаются нормированными в интервал [0,1]. Якобиан находится по формуле det||@math{dr_\alpha/d\xi_\beta}||, где @math{r}=@{@var{xdat},@var{ydat},@var{zdat}@} и @math{\xi}=@{i,j,k@}. Все размерности всех массивов должны быть одинаковы. Данные должны быть трехмерными если указаны все 3 массива @{@var{xdat},@var{ydat},@var{zdat}@} или двумерными если только 2 массива @{@var{xdat},@var{ydat}@}.
@end deffn



@c ------------------------------------------------------------------
@node Change data @MGL{}, Operators @MGL{}, Make another data @MGL{}, MGL interface
@section Изменение данных @MGL{}

Эти команды изменяют данные вдоль заданного направления(ий) типа например дифференцирования, интегрирования и т.д. Направление указывается строкой @var{dir}, которая может содержать символы @samp{x}, @samp{y} и/или @samp{z}, вдоль которых изменения будут применены.

@cindex cumsum
@anchor{cumsum}
@deffn {Команда MGL} cumsum dat 'dir'
Суммирует с накоплением в выбранном направлении(ях).
@end deffn
@cindex integrate
@anchor{integrate}
@deffn {Команда MGL} integrate dat 'dir'
Выполняет интегрирование (подобно суммированию с накоплением) в выбранном направлении(ях).
@end deffn
@cindex diff
@anchor{diff}
@deffn {Команда MGL} diff dat 'dir'
Выполняет дифференцирование в выбранном направлении(ях).
@end deffn
@deffn {Команда MGL} diff dat xdat ydat [zdat=0]
Выполняет дифференцирование данных @var{dat}, параметрически зависящих от координат, в направлении @var{xdat} с @var{ydat}, @var{zdat}=constant. Параметр @var{zdat} может быть опущен, что соответствует 2D случаю. Используются следующие формулы (2D случай): @math{da/dx = (a_j*y_i-a_i*y_j)/(x_j*y_i-x_i*y_j)}, где @math{a_i=da/di, a_j=da/dj} обозначает дифференцирование вдоль 1-ой и 2-ой размерности. Похожие формулы используются и в 3D случае. Порядок аргументов можно менять -- например, если данные a(i,j) зависят от координат @{x(i,j), y(i,j)@}, то обычная производная по @samp{x} будет равна @code{diff a x y}, а обычная производная по @samp{y} будет равна @code{diff a y x}.
@end deffn

@cindex diff2
@anchor{diff2}
@deffn {Команда MGL} diff2 dat 'dir'
Выполняет двойное дифференцирование (как в операторе Лапласа) в выбранном направлении(ях).
@end deffn

@cindex sinfft
@anchor{sinfft}
@deffn {Команда MGL} sinfft dat 'dir'
Выполняет синус преобразование в выбранном направлении(ях). Синус преобразование есть @math{\sum a_i \sin(k i)}.
@end deffn
@cindex cosfft
@anchor{cosfft}
@deffn {Команда MGL} cosfft dat 'dir'
Выполняет косинус преобразование в выбранном направлении(ях). Синус преобразование есть @math{\sum a_i \cos(k i)}.
@end deffn
@cindex hankel
@anchor{hankel}
@deffn {Команда MGL} hankel dat 'dir'
Выполняет преобразование Ханкеля в выбранном направлении(ях). Преобразование Ханкеля есть @math{\sum a_i J_0(k i)}.
@end deffn


@cindex swap
@anchor{swap}
@deffn {Команда MGL} swap dat 'dir'
Меняет местами левую и правую части данных в выбранном направлении(ях). Полезно для отображения результата FFT.
@end deffn
@cindex roll
@anchor{roll}
@deffn {Команда MGL} roll dat 'dir' num
Сдвигает данные на @var{num} ячеек в выбранном направлении(ях). Соответствует замене индекса на @var{i}->(@var{i}+@var{num})%@var{n}.
@end deffn

@cindex mirror
@anchor{mirror}
@deffn {Команда MGL} mirror dat 'dir'
Отражает данные в выбранном направлении(ях). Соответствует замене индекса на @var{i}->@var{n}-@var{i}.
@end deffn

@cindex sew
@anchor{sew}
@deffn {Команда MGL} sew dat ['dir'='xyz' @code{da=2*pi}]
Удаляет скачки данных (например, скачки фазы после обратных тригонометрических функций) с периодом @var{da} в выбранном направлении(ях).
@end deffn

@cindex smooth
@anchor{smooth}
@deffn {Команда MGL} smooth data @code{type} ['dir'='xyz']
Сглаживает данные в выбранном направлении(ях) методом @var{type}. Сейчас поддерживаются 4 метода: @code{0} ничего не делает, @code{1} линейное усреднение по 3 точкам, @code{2} линейное усреднение по 5 точкам, @code{3} квадратичное усреднение по 5 точкам.
@end deffn

@cindex envelop
@anchor{envelop}
@deffn {Команда MGL} envelop dat ['dir'='x']
Находит огибающую данных в выбранном направлении. Только одно направление может быть выбрано за раз.
@end deffn

@cindex normsl
@anchor{normsl}
@deffn {Команда MGL} normsl dat @code{v1 v2} ['dir'='z' @code{keep=on sym=off}]
Нормирует данные срез-за-срезом в выбранном направлении @var{dir} в интервал [@var{v1},@var{v2}]. Если @var{sym}=@code{on}, то используется симметричный интервал [-max(|v1|,|v2|), max(|v1|,|v2|)]. Если @var{keep}=@code{on}, то максимальное значение k-го среза ограничено величиной
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deffn

@cindex norm
@anchor{norm}
@deffn {Команда MGL} norm dat @code{v1 v2 [sym=off dim=0]}
Нормирует данные в интервал [@var{v1},@var{v2}]. Если @var{sym}=@code{on}, то используется симметричный интервал [-max(|v1|,|v2|), max(|v1|,|v2|)]. Изменения применяются только к срезам >=@var{dim}.
@end deffn

@c ------------------------------------------------------------------
@node Operators @MGL{}, Program flow @MGL{}, Change data @MGL{}, MGL interface
@section Операторы @MGL{}

@cindex multo
@anchor{multo}
@deffn {Команда MGL} multo dat dat2
Поэлементно умножает массив @var{dat} на @var{dat2}.
@end deffn
@deffn {Команда MGL} multo dat @code{val}
Умножает каждый элемент на число.
@end deffn

@cindex divto
@anchor{divto}
@deffn {Команда MGL} divto dat dat2
Поэлементно делит массив @var{dat} на @var{dat2}.
@end deffn
@deffn {Команда MGL} divto dat @code{val}
Делит каждый элемент на число.
@end deffn

@cindex addto
@anchor{addto}
@deffn {Команда MGL} addto dat dat2
Поэлементно прибавляет @var{dat2} к массиву @var{dat}.
@end deffn
@deffn {Команда MGL} addto dat @code{val}
Прибавляет число к каждому элементу.
@end deffn

@cindex subto
@anchor{subto}
@deffn {Команда MGL} subto dat dat2
Поэлементно вычитает @var{dat2} из массива @var{dat}.
@end deffn
@deffn {Команда MGL} subto dat @code{val}
Вычитает число из каждого элемента.
@end deffn

@c ------------------------------------------------------------------
@node Program flow @MGL{}, Command options @MGL{}, Operators @MGL{}, MGL interface
@section Программирование @MGL{}

Эти команды управляют порядком выполнения других команд (условия, циклы, подпрограммы), (пере-)определяют аргументы скрипта и пр.

@cindex chdir
@anchor{chdir}
@deffn {Команда MGL} chdir 'path'
Переходит в папку @var{path}.
@end deffn

@cindex define
@anchor{define}
@deffn {Команда MGL} define $N smth
Задает @var{N}-ый аргумент скрипта равным @var{smth}. Отмечу, что @var{smth} используется как есть (с символами @samp{'} если присутствуют). Выполняется только подстановка других макроопределений $0...$9, $a...$z. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn
@deffn {Команда MGL} define name smth
Определяет константу (скаляр) с именем @code{name} и числовым значением @code{smth}. Позднее она может быть использована как обычное число.
@end deffn
@cindex defchr
@anchor{defchr}
@deffn {Команда MGL} defchr $N smth
Задает @var{N}-ый аргумент скрипта равным символу с UTF кодом @var{smth}. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn
@cindex defnum
@anchor{defnum}
@deffn {Команда MGL} defnum $N smth
Задает @var{N}-ый аргумент скрипта равным числовому значению @var{smth}. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn
@cindex defpal
@anchor{defpal}
@deffn {Команда MGL} defpal $N smth
Задает @var{N}-ый аргумент скрипта равным символу палитры с индексом, найденным из @var{smth}. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn

@cindex call
@anchor{call}
@deffn {Команда MGL} call 'fname' [ARG1 ARG2 ... ARG9]
Переходит к выполнению (вызывает) подпрограммы @var{fname} (или внешнего скрипта, если функция не была найдена). Опциональные аргументы передаются в подпрограмму. См. также @ref{func}.
@end deffn
@cindex func
@anchor{func}
@deffn {Команда MGL} func 'fname' [narg=0]
Определяет подпрограмму с именем @var{fname} и задает число требуемых аргументов. Аргументы будут помещены в параметры скрипта $1, $2, ... $9. Отмечу, что выполнение основной программы должно быть остановлено до начала определений подпрограмм. См. также @ref{stop},  @ref{return}.
@end deffn
@cindex return
@anchor{return}
@deffn {Команда MGL} return
Возвращается из подпрограммы.
@end deffn


@cindex if
@anchor{if}
@deffn {Команда MGL} if dat 'cond'
Начинает блок команд, выполняемый если каждый элемент @var{dat} удовлетворяет условию @var{cond}.
@end deffn
@deffn {Команда MGL} if @code{val}
Начинает блок команд, выполняемый если @code{val} не ноль.
@end deffn
@cindex elseif
@anchor{elseif}
@deffn {Команда MGL} elseif dat 'cond'
Начинает блок команд, выполняемый если предыдущий @code{if} или @code{elseif} не был выполнен и каждый элемент @var{dat} удовлетворяет условию @var{cond}.
@end deffn
@deffn {Команда MGL} elseif @code{val}
Начинает блок команд, выполняемый если предыдущий @code{if} или @code{elseif} не был выполнен и @code{val} не ноль.
@end deffn
@cindex else
@anchor{else}
@deffn {Команда MGL} else
Начинает блок команд, выполняемый если предыдущий @code{if} или @code{elseif} не был выполнен.
@end deffn
@cindex endif
@anchor{endif}
@deffn {Команда MGL} endif
Заканчивает определение блока @code{if/elseif/else}.
@end deffn

@cindex for
@anchor{for}
@deffn {Команда MGL} for $N @code{v1 v2 [dv=1]}
Начинает блок команд, выполняемый в цикле с $@var{N}-ым аргументом изменяющимся от @var{v1} до @var{v2} с шагом @var{dv}. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn
@deffn {Команда MGL} for $N dat
Начинает блок команд, выполняемый в цикле с $@var{N}-ым аргументом пробегающим значения массива @var{dat}. Здесь @var{N} это цифра (0...9) или буква (a...z).
@end deffn
@cindex next
@anchor{next}
@deffn {Команда MGL} next
Заканчивает блок цикла @code{for}.
@end deffn

@cindex once
@anchor{once}
@deffn {Команда MGL} once @code{val}
Определяет код (между @code{once on} и @code{once off}) который будет выполнен только один раз. Полезно для работы с большими данными в программах типа UDAV.
@end deffn
@cindex stop
@anchor{stop}
@deffn {Команда MGL} stop
Останавливает выполнение скрипта.
@end deffn

@c ------------------------------------------------------------------
@node  Command options @MGL{}, Suffixes, Program flow @MGL{}, MGL interface
@section Опции команд

Опции команд позволяют легко настроить вид отдельного графика не меняя глобальных настроек для все рисунка. Опции указываются после команды. Каждая опция отделяется от предыдущей символом @samp{;}. Опции работают так, что запоминают текущие настройки рисунка, применяют собственные настройки, выполняют команду и возвращают глобальные настройки обратно. Поэтому использование опций для команд обработки данных или настройки графика бесполезно.

Наиболее часто используемые опции -- @code{xrange, yrange, zrange}, устанавливающие границы изменения осей координат (и тем самым автоматических массивов). Например, команда @code{plot y; xrange 0.1 0.9} построит кривую с x-координатой равно распределенной в интервале 0.1 ... 0.9, а не вдоль текущей оси x.

Полный список опций:
@cindex alpha
@cindex alphadef
@deffn {Опция MGL} alpha @code{val}
@deffnx {Опция MGL} alphadef @code{val}
Задает величину прозрачности поверхности. Значение должно быть в диапазоне [0, 1]. См. также @ref{alphadef}
@end deffn
@cindex ambient
@deffn {Опция MGL} ambient @code{val}
Задает яркость фонового освещения. Значение должно быть в диапазоне [0, 1]. См. также @ref{ambient}
@end deffn
@cindex crange
@deffn {Опция MGL} crange @code{val1 val2}
Задает границы цветовой шкалы. См. также @ref{crange}
@end deffn
@cindex xrange
@deffn {Опция MGL} xrange @code{val1 val2}
Задает границы изменения координаты x. См. также @ref{xrange}
@end deffn
@cindex yrange
@deffn {Опция MGL} yrange @code{val1 val2}
Задает границы изменения координаты y. См. также @ref{yrange}
@end deffn
@cindex zrange
@deffn {Опция MGL} zrange @code{val1 val2}
Задает границы изменения координаты z. См. также @ref{zrange}
@end deffn
@cindex cut
@deffn {Опция MGL} cut @code{val}
Задает обрезание точек за пределами осей координат. См. также @ref{cut}
@end deffn
@cindex fontsize
@deffn {Опция MGL} fontsize @code{val}
Задает размер текста. См. также @ref{font}
@end deffn
@cindex marksize
@deffn {Опция MGL} marksize @code{val}
Задает размер маркеров. См. также @ref{marksize}
@end deffn
@cindex meshnum
@deffn {Опция MGL} meshnum @code{val}
Задает ориентировочное число линий, стрелок, ячеек и пр. См. также @ref{meshnum}
@end deffn
@cindex legend
@deffn {Опция MGL} legend 'txt'
Добавляет строку 'txt' во внутренний массив записей легенды. Стиль линии и маркера аргумента последней вызванной команды построения @ref{1D plotting @MGL{}}. См. также @ref{legend}
@end deffn

@c ------------------------------------------------------------------
@node  Suffixes, Utilities, Command options @MGL{}, MGL interface
@section Суффиксы переменных

Суффиксы позволяют быстро получить числовую характеристику (размер, максимальное или минимальное значение, сумму элементов и т.д.) массива данных и использовать ее как число (скаляр) в аргументах. Суффиксы начинаются с точки @samp{.} сразу после (без пробелов) имени переменной и временного массива. Например, @code{a.nx} даст размер массива @var{a} по оси х, @code{b(1).max} даст максимальное значение второй строки массива @var{b}, @code{(c(:,0)^2).sum} даст сумму квадратов элементов первой колонки массива @var{c} и т.д.

Полный список суффиксов:
@table @strong
@item nx, ny, nz
Размер массива в направлении x, y, z соответственно.
@item max
Максимальное значение массива.
@item min
Минимальное значение массива.
@item sum
Сумма элементов массива.
@item a
Первый элемент массива (элемент с индексами 0,0,0).
@item fst
Первое не нулевое значение массива.
@item lst
Последнее не нулевое значение массива.
@item mx, my, mz
Положение максимума в направлении x, y, z соответственно.
@item ax, ay, az, aa
Положение центра масс в направлении x, y, z соответственно или среднее значение массива.
@item wx, wy, wz, wa
Ширина в направлении x, y, z соответственно или дисперсия элементов массива.
@item sx, sy, sz, sa
Асимметрия в направлении x, y, z соответственно или элементов массива.
@item kx, ky, kz, ka
Эксцесс в направлении x, y, z соответственно или элементов массива.
@end table

@c ------------------------------------------------------------------
@node  Utilities, , Suffixes, MGL interface
@section Утилиты для MGL

MathGL содержит несколько программ для работы со скриптами MGL. Есть утилита для сохранения в растровое (@code{mgl2png}, @code{mgl2gif}) или векторное (@code{mgl2eps}, @code{mgl2svg}) изображения. Программа @code{mglview} показывает результат выполнения скрипта MGL и позволяет вращать и настраивать график. Также можно транслировать MGL скрипт в C++ файл с помощью программы @code{mgl2cpp}.

Все эти программы имеют схожий набор аргументов. Первым идет имя скрипта, а вторым идет имя выходного файлы (может быть опущено), последние аргументы -- опции скрипта и программы. К опциям относятся параметры скрипта (это @code{$0, $1, ... $9}) и настройки локали. Параметры скрипта имеют формат @samp{-Nval}, где N=0,1...9 -- номер параметра, val -- его значние. Например, опция @samp{-1test} заменит @code{$1} на @samp{test} в скрипте. Опция -Lval устанавливает локаль в значение val. Например, @samp{-Lutf8} будет использовать UTF-8 в скрипте.

Также можно создавать анимированные изображения GIF или набор JPEG файлов с именами @samp{frameNNNN.jpg} (где @samp{NNNN} -- номер кадра). Для этого в скрипте надо указать параметры анимации для каждого кадра (строками с коментариями @code{##a val} или опциями @samp{-Aval}) или в цикле (строкой с комментарием @code{##с v1 v2 [dv]} или опцию @samp{-Cn1:n2}), которые будут подставлены в качестве параметра @code{$0} при последовательном вызове скрипта. Для сохранения кадров в JPEG просто добавьте команду @code{write ''} в конце скрипта.


